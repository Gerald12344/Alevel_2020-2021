{"ast":null,"code":"import _classCallCheck from \"/Users/year12/Desktop/Harvey/alevel_2020-2021/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/year12/Desktop/Harvey/alevel_2020-2021/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport * as THREE from \"three\";\nimport { Perlin } from \"./Perlin.js\";\n/**\n * This class is an implimentaiton of a Fractal Brownian Motion\n * function using Perlin Nosie.\n */\n\nexport var FBM = /*#__PURE__*/function () {\n  /**\n   * Create an instance of the FBM class.\n   * Use this instance to generate fBm noise.\n   *\n   * @param {Object} options Options for fBm generaiton.\n   * @param {number} options.seed Seed for Perlin Noise\n   * @param {number} options.scale What distance to view the noisemap\n   * @param {number} options.persistance How much each octave contributes to the overall shape\n   * @param {number} options.lacunarity How much detail is added or removed at each octave\n   * @param {number} options.octaves Levels of detail you want you perlin noise to have\n   * @param {number} options.redistribution Level of flatness within the valleys\n   */\n  function FBM(options) {\n    _classCallCheck(this, FBM);\n\n    var seed = options.seed,\n        scale = options.scale,\n        persistance = options.persistance,\n        lacunarity = options.lacunarity,\n        octaves = options.octaves,\n        redistribution = options.redistribution;\n    this._noise = new Perlin(seed);\n    this._scale = scale || 1;\n    this._persistance = persistance || 0.5;\n    this._lacunarity = lacunarity || 2;\n    this._octaves = octaves || 6;\n    this._redistribution = redistribution || 1;\n  }\n  /**\n   * Sample 2D Perlin Noise with fBm at given\n   * coordinates. The function will use <code>Perlin_get2</code> or <code>Perlin_get3</code>\n   * depending on the input vector's type.\n   *\n   * @param {(THREE.Vector2 | THREE.Vector3)} input Coordinates to sample noise at.\n   * @returns {number} Normalized noise in the range [0, 1]\n   */\n\n\n  _createClass(FBM, [{\n    key: \"get2\",\n    value: function get2(input) {\n      var result = 0;\n      var amplitude = 1;\n      var frequency = 1;\n      var max = amplitude;\n\n      var noiseFunction = this._noise.get2.bind(this._noise);\n\n      for (var i = 0; i < this._octaves; i++) {\n        var position = new THREE.Vector2(input.x * this._scale * frequency, input.y * this._scale * frequency);\n        var noiseVal = noiseFunction(position);\n        result += noiseVal * amplitude;\n        frequency *= this._lacunarity;\n        amplitude *= this._persistance;\n        max += amplitude;\n      }\n\n      var redistributed = Math.pow(result, this._redistribution);\n      return redistributed / max;\n    }\n    /**\n     * Sample 3D Perlin Noise with fBm at given\n     * coordinates. The function will use <code>Perlin_get2</code> or <code>Perlin_get3</code>\n     * depending on the input vector's type.\n     *\n     * @param {THREE.Vector3} input Coordinates to sample noise at.\n     * @returns {number} Normalized noise in the range [0, 1]\n     */\n\n  }, {\n    key: \"get3\",\n    value: function get3(input) {\n      var result = 0;\n      var amplitude = 1;\n      var frequency = 1;\n      var max = amplitude;\n\n      var noiseFunction = this._noise.get3.bind(this._noise);\n\n      for (var i = 0; i < this._octaves; i++) {\n        var position = new THREE.Vector2(input.x * this._scale * frequency, input.y * this._scale * frequency, input.z * this._scale * frequency);\n        var noiseVal = noiseFunction(position);\n        result += noiseVal * amplitude;\n        frequency *= this._lacunarity;\n        amplitude *= this._persistance;\n        max += amplitude;\n      }\n\n      var redistributed = Math.pow(result, this._redistribution);\n      return redistributed / max;\n    }\n  }]);\n\n  return FBM;\n}();","map":{"version":3,"sources":["/Users/year12/Desktop/Harvey/alevel_2020-2021/components/Core-API/PerlinNoise/PerlingNoise.js"],"names":["THREE","Perlin","FBM","options","seed","scale","persistance","lacunarity","octaves","redistribution","_noise","_scale","_persistance","_lacunarity","_octaves","_redistribution","input","result","amplitude","frequency","max","noiseFunction","get2","bind","i","position","Vector2","x","y","noiseVal","redistributed","Math","pow","get3","z"],"mappings":";;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,MAAT,QAAuB,aAAvB;AAEA;AACA;AACA;AACA;;AACA,WAAaC,GAAb;AACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,eAAYC,OAAZ,EAAqB;AAAA;;AAAA,QACXC,IADW,GAEjBD,OAFiB,CACXC,IADW;AAAA,QACLC,KADK,GAEjBF,OAFiB,CACLE,KADK;AAAA,QACEC,WADF,GAEjBH,OAFiB,CACEG,WADF;AAAA,QACeC,UADf,GAEjBJ,OAFiB,CACeI,UADf;AAAA,QAC2BC,OAD3B,GAEjBL,OAFiB,CAC2BK,OAD3B;AAAA,QACoCC,cADpC,GAEjBN,OAFiB,CACoCM,cADpC;AAGnB,SAAKC,MAAL,GAAc,IAAIT,MAAJ,CAAWG,IAAX,CAAd;AACA,SAAKO,MAAL,GAAcN,KAAK,IAAI,CAAvB;AACA,SAAKO,YAAL,GAAoBN,WAAW,IAAI,GAAnC;AACA,SAAKO,WAAL,GAAmBN,UAAU,IAAI,CAAjC;AACA,SAAKO,QAAL,GAAgBN,OAAO,IAAI,CAA3B;AACA,SAAKO,eAAL,GAAuBN,cAAc,IAAI,CAAzC;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AA/BA;AAAA;AAAA,yBAgCOO,KAhCP,EAgCc;AACV,UAAIC,MAAM,GAAG,CAAb;AACA,UAAIC,SAAS,GAAG,CAAhB;AACA,UAAIC,SAAS,GAAG,CAAhB;AACA,UAAIC,GAAG,GAAGF,SAAV;;AAEA,UAAIG,aAAa,GAAG,KAAKX,MAAL,CAAYY,IAAZ,CAAiBC,IAAjB,CAAsB,KAAKb,MAA3B,CAApB;;AAEA,WAAK,IAAIc,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKV,QAAzB,EAAmCU,CAAC,EAApC,EAAwC;AACtC,YAAMC,QAAQ,GAAG,IAAIzB,KAAK,CAAC0B,OAAV,CACfV,KAAK,CAACW,CAAN,GAAU,KAAKhB,MAAf,GAAwBQ,SADT,EAEfH,KAAK,CAACY,CAAN,GAAU,KAAKjB,MAAf,GAAwBQ,SAFT,CAAjB;AAKA,YAAMU,QAAQ,GAAGR,aAAa,CAACI,QAAD,CAA9B;AACAR,QAAAA,MAAM,IAAIY,QAAQ,GAAGX,SAArB;AAEAC,QAAAA,SAAS,IAAI,KAAKN,WAAlB;AACAK,QAAAA,SAAS,IAAI,KAAKN,YAAlB;AACAQ,QAAAA,GAAG,IAAIF,SAAP;AACD;;AAED,UAAMY,aAAa,GAAGC,IAAI,CAACC,GAAL,CAASf,MAAT,EAAiB,KAAKF,eAAtB,CAAtB;AACA,aAAOe,aAAa,GAAGV,GAAvB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAjEA;AAAA;AAAA,yBAkEOJ,KAlEP,EAkEc;AACV,UAAIC,MAAM,GAAG,CAAb;AACA,UAAIC,SAAS,GAAG,CAAhB;AACA,UAAIC,SAAS,GAAG,CAAhB;AACA,UAAIC,GAAG,GAAGF,SAAV;;AAEA,UAAIG,aAAa,GAAG,KAAKX,MAAL,CAAYuB,IAAZ,CAAiBV,IAAjB,CAAsB,KAAKb,MAA3B,CAApB;;AAEA,WAAK,IAAIc,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKV,QAAzB,EAAmCU,CAAC,EAApC,EAAwC;AACtC,YAAMC,QAAQ,GAAG,IAAIzB,KAAK,CAAC0B,OAAV,CACfV,KAAK,CAACW,CAAN,GAAU,KAAKhB,MAAf,GAAwBQ,SADT,EAEfH,KAAK,CAACY,CAAN,GAAU,KAAKjB,MAAf,GAAwBQ,SAFT,EAGfH,KAAK,CAACkB,CAAN,GAAU,KAAKvB,MAAf,GAAwBQ,SAHT,CAAjB;AAMA,YAAMU,QAAQ,GAAGR,aAAa,CAACI,QAAD,CAA9B;AACAR,QAAAA,MAAM,IAAIY,QAAQ,GAAGX,SAArB;AAEAC,QAAAA,SAAS,IAAI,KAAKN,WAAlB;AACAK,QAAAA,SAAS,IAAI,KAAKN,YAAlB;AACAQ,QAAAA,GAAG,IAAIF,SAAP;AACD;;AAED,UAAMY,aAAa,GAAGC,IAAI,CAACC,GAAL,CAASf,MAAT,EAAiB,KAAKF,eAAtB,CAAtB;AACA,aAAOe,aAAa,GAAGV,GAAvB;AACD;AA3FH;;AAAA;AAAA","sourcesContent":["import * as THREE from \"three\";\nimport { Perlin } from \"./Perlin.js\";\n\n/**\n * This class is an implimentaiton of a Fractal Brownian Motion\n * function using Perlin Nosie.\n */\nexport class FBM {\n  /**\n   * Create an instance of the FBM class.\n   * Use this instance to generate fBm noise.\n   *\n   * @param {Object} options Options for fBm generaiton.\n   * @param {number} options.seed Seed for Perlin Noise\n   * @param {number} options.scale What distance to view the noisemap\n   * @param {number} options.persistance How much each octave contributes to the overall shape\n   * @param {number} options.lacunarity How much detail is added or removed at each octave\n   * @param {number} options.octaves Levels of detail you want you perlin noise to have\n   * @param {number} options.redistribution Level of flatness within the valleys\n   */\n  constructor(options) {\n    const { seed, scale, persistance, lacunarity, octaves, redistribution } =\n      options;\n    this._noise = new Perlin(seed);\n    this._scale = scale || 1;\n    this._persistance = persistance || 0.5;\n    this._lacunarity = lacunarity || 2;\n    this._octaves = octaves || 6;\n    this._redistribution = redistribution || 1;\n  }\n\n  /**\n   * Sample 2D Perlin Noise with fBm at given\n   * coordinates. The function will use <code>Perlin_get2</code> or <code>Perlin_get3</code>\n   * depending on the input vector's type.\n   *\n   * @param {(THREE.Vector2 | THREE.Vector3)} input Coordinates to sample noise at.\n   * @returns {number} Normalized noise in the range [0, 1]\n   */\n  get2(input) {\n    let result = 0;\n    let amplitude = 1;\n    let frequency = 1;\n    let max = amplitude;\n\n    let noiseFunction = this._noise.get2.bind(this._noise);\n\n    for (let i = 0; i < this._octaves; i++) {\n      const position = new THREE.Vector2(\n        input.x * this._scale * frequency,\n        input.y * this._scale * frequency\n      );\n\n      const noiseVal = noiseFunction(position);\n      result += noiseVal * amplitude;\n\n      frequency *= this._lacunarity;\n      amplitude *= this._persistance;\n      max += amplitude;\n    }\n\n    const redistributed = Math.pow(result, this._redistribution);\n    return redistributed / max;\n  }\n\n  /**\n   * Sample 3D Perlin Noise with fBm at given\n   * coordinates. The function will use <code>Perlin_get2</code> or <code>Perlin_get3</code>\n   * depending on the input vector's type.\n   *\n   * @param {THREE.Vector3} input Coordinates to sample noise at.\n   * @returns {number} Normalized noise in the range [0, 1]\n   */\n  get3(input) {\n    let result = 0;\n    let amplitude = 1;\n    let frequency = 1;\n    let max = amplitude;\n\n    let noiseFunction = this._noise.get3.bind(this._noise);\n\n    for (let i = 0; i < this._octaves; i++) {\n      const position = new THREE.Vector2(\n        input.x * this._scale * frequency,\n        input.y * this._scale * frequency,\n        input.z * this._scale * frequency\n      );\n\n      const noiseVal = noiseFunction(position);\n      result += noiseVal * amplitude;\n\n      frequency *= this._lacunarity;\n      amplitude *= this._persistance;\n      max += amplitude;\n    }\n\n    const redistributed = Math.pow(result, this._redistribution);\n    return redistributed / max;\n  }\n}"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"// Written By Harvey Randall \\\\\nimport { DoubleSide, Group, Mesh, MeshPhongMaterial, SphereGeometry } from \"three\"; // Randomly delplace cloud verticies\n\nconst map = (val, smin, smax, emin, emax) => (emax - emin) * (val - smin) / (smax - smin) + emin;\n\nconst jitter = (geometry, per) => {\n  for (var i = 0, l = geometry.attributes.position.count; i < l; i++) {\n    geometry.attributes.position.array[i * 3] += map(Math.random(), 0, 1, -per, per);\n    geometry.attributes.position.array[i * 3 + 1] += map(Math.random(), 0, 1, -per, per);\n    geometry.attributes.position.array[i * 3 + 2] += map(Math.random(), 0, 1, -per, per);\n  }\n};\n\nexport class generateClouds {\n  constructor(pos, scene, speed, scale) {\n    const group = new Group();\n    const tuft1 = new SphereGeometry(1.5 * scale, 7, 11);\n    tuft1.translate(-2 * scale, 0, 0);\n    const tuft3 = new SphereGeometry(1.5 * scale, 7, 11);\n    tuft3.translate(2 * scale, 0, 0);\n    const tuft2 = new SphereGeometry(2.0 * scale, 7, 11);\n    tuft2.translate(0, 0, 0);\n    jitter(tuft1, 0.2);\n    jitter(tuft2, 0.1);\n    jitter(tuft3, 0.1);\n    tuft1.computeVertexNormals();\n    const mat = new MeshPhongMaterial({\n      color: \"white\",\n      flatShading: true,\n      side: DoubleSide\n    });\n    let cloud = new Mesh(tuft1, mat);\n    let cloud1 = new Mesh(tuft2, mat);\n    let cloud2 = new Mesh(tuft3, mat);\n    group.add(cloud);\n    group.add(cloud1);\n    group.add(cloud2);\n    scene.add(group);\n    group.castShadow = true;\n    group.receiveShadow = true;\n    group.position.x = pos.x;\n    group.position.y = pos.y;\n    group.position.z = pos.z;\n    this.grass = group;\n    this.speed = speed;\n    this.pos = pos;\n  }\n\n  update() {\n    let geos = this.grass;\n    geos.position.x += this.speed;\n\n    if (geos.position.x > 400) {\n      geos.position.x = this.pos.x;\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/year12/Desktop/Harvey/alevel_2020-2021/components/gameFundalmentals/clouds.js"],"names":["DoubleSide","Group","Mesh","MeshPhongMaterial","SphereGeometry","map","val","smin","smax","emin","emax","jitter","geometry","per","i","l","attributes","position","count","array","Math","random","generateClouds","constructor","pos","scene","speed","scale","group","tuft1","translate","tuft3","tuft2","computeVertexNormals","mat","color","flatShading","side","cloud","cloud1","cloud2","add","castShadow","receiveShadow","x","y","z","grass","update","geos"],"mappings":"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","sourcesContent":["// Written By Harvey Randall \\\\\n\nimport {\n    DoubleSide,\n    Group,\n    Mesh,\n    MeshPhongMaterial,\n    SphereGeometry,\n} from \"three\";\n\n// Randomly delplace cloud verticies\nconst map = (val, smin, smax, emin, emax) =>\n    ((emax - emin) * (val - smin)) / (smax - smin) + emin;\nconst jitter = (geometry, per) => {\n    for (var i = 0, l = geometry.attributes.position.count; i < l; i++) {\n        geometry.attributes.position.array[i * 3] += map(\n            Math.random(),\n            0,\n            1,\n            -per,\n            per\n        );\n        geometry.attributes.position.array[i * 3 + 1] += map(\n            Math.random(),\n            0,\n            1,\n            -per,\n            per\n        );\n        geometry.attributes.position.array[i * 3 + 2] += map(\n            Math.random(),\n            0,\n            1,\n            -per,\n            per\n        );\n    }\n};\n\nexport class generateClouds {\n    constructor(pos, scene, speed, scale) {\n        const group = new Group();\n\n        const tuft1 = new SphereGeometry(1.5 * scale, 7, 11);\n        tuft1.translate(-2 * scale, 0, 0);\n\n        const tuft3 = new SphereGeometry(1.5 * scale, 7, 11);\n        tuft3.translate(2 * scale, 0, 0);\n\n        const tuft2 = new SphereGeometry(2.0 * scale, 7, 11);\n        tuft2.translate(0, 0, 0);\n\n        jitter(tuft1, 0.2);\n        jitter(tuft2, 0.1);\n        jitter(tuft3, 0.1);\n\n        tuft1.computeVertexNormals();\n\n        const mat = new MeshPhongMaterial({\n            color: \"white\",\n            flatShading: true,\n            side: DoubleSide,\n        });\n\n        let cloud = new Mesh(tuft1, mat);\n        let cloud1 = new Mesh(tuft2, mat);\n        let cloud2 = new Mesh(tuft3, mat);\n\n        group.add(cloud);\n        group.add(cloud1);\n        group.add(cloud2);\n\n        scene.add(group);\n        group.castShadow = true;\n        group.receiveShadow = true;\n        group.position.x = pos.x;\n        group.position.y = pos.y;\n        group.position.z = pos.z;\n\n        this.grass = group;\n        this.speed = speed;\n        this.pos = pos;\n    }\n\n    update() {\n        let geos = this.grass;\n        geos.position.x += this.speed;\n        if (geos.position.x > 400) {\n            geos.position.x = this.pos.x;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { Mesh, MeshPhongMaterial, PlaneBufferGeometry, Vector2, Vector3 } from \"three\";\nimport { radiants } from \"../components/Algorithms/degToRad\";\nimport * as SimplexNoise from 'simplex-noise';\nexport function createOcean(scene) {\n  let plane = new PlaneBufferGeometry(500, 500, 50);\n  const material = new MeshPhongMaterial({\n    color: 0x0077be,\n    flatShading: true\n  });\n  const positionAttribute = mesh.geometry.getAttribute(\"position\");\n\n  for (var i = 0, l = plane.attributes.position.count; i < l; i++) {\n    // Get Data position\n    const vertex = new Vector3();\n    vertex.fromBufferAttribute(positionAttribute, i); // Check Height from Perlin Noise Generator\n\n    let height = noiseMap.noise2D(vertex.x, vertex.y) * gain; // Set the height accordingly\n\n    plane.attributes.position.array[i * 3 + 2] = height; // Update Vertice colours accordinly\n\n    /*\n    if (height > 43) {\n        colours.push(1, 1, 1);\n    } else if (height > 5) {\n        colours.push(0.56, 0.54, 0.48);\n    } else if (height < -20) {\n        colours.push(0.501, 0.772, 0.87);\n    } else {\n        colours.push(0.56, 0.68, 0.166);\n    }*/\n  }\n\n  let noiseMap = new SimplexNoise(`${Math.random()}`);\n  let mesh = new Mesh(plane, material);\n  mesh.rotateX(radiants(-90));\n  let offset = 10;\n  let Position = new Vector2(0, 0);\n  let gain = 5;\n  scene.add(mesh);\n  setInterval(() => {\n    const positionAttribute = mesh.geometry.getAttribute(\"position\"); //------------[Edit the Geomtry Accordingly]------------\\\\\n\n    for (var i = 0, l = mesh.geometry.attributes.position.count; i < l; i++) {\n      // Get Data position\n      const vertex = new Vector3();\n      vertex.fromBufferAttribute(positionAttribute, i); // Check Height from Perlin Noise Generator\n      //let height = noiseMap.noise2D(vertex.x+(Position.x)+offset, vertex.y-(Position.y)+offset) * gain\n\n      let height = noiseMap.noise2D(vertex.x, vertex.y) * gain; // Set the height accordingly\n\n      console.log(height);\n      mesh.geometry.attributes.position.array[i * 3 + 2] = height * 1000; // Update Vertice colours accordinly\n\n      /*\n      if (height > 43) {\n          colours.push(1, 1, 1);\n      } else if (height > 5) {\n          colours.push(0.56, 0.54, 0.48);\n      } else if (height < -20) {\n          colours.push(0.501, 0.772, 0.87);\n      } else {\n          colours.push(0.56, 0.68, 0.166);\n      }*/\n    }\n\n    mesh.updateMatrix();\n  }, 1000);\n}","map":{"version":3,"sources":["/Users/year12/Desktop/Harvey/alevel_2020-2021/testing/ocean.js"],"names":["Mesh","MeshPhongMaterial","PlaneBufferGeometry","Vector2","Vector3","radiants","SimplexNoise","createOcean","scene","plane","material","color","flatShading","positionAttribute","mesh","geometry","getAttribute","i","l","attributes","position","count","vertex","fromBufferAttribute","height","noiseMap","noise2D","x","y","gain","array","Math","random","rotateX","offset","Position","add","setInterval","console","log","updateMatrix"],"mappings":"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","sourcesContent":["import { Mesh, MeshPhongMaterial, PlaneBufferGeometry, Vector2, Vector3 } from \"three\";\nimport { radiants } from \"../components/Algorithms/degToRad\"\nimport * as SimplexNoise from 'simplex-noise'\n\n\nexport function createOcean(scene){\n    let plane = new PlaneBufferGeometry(500,500, 50)\n\n    const material = new MeshPhongMaterial( {color: 0x0077be, flatShading:true} );\n\n    const positionAttribute = mesh.geometry.getAttribute(\"position\");\n    for (var i = 0, l = plane.attributes.position.count; i < l; i++) {\n        // Get Data position\n        const vertex = new Vector3();\n        vertex.fromBufferAttribute(positionAttribute, i);\n\n        // Check Height from Perlin Noise Generator\n        \n        let height = noiseMap.noise2D(vertex.x, vertex.y) * gain\n        \n        // Set the height accordingly\n        plane.attributes.position.array[i * 3 + 2] = height;\n\n        // Update Vertice colours accordinly\n        /*\n        if (height > 43) {\n            colours.push(1, 1, 1);\n        } else if (height > 5) {\n            colours.push(0.56, 0.54, 0.48);\n        } else if (height < -20) {\n            colours.push(0.501, 0.772, 0.87);\n        } else {\n            colours.push(0.56, 0.68, 0.166);\n        }*/\n    }\n\n    let noiseMap = new SimplexNoise(`${Math.random()}`)\n\n    let mesh = new Mesh(plane, material)\n\n    mesh.rotateX(radiants(-90))\n\n    let offset = 10\n\n    let Position = new Vector2(0,0)\n\n    let gain = 5\n\n    scene.add(mesh)\n\n    setInterval(() => {\n        const positionAttribute = mesh.geometry.getAttribute(\"position\");\n        //------------[Edit the Geomtry Accordingly]------------\\\\\n        for (var i = 0, l = mesh.geometry.attributes.position.count; i < l; i++) {\n            // Get Data position\n            const vertex = new Vector3();\n            vertex.fromBufferAttribute(positionAttribute, i);\n\n            // Check Height from Perlin Noise Generator\n            \n            //let height = noiseMap.noise2D(vertex.x+(Position.x)+offset, vertex.y-(Position.y)+offset) * gain\n            let height = noiseMap.noise2D(vertex.x, vertex.y) * gain\n            \n            // Set the height accordingly\n            console.log(height)\n            mesh.geometry.attributes.position.array[i * 3 + 2] = height*1000;\n\n            // Update Vertice colours accordinly\n            /*\n            if (height > 43) {\n                colours.push(1, 1, 1);\n            } else if (height > 5) {\n                colours.push(0.56, 0.54, 0.48);\n            } else if (height < -20) {\n                colours.push(0.501, 0.772, 0.87);\n            } else {\n                colours.push(0.56, 0.68, 0.166);\n            }*/\n        }\n        mesh.updateMatrix()\n    }, 1000)\n\n\n\n}"]},"metadata":{},"sourceType":"module"}
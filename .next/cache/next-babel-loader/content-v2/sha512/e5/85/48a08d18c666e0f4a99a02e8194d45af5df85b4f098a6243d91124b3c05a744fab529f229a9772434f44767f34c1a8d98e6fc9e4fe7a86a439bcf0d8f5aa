{"ast":null,"code":"// Written By Harvey Randall \\\\\nimport { BoxGeometry, Mesh, MeshBasicMaterial, MeshLambertMaterial, Scene, SphereBufferGeometry } from \"three\";\nimport { CreateAmbientLight, CreateDirectionalLight } from \"../LightingManager\";\nimport { getRandomStarField } from \"../stars\";\nimport { rotateAboutPoint } from \"./rotateAroundPoint\";\nexport class CreateDayNightCycle {\n  constructor(SceneToGet, Renders) {\n    // ---------- [Two to level global variables] ---------- \\\\\n    this.SceneToGet = SceneToGet;\n    this.Renders = Renders; // ---------- [Create Sun Mesh] ---------- \\\\\n\n    let sun = new SphereBufferGeometry(20, 20, 100, 100);\n    let sunMaterial = new MeshLambertMaterial({\n      emissive: 0xf9d71c\n    });\n    let sunmesh = new Mesh(sun, sunMaterial);\n    sunmesh.position.set(1, 300, 300);\n    SceneToGet.add(sunmesh); // ---------- [Create Moon Mesh] ---------- \\\\\n\n    let moon = new SphereBufferGeometry(10, 10, 100, 100);\n    let moonMaterial = new MeshLambertMaterial({\n      emissive: 0xffffff\n    });\n    let moonMesh = new Mesh(moon, moonMaterial);\n    moonMesh.position.set(-1, -200, -300);\n    SceneToGet.add(moonMesh); // ---------- [Create Box Gometry for handling rotation] ---------- \\\\\n\n    var geometry = new BoxGeometry(1, 1, 1);\n    var cube = new Mesh(geometry);\n    cube.visible = false;\n    SceneToGet.add(cube); // ^ This is a very bad work around fix later\n    // ---------- [All defintions for the moving part] ---------- \\\\\n\n    this.cube = cube;\n    this.moonMesh = moonMesh;\n    this.sunmesh = sunmesh;\n    this.t = 0;\n    this.dTIme = 0; // ---------- [All defintions for lights to create shadows] ---------- \\\\\n\n    this.directionalLight = CreateDirectionalLight(SceneToGet, 0xddffee, 0.5, [1, 100, 100]);\n    this.directionalLight2 = CreateDirectionalLight(SceneToGet, 0xffffff, 0.2, [1, -100, -100]);\n    this.light = CreateAmbientLight(SceneToGet, 0xaaaaaa, 0.5); // ---------- [Create Stary night] ---------- \\\\\n\n    let skyBox = new BoxGeometry(1200, 1200, 1200);\n    let skyBoxMaterial = new MeshBasicMaterial({\n      map: getRandomStarField(600, 2048, 2048),\n      side: THREE.BackSide\n    });\n    this.sky = new Mesh(skyBox, skyBoxMaterial);\n  }\n\n  update() {\n    // This two lines are  important as it is part of the hacky work around to get time of day on varying FPS\n    let theta = rotateAboutPoint(directionalLight, new Vector3(0, 0, 0), new Vector3(1, 0, 0), 0.001, true);\n    let angle = THREE.MathUtils.radToDeg(this.cube.rotation.x); // ---------- [Rotate all the lights and Meshes] ---------- \\\\\n\n    rotateAboutPoint(sunmesh, new Vector3(100, 0, 0), new Vector3(1, 0, 0), 0.001, true);\n    rotateAboutPoint(moonMesh, new Vector3(100, 0, 0), new Vector3(1, 0, 0), 0.001, true);\n    rotateAboutPoint(directionalLight2, new Vector3(0, 0, 0), new Vector3(1, 0, 0), 0.001, true); // ---------- [If it is day] ---------- \\\\\n\n    if (angle < 40) {\n      this.t = 0;\n      this.directionalLight.color.setHex(0xddffee);\n      this.dTIme += 0.003;\n\n      if (this.dTIme >= 1) {\n        this.dTIme = 1;\n        return;\n      }\n\n      this.Renders.setClearColor(new THREE.Color().lerpColors(new THREE.Color(0xFDB813), new THREE.Color(0x87ceeb), this.dTIme), 1);\n      this.light.intensity = 0.5;\n      this.directionalLight2.color.setHex(0x000000);\n      this.directionalLight.intensity = 0.5;\n      this.directionalLight2.intensity = 0;\n      this.SceneToGet.remove(this.sky);\n    } // ---------- [If it is night] ---------- \\\\\n    else if (angle) {\n        this.dTIme = 0;\n        this.t += 0.01;\n\n        if (this.t >= 1) {\n          this.t = 1;\n          SceneToGet.add(sky);\n          return;\n        }\n\n        this.directionalLight2.color.setHex(0xffffff);\n        this.Renders.setClearColor(new THREE.Color().lerpColors(new THREE.Color(0x87ceeb), new THREE.Color(0x000000), t), 1);\n        this.light.intensity = 0.2;\n        this.directionalLight.intensity = 0;\n        this.directionalLight2.intensity = 0.2;\n        this.sky.rotation.x += -0.0004;\n      }\n\n    this.cube.rotateOnAxis(new Vector3(1, 0, 0), theta);\n  }\n\n}","map":{"version":3,"sources":["/Users/year12/Desktop/Harvey/alevel_2020-2021/components/gameFundalmentals/DayNightCycle.js"],"names":["BoxGeometry","Mesh","MeshBasicMaterial","MeshLambertMaterial","Scene","SphereBufferGeometry","CreateAmbientLight","CreateDirectionalLight","getRandomStarField","rotateAboutPoint","CreateDayNightCycle","constructor","SceneToGet","Renders","sun","sunMaterial","emissive","sunmesh","position","set","add","moon","moonMaterial","moonMesh","geometry","cube","visible","t","dTIme","directionalLight","directionalLight2","light","skyBox","skyBoxMaterial","map","side","THREE","BackSide","sky","update","theta","Vector3","angle","MathUtils","radToDeg","rotation","x","color","setHex","setClearColor","Color","lerpColors","intensity","remove","rotateOnAxis"],"mappings":"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","sourcesContent":["// Written By Harvey Randall \\\\\nimport { BoxGeometry, Mesh, MeshBasicMaterial, MeshLambertMaterial, Scene, SphereBufferGeometry } from \"three\";\nimport { CreateAmbientLight, CreateDirectionalLight } from \"../LightingManager\";\nimport { getRandomStarField } from \"../stars\";\nimport { rotateAboutPoint } from \"./rotateAroundPoint\";\n\nexport class CreateDayNightCycle {\n    constructor(SceneToGet, Renders) {\n\n        // ---------- [Two to level global variables] ---------- \\\\\n        this.SceneToGet = SceneToGet\n        this.Renders = Renders\n\n        // ---------- [Create Sun Mesh] ---------- \\\\\n        let sun = new SphereBufferGeometry(20, 20, 100, 100)\n        let sunMaterial = new MeshLambertMaterial({\n            emissive: 0xf9d71c,\n        })\n        let sunmesh = new Mesh(sun, sunMaterial)\n        sunmesh.position.set(1, 300, 300)\n        SceneToGet.add(sunmesh)\n\n\n        // ---------- [Create Moon Mesh] ---------- \\\\\n        let moon = new SphereBufferGeometry(10, 10, 100, 100)\n        let moonMaterial = new MeshLambertMaterial({\n            emissive: 0xffffff,\n        })\n        let moonMesh = new Mesh(moon, moonMaterial)\n        moonMesh.position.set(-1, -200, -300)\n        SceneToGet.add(moonMesh)\n\n        // ---------- [Create Box Gometry for handling rotation] ---------- \\\\\n        var geometry = new BoxGeometry(1, 1, 1);\n        var cube = new Mesh(geometry);\n        cube.visible = false\n        SceneToGet.add(cube);\n        // ^ This is a very bad work around fix later\n\n\n        // ---------- [All defintions for the moving part] ---------- \\\\\n        this.cube = cube\n        this.moonMesh = moonMesh\n        this.sunmesh = sunmesh\n        this.t = 0\n        this.dTIme = 0\n\n        // ---------- [All defintions for lights to create shadows] ---------- \\\\\n        this.directionalLight = CreateDirectionalLight(SceneToGet, 0xddffee, 0.5, [1, 100, 100])\n        this.directionalLight2 = CreateDirectionalLight(SceneToGet, 0xffffff, 0.2, [1, -100, -100])\n        this.light = CreateAmbientLight(SceneToGet, 0xaaaaaa, 0.5)\n\n        // ---------- [Create Stary night] ---------- \\\\\n        let skyBox = new BoxGeometry(1200, 1200, 1200);\n        let skyBoxMaterial = new MeshBasicMaterial({\n            map: getRandomStarField(600, 2048, 2048),\n            side: THREE.BackSide,\n        });\n        this.sky = new Mesh(skyBox, skyBoxMaterial);\n    }\n    update() {\n        // This two lines are  important as it is part of the hacky work around to get time of day on varying FPS\n        let theta = rotateAboutPoint(directionalLight, new Vector3(0, 0, 0), new Vector3(1, 0, 0), 0.001, true)\n        let angle = THREE.MathUtils.radToDeg(this.cube.rotation.x)\n\n        // ---------- [Rotate all the lights and Meshes] ---------- \\\\\n        rotateAboutPoint(sunmesh, new Vector3(100, 0, 0), new Vector3(1, 0, 0), 0.001, true)\n        rotateAboutPoint(moonMesh, new Vector3(100, 0, 0), new Vector3(1, 0, 0), 0.001, true)\n        rotateAboutPoint(directionalLight2, new Vector3(0, 0, 0), new Vector3(1, 0, 0), 0.001, true)\n\n\n    \n\n        // ---------- [If it is day] ---------- \\\\\n        if (angle < 40) {\n            this.t = 0\n            this.directionalLight.color.setHex(0xddffee)\n            this.dTIme += 0.003\n            if (this.dTIme >= 1) {\n                this.dTIme = 1\n                return\n            }\n            this.Renders.setClearColor(new THREE.Color().lerpColors(new THREE.Color(0xFDB813), new THREE.Color(0x87ceeb), this.dTIme), 1);\n            this.light.intensity = 0.5\n            this.directionalLight2.color.setHex(0x000000)\n            this.directionalLight.intensity = 0.5\n            this.directionalLight2.intensity = 0\n            this.SceneToGet.remove(this.sky);\n        }\n\n        // ---------- [If it is night] ---------- \\\\\n        else if (angle) {\n            this.dTIme = 0\n\n            this.t += 0.01;\n            if (this.t >= 1) {\n                this.t = 1\n                SceneToGet.add(sky);\n                return\n            }\n            this.directionalLight2.color.setHex(0xffffff)\n            this.Renders.setClearColor(new THREE.Color().lerpColors(new THREE.Color(0x87ceeb), new THREE.Color(0x000000), t), 1);\n            this.light.intensity = 0.2\n            this.directionalLight.intensity = 0\n            this.directionalLight2.intensity = 0.2\n\n            this.sky.rotation.x += -0.0004\n        }\n        this.cube.rotateOnAxis(new Vector3(1, 0, 0), theta)\n\n    }\n}"]},"metadata":{},"sourceType":"module"}
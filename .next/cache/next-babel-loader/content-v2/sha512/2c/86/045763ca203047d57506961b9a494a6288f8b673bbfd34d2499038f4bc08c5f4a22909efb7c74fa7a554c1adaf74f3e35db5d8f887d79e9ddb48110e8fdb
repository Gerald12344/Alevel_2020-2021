{"ast":null,"code":"import _classCallCheck from \"/Users/year12/Desktop/Harvey/alevel_2020-2021/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/year12/Desktop/Harvey/alevel_2020-2021/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Written By Harvey Randall \\\\\nimport { BackSide, BoxGeometry, Color, MathUtils, Mesh, MeshBasicMaterial, MeshLambertMaterial, Scene, SphereBufferGeometry, Vector3 } from \"three\";\nimport { CreateAmbientLight, CreateDirectionalLight } from \"../LightingManager\";\nimport { getRandomStarField } from \"../stars\";\nimport { rotateAboutPoint } from \"./rotateAroundPoint\";\nexport var CreateDayNightCycle = /*#__PURE__*/function () {\n  function CreateDayNightCycle(SceneToGet, Renders) {\n    _classCallCheck(this, CreateDayNightCycle);\n\n    // ---------- [Two to level global variables] ---------- \\\\\n    this.SceneToGet = SceneToGet;\n    this.Renders = Renders; // ---------- [Create Sun Mesh] ---------- \\\\\n\n    var sun = new SphereBufferGeometry(20, 20, 100, 100);\n    var sunMaterial = new MeshLambertMaterial({\n      emissive: 0xf9d71c\n    });\n    var sunmesh = new Mesh(sun, sunMaterial);\n    sunmesh.position.set(1, 300, 300);\n    SceneToGet.add(sunmesh); // ---------- [Create Moon Mesh] ---------- \\\\\n\n    var moon = new SphereBufferGeometry(10, 10, 100, 100);\n    var moonMaterial = new MeshLambertMaterial({\n      emissive: 0xffffff\n    });\n    var moonMesh = new Mesh(moon, moonMaterial);\n    moonMesh.position.set(-1, -200, -300);\n    SceneToGet.add(moonMesh); // ---------- [Create Box Gometry for handling rotation] ---------- \\\\\n\n    var geometry = new BoxGeometry(1, 1, 1);\n    var cube = new Mesh(geometry);\n    cube.visible = true;\n    SceneToGet.add(cube); // ^ This is a very bad work around fix later\n    // ---------- [All defintions for the moving part] ---------- \\\\\n\n    this.cube = cube;\n    this.moonMesh = moonMesh;\n    this.sunmesh = sunmesh;\n    this.t = 0;\n    this.dTIme = 0; // ---------- [All defintions for lights to create shadows] ---------- \\\\\n\n    this.directionalLight = CreateDirectionalLight(SceneToGet, 0xddffee, 0.5, [1, 100, 100]);\n    this.directionalLight2 = CreateDirectionalLight(SceneToGet, 0xffffff, 0.2, [1, -100, -100]);\n    this.light = CreateAmbientLight(SceneToGet, 0xaaaaaa, 0.5); // ---------- [Create Stary night] ---------- \\\\\n\n    var skyBox = new BoxGeometry(1200, 1200, 1200);\n    var skyBoxMaterial = new MeshBasicMaterial({\n      map: getRandomStarField(600, 2048, 2048),\n      side: BackSide\n    });\n    this.sky = new Mesh(skyBox, skyBoxMaterial);\n  }\n\n  _createClass(CreateDayNightCycle, [{\n    key: \"update\",\n    value: function update() {\n      // This two lines are  important as it is part of the hacky work around to get time of day on varying FPS\n      var theta = rotateAboutPoint(this.directionalLight, new Vector3(0, 0, 0), new Vector3(1, 0, 0), 0.001, true);\n      var angle = MathUtils.radToDeg(this.cube.rotation.x); // ---------- [Rotate all the lights and Meshes] ---------- \\\\\n\n      rotateAboutPoint(this.sunmesh, new Vector3(100, 0, 0), new Vector3(1, 0, 0), 0.001, true);\n      rotateAboutPoint(this.moonMesh, new Vector3(100, 0, 0), new Vector3(1, 0, 0), 0.001, true);\n      rotateAboutPoint(this.directionalLight2, new Vector3(0, 0, 0), new Vector3(1, 0, 0), 0.001, true); // ---------- [If it is day] ---------- \\\\\n\n      if (angle < 40) {\n        this.t = 0;\n        this.directionalLight.color.setHex(0xddffee);\n        this.dTIme += 0.003;\n\n        if (this.dTIme >= 1) {\n          this.dTIme = 1;\n        }\n\n        this.Renders.setClearColor(new Color().lerpColors(new Color(0xFDB813), new Color(0x87ceeb), this.dTIme), 1);\n        this.light.intensity = 0.5;\n        this.directionalLight2.color.setHex(0x000000);\n        this.directionalLight.intensity = 0.5;\n        this.directionalLight2.intensity = 0;\n        this.SceneToGet.remove(this.sky);\n      } // ---------- [If it is night] ---------- \\\\\n      else if (angle) {\n          this.dTIme = 0;\n          this.t += 0.01;\n\n          if (this.t >= 1) {\n            this.t = 1;\n            SceneToGet.add(sky);\n          }\n\n          this.directionalLight2.color.setHex(0xffffff);\n          this.Renders.setClearColor(new Color().lerpColors(new Color(0x87ceeb), new Color(0x000000), t), 1);\n          this.light.intensity = 0.2;\n          this.directionalLight.intensity = 0;\n          this.directionalLight2.intensity = 0.2;\n          this.sky.rotation.x += -0.0004;\n        }\n\n      this.cube.rotateOnAxis(new Vector3(1, 0, 0), theta);\n    }\n  }]);\n\n  return CreateDayNightCycle;\n}();","map":{"version":3,"sources":["/Users/year12/Desktop/Harvey/alevel_2020-2021/components/gameFundalmentals/DayNightCycle.js"],"names":["BackSide","BoxGeometry","Color","MathUtils","Mesh","MeshBasicMaterial","MeshLambertMaterial","Scene","SphereBufferGeometry","Vector3","CreateAmbientLight","CreateDirectionalLight","getRandomStarField","rotateAboutPoint","CreateDayNightCycle","SceneToGet","Renders","sun","sunMaterial","emissive","sunmesh","position","set","add","moon","moonMaterial","moonMesh","geometry","cube","visible","t","dTIme","directionalLight","directionalLight2","light","skyBox","skyBoxMaterial","map","side","sky","theta","angle","radToDeg","rotation","x","color","setHex","setClearColor","lerpColors","intensity","remove","rotateOnAxis"],"mappings":"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","sourcesContent":["// Written By Harvey Randall \\\\\nimport { BackSide, BoxGeometry, Color, MathUtils, Mesh, MeshBasicMaterial, MeshLambertMaterial, Scene, SphereBufferGeometry, Vector3 } from \"three\";\nimport { CreateAmbientLight, CreateDirectionalLight } from \"../LightingManager\";\nimport { getRandomStarField } from \"../stars\";\nimport { rotateAboutPoint } from \"./rotateAroundPoint\";\n\nexport class CreateDayNightCycle {\n    constructor(SceneToGet, Renders) {\n\n        // ---------- [Two to level global variables] ---------- \\\\\n        this.SceneToGet = SceneToGet\n        this.Renders = Renders\n\n        // ---------- [Create Sun Mesh] ---------- \\\\\n        let sun = new SphereBufferGeometry(20, 20, 100, 100)\n        let sunMaterial = new MeshLambertMaterial({\n            emissive: 0xf9d71c,\n        })\n        let sunmesh = new Mesh(sun, sunMaterial)\n        sunmesh.position.set(1, 300, 300)\n        SceneToGet.add(sunmesh)\n\n\n        // ---------- [Create Moon Mesh] ---------- \\\\\n        let moon = new SphereBufferGeometry(10, 10, 100, 100)\n        let moonMaterial = new MeshLambertMaterial({\n            emissive: 0xffffff,\n        })\n        let moonMesh = new Mesh(moon, moonMaterial)\n        moonMesh.position.set(-1, -200, -300)\n        SceneToGet.add(moonMesh)\n\n        // ---------- [Create Box Gometry for handling rotation] ---------- \\\\\n        var geometry = new BoxGeometry(1, 1, 1);\n        var cube = new Mesh(geometry);\n        cube.visible = true\n        SceneToGet.add(cube);\n        // ^ This is a very bad work around fix later\n\n\n        // ---------- [All defintions for the moving part] ---------- \\\\\n        this.cube = cube\n        this.moonMesh = moonMesh\n        this.sunmesh = sunmesh\n        this.t = 0\n        this.dTIme = 0\n\n        // ---------- [All defintions for lights to create shadows] ---------- \\\\\n        this.directionalLight = CreateDirectionalLight(SceneToGet, 0xddffee, 0.5, [1, 100, 100])\n        this.directionalLight2 = CreateDirectionalLight(SceneToGet, 0xffffff, 0.2, [1, -100, -100])\n        this.light = CreateAmbientLight(SceneToGet, 0xaaaaaa, 0.5)\n\n        // ---------- [Create Stary night] ---------- \\\\\n        let skyBox = new BoxGeometry(1200, 1200, 1200);\n        let skyBoxMaterial = new MeshBasicMaterial({\n            map: getRandomStarField(600, 2048, 2048),\n            side: BackSide,\n        });\n        this.sky = new Mesh(skyBox, skyBoxMaterial);\n    }\n    update() {\n        // This two lines are  important as it is part of the hacky work around to get time of day on varying FPS\n        let theta = rotateAboutPoint(this.directionalLight, new Vector3(0, 0, 0), new Vector3(1, 0, 0), 0.001, true)\n        let angle = MathUtils.radToDeg(this.cube.rotation.x)\n\n        // ---------- [Rotate all the lights and Meshes] ---------- \\\\\n        rotateAboutPoint(this.sunmesh, new Vector3(100, 0, 0), new Vector3(1, 0, 0), 0.001, true)\n        rotateAboutPoint(this.moonMesh, new Vector3(100, 0, 0), new Vector3(1, 0, 0), 0.001, true)\n        rotateAboutPoint(this.directionalLight2, new Vector3(0, 0, 0), new Vector3(1, 0, 0), 0.001, true)\n\n\n    \n\n        // ---------- [If it is day] ---------- \\\\\n        if (angle < 40) {\n            this.t = 0\n            this.directionalLight.color.setHex(0xddffee)\n            this.dTIme += 0.003\n            if (this.dTIme >= 1) {\n                this.dTIme = 1\n            }\n            this.Renders.setClearColor(new Color().lerpColors(new Color(0xFDB813), new Color(0x87ceeb), this.dTIme), 1);\n            this.light.intensity = 0.5\n            this.directionalLight2.color.setHex(0x000000)\n            this.directionalLight.intensity = 0.5\n            this.directionalLight2.intensity = 0\n            this.SceneToGet.remove(this.sky);\n        }\n\n        // ---------- [If it is night] ---------- \\\\\n        else if (angle) {\n            this.dTIme = 0\n\n            this.t += 0.01;\n            if (this.t >= 1) {\n                this.t = 1\n                SceneToGet.add(sky);\n            }\n            this.directionalLight2.color.setHex(0xffffff)\n            this.Renders.setClearColor(new Color().lerpColors(new Color(0x87ceeb), new Color(0x000000), t), 1);\n            this.light.intensity = 0.2\n            this.directionalLight.intensity = 0\n            this.directionalLight2.intensity = 0.2\n\n            this.sky.rotation.x += -0.0004\n        }\n        this.cube.rotateOnAxis(new Vector3(1, 0, 0), theta)\n\n    }\n}"]},"metadata":{},"sourceType":"module"}
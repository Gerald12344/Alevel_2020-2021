{"ast":null,"code":"// Written By Harvey Randall \\\\\nimport { DoubleSide, Group, Mesh, MeshPhongMaterial, SphereGeometry } from \"three\"; // Randomly delplace cloud verticies\n\nconst map = (val, smin, smax, emin, emax) => (emax - emin) * (val - smin) / (smax - smin) + emin;\n\nconst jitter = (geometry, per) => {\n  for (var i = 0, l = geometry.attributes.position.count; i < l; i++) {\n    geometry.attributes.position.array[i * 3] += map(Math.random(), 0, 1, -per, per);\n    geometry.attributes.position.array[i * 3 + 1] += map(Math.random(), 0, 1, -per, per);\n    geometry.attributes.position.array[i * 3 + 2] += map(Math.random(), 0, 1, -per, per);\n  }\n};\n\nexport class GenerateClouds {\n  constructor(pos, scene, speed, scale) {\n    const group = new Group();\n    const tuft1 = new SphereGeometry(1.5 * scale, 7, 11);\n    tuft1.translate(-2 * scale, 0, 0);\n    const tuft3 = new SphereGeometry(1.5 * scale, 7, 11);\n    tuft3.translate(2 * scale, 0, 0);\n    const tuft2 = new SphereGeometry(2.0 * scale, 7, 11);\n    tuft2.translate(0, 0, 0);\n    jitter(tuft1, 0.2);\n    jitter(tuft2, 0.1);\n    jitter(tuft3, 0.1);\n    tuft1.computeVertexNormals();\n    const mat = new MeshPhongMaterial({\n      color: \"white\",\n      flatShading: true,\n      side: DoubleSide\n    });\n    let cloud = new Mesh(tuft1, mat);\n    let cloud1 = new Mesh(tuft2, mat);\n    let cloud2 = new Mesh(tuft3, mat);\n    group.add(cloud);\n    group.add(cloud1);\n    group.add(cloud2);\n    scene.add(group);\n    group.castShadow = true;\n    group.receiveShadow = true;\n    group.position.x = pos.x;\n    group.position.y = pos.y;\n    group.position.z = pos.z;\n    this.grass = group;\n    this.speed = speed;\n    this.pos = pos;\n  }\n\n  update() {\n    let geos = this.grass;\n    geos.position.x += this.speed;\n\n    if (geos.position.x > 400) {\n      geos.position.x = this.pos.x;\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}
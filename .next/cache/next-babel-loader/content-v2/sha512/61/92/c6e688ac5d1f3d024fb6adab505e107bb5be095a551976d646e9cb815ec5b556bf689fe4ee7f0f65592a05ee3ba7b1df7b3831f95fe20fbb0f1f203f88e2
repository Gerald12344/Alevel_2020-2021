{"ast":null,"code":"import { BufferAttribute, Mesh, MeshPhongMaterial, PlaneBufferGeometry, Vector2, Vector3 } from \"three\";\nimport { radiants } from \"../components/Algorithms/degToRad\";\nimport * as SimplexNoise from 'simplex-noise';\nimport { randomIntFromInterval } from \"../components/Algorithms/VectorUtils\";\nexport function createOcean(scene) {\n  let plane = new PlaneBufferGeometry(500, 500, 100, 100); //const material = new MeshPhongMaterial( {color: 0x0077be, flatShading:true} );\n\n  let noiseMap = new SimplexNoise(`${Math.random()}`);\n  let offset = 10;\n  let Position = new Vector2(0, 0);\n  let gain = 0.75;\n  let colours = [];\n  let startTime = 0;\n\n  let init = mesh => {\n    startTime++;\n    const positionAttribute = plane.getAttribute(\"position\"); //------------[Edit the Geomtry Accordingly]------------\\\\\n\n    for (var i = 0, l = plane.attributes.position.count; i < l; i++) {\n      // Get Data position\n      const vertex = new Vector3();\n      vertex.fromBufferAttribute(positionAttribute, i); // Check Height from Perlin Noise Generator\n      //let height = noiseMap.noise2D(vertex.x+(Position.x)+offset, vertex.y-(Position.y)+offset) * gain\n\n      let height = noiseMap.noise2D(vertex.x / 10 + startTime, vertex.y / 10 + startTime) * gain; // Set the height accordingly\n\n      plane.attributes.position.array[i * 3 + 2] = height;\n      console.log(height); // Update Vertice colours accordinly\n\n      if (height > 0.4) {\n        colours.push(0, 0.567, 0.845);\n      } else {\n        //randomIntFromInterval\n        colours.push(0, randomIntFromInterval(400, 500) / 1000, randomIntFromInterval(700, 800) / 1000);\n      }\n    }\n\n    if (mesh) {\n      mesh.updateMatrix();\n    }\n  };\n\n  init(); //------------[Create Material]------------\\\\\n\n  var material = new MeshPhongMaterial({\n    vertexColors: colours,\n    reflectivity: 0,\n    roughness: 1,\n    flatShading: true\n  }); //------------[Edit colour attribute]------------\\\\\n\n  plane.setAttribute(\"color\", new BufferAttribute(new Float32Array(colours), 3));\n  let mesh = new Mesh(plane, material);\n  setInterval(init(mesh), 1000);\n  mesh.rotateX(radiants(-90));\n  scene.add(mesh);\n}","map":{"version":3,"sources":["/Users/year12/Desktop/Harvey/alevel_2020-2021/testing/ocean.js"],"names":["BufferAttribute","Mesh","MeshPhongMaterial","PlaneBufferGeometry","Vector2","Vector3","radiants","SimplexNoise","randomIntFromInterval","createOcean","scene","plane","noiseMap","Math","random","offset","Position","gain","colours","startTime","init","mesh","positionAttribute","getAttribute","i","l","attributes","position","count","vertex","fromBufferAttribute","height","noise2D","x","y","array","console","log","push","updateMatrix","material","vertexColors","reflectivity","roughness","flatShading","setAttribute","Float32Array","setInterval","rotateX","add"],"mappings":"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","sourcesContent":["import { BufferAttribute, Mesh, MeshPhongMaterial, PlaneBufferGeometry, Vector2, Vector3 } from \"three\";\nimport { radiants } from \"../components/Algorithms/degToRad\"\nimport * as SimplexNoise from 'simplex-noise'\nimport { randomIntFromInterval } from \"../components/Algorithms/VectorUtils\";\n\n\nexport function createOcean(scene){\n    let plane = new PlaneBufferGeometry(500, 500, 100, 100);\n\n    //const material = new MeshPhongMaterial( {color: 0x0077be, flatShading:true} );\n\n    let noiseMap = new SimplexNoise(`${Math.random()}`)\n\n\n    let offset = 10\n\n    let Position = new Vector2(0,0)\n\n    let gain = 0.75\n\n    let colours = [];\n\n    let startTime = 0\n    let init =  (mesh) => {\n        startTime++\n        const positionAttribute = plane.getAttribute(\"position\");\n        //------------[Edit the Geomtry Accordingly]------------\\\\\n        for (var i = 0, l = plane.attributes.position.count; i < l; i++) {\n            // Get Data position\n            const vertex = new Vector3();\n            vertex.fromBufferAttribute(positionAttribute, i);\n\n            // Check Height from Perlin Noise Generator\n            \n            //let height = noiseMap.noise2D(vertex.x+(Position.x)+offset, vertex.y-(Position.y)+offset) * gain\n\n            let height = noiseMap.noise2D(vertex.x/10+startTime, vertex.y/10+startTime) * gain\n            \n            // Set the height accordingly\n            plane.attributes.position.array[i * 3 + 2] = height;\n\n            console.log(height)\n\n            // Update Vertice colours accordinly\n            \n            \n            if (height > 0.4) {\n                colours.push(0,0.567,0.845);\n            }else{\n                //randomIntFromInterval\n                colours.push(0,randomIntFromInterval(400, 500)/1000,randomIntFromInterval(700, 800)/1000)\n            }\n        }\n        if(mesh){\n            mesh.updateMatrix()\n        }\n        \n    }\n\n    init()\n\n\n    //------------[Create Material]------------\\\\\n    var material = new MeshPhongMaterial({\n        vertexColors: colours,\n        reflectivity: 0,\n        roughness: 1,\n        flatShading: true,\n    });\n\n    //------------[Edit colour attribute]------------\\\\\n    plane.setAttribute(\n        \"color\",\n        new BufferAttribute(new Float32Array(colours), 3)\n    );\n\n\n    let mesh = new Mesh(plane, material)\n    setInterval(init(mesh), 1000)\n\n    mesh.rotateX(radiants(-90))\n\n\n    scene.add(mesh)\n\n\n}"]},"metadata":{},"sourceType":"module"}
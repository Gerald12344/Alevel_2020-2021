{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n// Written By Harvey Randall \\\\\n// This file aims to make communicatiom between client and server a lot easier, using promise\n//-------------[   Imports   ]-------------\\\\\nimport { PriorityQueue } from \"../Algorithms/PriorityQueue\";\nimport * as Joi from \"joi\"; //-------------[Core Variables]-------------\\\\\n\nvar client;\nvar Queue = new PriorityQueue(function (a, b) {\n  return a.prority > b.prority;\n});\n/**\n *  @param {string} socket - The socket io Client\n */\n\nexport function startSeverClientCommunication(socket) {\n  client = socket; //Data Handshake\n\n  client.emit(\"ConnectionEstablised\", Date.now());\n}\n/**\n *  @param {string} event - The Event name\n *  @param {array} data   - The data to send to the server\n */\n\nexport function sendDataWithPromise(event, data) {\n  var _arguments = arguments;\n  //-------------[   Create a basic promise to return data   ]-------------\\\\\n  var DataPromise = new Promise(function (resolve, reject) {\n    var resolved = false;\n\n    try {\n      var _client;\n\n      (_client = client).emit.apply(_client, [event].concat(_toConsumableArray(data)));\n\n      client.on(event + \"_Callback\", function () {\n        resolved = true;\n        resolve.apply(void 0, _toConsumableArray(_arguments));\n      });\n    } catch (err) {\n      resolved = true;\n      reject(err);\n    }\n\n    setTimeout(function () {\n      if (resolved === false) {\n        resolved = true;\n        reject(\"No data returned within 2 seconds, is there a data callback?\");\n      }\n    }, 2000);\n  });\n  return DataPromise;\n}\n/**\n *  @param {string} event        - The Event name\n *  @param {function} callback   - The function that will be called with the data back\n */\n\nexport function listenToEvent(event, callback) {\n  // Attach event handle to functions\n  client.on(event, callback);\n}\n/**\n *  @param {function} callback   - The function that will listen to all events sent to the client\n */\n\nexport function attachToMainEventStream(callback) {\n  client.onAny(function (eventName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    callback(eventName, args);\n  });\n}\n/**\n *  @param {string} event        - The name of the event to listen to\n *  @param {scema} scema         - The data scheme to folow\n *  @param {function} callback   - The function that will be called with the data\n */\n\nexport function listenForEventWithSchemaValidation(_x, _x2, _x3) {\n  return _listenForEventWithSchemaValidation.apply(this, arguments);\n}\n\nfunction _listenForEventWithSchemaValidation() {\n  _listenForEventWithSchemaValidation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(event, scema, callback) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            listenToEvent(event, function (args) {\n              var _scema$validate = scema.validate(args),\n                  error = _scema$validate.error,\n                  value = _scema$validate.value;\n\n              if (error) {\n                throw new Error(\"Scehma Check Failed\");\n              } else {\n                callback(value);\n                return value;\n              }\n            });\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _listenForEventWithSchemaValidation.apply(this, arguments);\n}\n\nexport function addDataToQueue(event, data, callback) {\n  var prority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  Queue.push({\n    prority: prority,\n    input: [event, data, callback]\n  });\n} //-------------[   All Non essesntial communcation   ]-------------\\\\\n\nsetInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n  var func, input, callBack, data;\n  return _regeneratorRuntime.wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (Queue.isEmpty()) {\n            _context.next = 14;\n            break;\n          }\n\n          func = Queue.pop();\n          input = func.input;\n          callBack = input[2];\n          _context.prev = 4;\n          _context.next = 7;\n          return sendDataWithPromise.apply(void 0, [input[0]].concat(_toConsumableArray(input[1])));\n\n        case 7:\n          data = _context.sent;\n          callBack(false, data);\n          _context.next = 14;\n          break;\n\n        case 11:\n          _context.prev = 11;\n          _context.t0 = _context[\"catch\"](4);\n          callBack(true, []);\n\n        case 14:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _callee, null, [[4, 11]]);\n})), 500);","map":{"version":3,"sources":["/Users/year12/Desktop/Harvey/alevel_2020-2021/components/Core-API/ConnectAPI.js"],"names":["PriorityQueue","Joi","client","Queue","a","b","prority","startSeverClientCommunication","socket","emit","Date","now","sendDataWithPromise","event","data","DataPromise","Promise","resolve","reject","resolved","on","arguments","err","setTimeout","listenToEvent","callback","attachToMainEventStream","onAny","eventName","args","listenForEventWithSchemaValidation","scema","validate","error","value","Error","addDataToQueue","push","input","setInterval","isEmpty","func","pop","callBack"],"mappings":"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","sourcesContent":["// Written By Harvey Randall \\\\\n\n// This file aims to make communicatiom between client and server a lot easier, using promise\n\n//-------------[   Imports   ]-------------\\\\\nimport { PriorityQueue } from \"../Algorithms/PriorityQueue\";\nimport * as Joi from \"joi\";\n\n//-------------[Core Variables]-------------\\\\\nlet client;\nlet Queue = new PriorityQueue((a, b) => a.prority > b.prority);\n\n/**\n *  @param {string} socket - The socket io Client\n */\nexport function startSeverClientCommunication(socket) {\n  client = socket;\n\n  //Data Handshake\n  client.emit(\"ConnectionEstablised\", Date.now());\n}\n\n/**\n *  @param {string} event - The Event name\n *  @param {array} data   - The data to send to the server\n */\nexport function sendDataWithPromise(event, data) {\n  //-------------[   Create a basic promise to return data   ]-------------\\\\\n  const DataPromise = new Promise((resolve, reject) => {\n    let resolved = false;\n    try {\n      client.emit(event, ...data);\n\n      client.on(event + \"_Callback\", () => {\n        resolved = true;\n        resolve(...arguments);\n      });\n    } catch (err) {\n      resolved = true;\n      reject(err);\n    }\n    setTimeout(() => {\n      if (resolved === false) {\n        resolved = true;\n        reject(\"No data returned within 2 seconds, is there a data callback?\");\n      }\n    }, 2000);\n  });\n  return DataPromise;\n}\n\n/**\n *  @param {string} event        - The Event name\n *  @param {function} callback   - The function that will be called with the data back\n */\nexport function listenToEvent(event, callback) {\n  // Attach event handle to functions\n  client.on(event, callback);\n}\n\n/**\n *  @param {function} callback   - The function that will listen to all events sent to the client\n */\nexport function attachToMainEventStream(callback) {\n  client.onAny((eventName, ...args) => {\n    callback(eventName, args);\n  });\n}\n\n/**\n *  @param {string} event        - The name of the event to listen to\n *  @param {scema} scema         - The data scheme to folow\n *  @param {function} callback   - The function that will be called with the data\n */\nexport async function listenForEventWithSchemaValidation(\n  event,\n  scema,\n  callback\n) {\n  listenToEvent(event, (args) => {\n    const { error, value } = scema.validate(args);\n    if (error) {\n      throw new Error(\"Scehma Check Failed\");\n    } else {\n      callback(value);\n      return value;\n    }\n  });\n}\n\nexport function addDataToQueue(event, data, callback, prority = 1) {\n  Queue.push({ prority, input: [event, data, callback] });\n}\n\n//-------------[   All Non essesntial communcation   ]-------------\\\\\nsetInterval(async () => {\n  if (!Queue.isEmpty()) {\n    let func = Queue.pop();\n    let input = func.input;\n    let callBack = input[2];\n    try {\n      //Destructure and send data\n      let data = await sendDataWithPromise(input[0], ...input[1]);\n      callBack(false, data);\n    } catch {\n      callBack(true, []);\n    }\n  }\n}, 500);\n"]},"metadata":{},"sourceType":"module"}
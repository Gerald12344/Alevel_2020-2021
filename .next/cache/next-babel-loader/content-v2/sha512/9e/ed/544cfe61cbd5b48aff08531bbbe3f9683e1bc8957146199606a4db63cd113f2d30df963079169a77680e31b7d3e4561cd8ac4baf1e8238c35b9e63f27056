{"ast":null,"code":"import _classCallCheck from \"/Users/year12/Desktop/Harvey/alevel_2020-2021/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/year12/Desktop/Harvey/alevel_2020-2021/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport * as THREE from 'three';\n\nvar THREE_Noise = function (exports, THREE) {\n  'use strict';\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function get() {\n              return e[k];\n            }\n          });\n        }\n      });\n    }\n\n    n['default'] = e;\n    return Object.freeze(n);\n  }\n\n  var THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);\n\n  var definitions_perlin = \"#define GLSLIFY 1\\n// From https://github.com/hughsk/glsl-noise/blob/master/periodic/2d.glsl\\n\\n//\\n// GLSL textureless classic 2D noise \\\"cnoise\\\",\\n// with an RSL-style periodic variant \\\"pnoise\\\".\\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\\n// Version: 2011-08-22\\n//\\n// Many thanks to Ian McEwan of Ashima Arts for the\\n// ideas for permutation and gradient selection.\\n//\\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\\n// Distributed under the MIT license. See LICENSE file.\\n// https://github.com/ashima/webgl-noise\\n//\\n\\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\\n\\nvec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\\n\\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\\n\\nvec2 fade(vec2 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\\n\\nfloat map(float value, float min1, float max1, float min2, float max2) {\\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\\n}\\n\\n// Classic Perlin noise, periodic variant\\nfloat perlin(vec2 P) {\\n\\n  vec2 rep = vec2(255.0, 255.0);\\n\\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\\n  vec4 ix = Pi.xzxz;\\n  vec4 iy = Pi.yyww;\\n  vec4 fx = Pf.xzxz;\\n  vec4 fy = Pf.yyww;\\n\\n  vec4 i = permute(permute(ix) + iy);\\n\\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\\n  vec4 gy = abs(gx) - 0.5;\\n  vec4 tx = floor(gx + 0.5);\\n  gx = gx - tx;\\n\\n  vec2 g00 = vec2(gx.x, gy.x);\\n  vec2 g10 = vec2(gx.y, gy.y);\\n  vec2 g01 = vec2(gx.z, gy.z);\\n  vec2 g11 = vec2(gx.w, gy.w);\\n\\n  vec4 norm = taylorInvSqrt(\\n      vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\\n  g00 *= norm.x;\\n  g01 *= norm.y;\\n  g10 *= norm.z;\\n  g11 *= norm.w;\\n\\n  float n00 = dot(g00, vec2(fx.x, fy.x));\\n  float n10 = dot(g10, vec2(fx.y, fy.y));\\n  float n01 = dot(g01, vec2(fx.z, fy.z));\\n  float n11 = dot(g11, vec2(fx.w, fy.w));\\n\\n  vec2 fade_xy = fade(Pf.xy);\\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\\n  return map(2.3 * n_xy, -1.0, 1.0, 0.0, 1.0);\\n}\\n\\nfloat fbm(vec2 pos, vec4 props) {\\n  float persistance = props.x;\\n  float lacunarity = props.y;\\n  float redistribution = props.z;\\n  int octaves = int(props.w);\\n\\n  float result = 0.0;\\n  float amplitude = 1.0;\\n  float frequency = 1.0;\\n  float maximum = amplitude;\\n\\n  for (int i = 0; i < 2; i++) {\\n\\n    vec2 p = pos.xy * frequency;\\n\\n    float noiseVal = perlin(p);\\n    result += noiseVal * amplitude;\\n\\n    frequency *= lacunarity;\\n    amplitude *= persistance;\\n    maximum += amplitude;\\n  }\\n\\n  float redistributed = pow(result, redistribution);\\n  return redistributed / maximum;\\n}\\n\"; // eslint-disable-line\n\n  var p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];\n  /**\n   * An implimentation of Perlin Noise by Ken Perlin.\n   */\n\n  var Perlin = /*#__PURE__*/function () {\n    /**\n     *\n     * @param {number} seed Seed Value for PRNG.\n     */\n    function Perlin(seed) {\n      _classCallCheck(this, Perlin);\n\n      var _gradientVecs = [// 2D Vecs\n      new THREE__namespace.Vector3(1, 1, 0), new THREE__namespace.Vector3(-1, 1, 0), new THREE__namespace.Vector3(1, -1, 0), new THREE__namespace.Vector3(-1, -1, 0), // + 3D Vecs\n      new THREE__namespace.Vector3(1, 0, 1), new THREE__namespace.Vector3(-1, 0, 1), new THREE__namespace.Vector3(1, 0, -1), new THREE__namespace.Vector3(-1, 0, -1), new THREE__namespace.Vector3(0, 1, 1), new THREE__namespace.Vector3(0, -1, 1), new THREE__namespace.Vector3(0, 1, -1), new THREE__namespace.Vector3(0, -1, -1)];\n      var perm = new Array(512);\n      var gradP = new Array(512);\n      if (!seed) seed = 1;\n      seed *= 65536;\n      seed = Math.floor(seed);\n\n      if (seed < 256) {\n        seed |= seed << 8;\n      }\n\n      for (var i = 0; i < 256; i++) {\n        var v;\n\n        if (i & 1) {\n          v = p[i] ^ seed & 255;\n        } else {\n          v = p[i] ^ seed >> 8 & 255;\n        }\n\n        perm[i] = perm[i + 256] = v;\n        gradP[i] = gradP[i + 256] = _gradientVecs[v % 12];\n      }\n\n      this._seed = seed;\n      this._offsetMatrix = [new THREE__namespace.Vector3(0, 0, 0), new THREE__namespace.Vector3(0, 0, 1), new THREE__namespace.Vector3(0, 1, 0), new THREE__namespace.Vector3(0, 1, 1), new THREE__namespace.Vector3(1, 0, 0), new THREE__namespace.Vector3(1, 0, 1), new THREE__namespace.Vector3(1, 1, 0), new THREE__namespace.Vector3(1, 1, 1)];\n      /**\n       * GLSL Shader Chunk for 2D Perlin Noise. Can be used with\n       * three-CustomShaderMaterial.\n       * See: <a href=\"https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\">three-CustomShaderMaterial</a>\n       */\n\n      this.shaderChunk = {\n        defines: \"\",\n        header: definitions_perlin,\n        main: \"\",\n        uniforms: [{\n          three_noise_seed: this._seed\n        }]\n      };\n      this.perm = perm;\n      this.gradP = gradP;\n    }\n\n    _createClass(Perlin, [{\n      key: \"_fade\",\n      value: function _fade(t) {\n        return t * t * t * (t * (t * 6 - 15) + 10);\n      }\n    }, {\n      key: \"_lerp\",\n      value: function _lerp(a, b, t) {\n        return (1 - t) * a + t * b;\n      }\n    }, {\n      key: \"_gradient\",\n      value: function _gradient(posInCell) {\n        if (posInCell instanceof THREE__namespace.Vector3) {\n          return posInCell.x + this.perm[posInCell.y + this.perm[posInCell.z]];\n        } else {\n          return posInCell.x + this.perm[posInCell.y];\n        }\n      }\n      /**\n       * Maps a number from one range to another.\n       * @param {number} x       Input Number\n       * @param {number} in_min  Current range minimum\n       * @param {number} in_max  Current range maximum\n       * @param {number} out_min New range minimum\n       * @param {number} out_max New range maximum\n       * @returns {number} Input Mapped to range [out_min, out_max]\n       */\n\n    }, {\n      key: \"get2\",\n\n      /**\n       * Samples 2D Perlin Nosie at given coordinates.\n       * @param {THREE.Vector2 | THREE.Vector3} input Coordincates to sample at\n       * @returns {number} Value of Perlin Noise at that coordinate.\n       */\n      value: function get2(input) {\n        if (input.z !== undefined) input = new THREE__namespace.Vector2(input.x, input.y);\n        var cell = new THREE__namespace.Vector2(Math.floor(input.x), Math.floor(input.y));\n        input.sub(cell);\n        cell.x &= 255;\n        cell.y &= 255;\n        var gradiantDot = [];\n\n        for (var i = 0; i < 4; i++) {\n          var s3 = this._offsetMatrix[i * 2];\n          var s = new THREE__namespace.Vector2(s3.x, s3.y);\n\n          var grad3 = this.gradP[this._gradient(new THREE__namespace.Vector2().addVectors(cell, s))];\n\n          var grad2 = new THREE__namespace.Vector2(grad3.x, grad3.y);\n          var dist2 = new THREE__namespace.Vector2().subVectors(input, s);\n          gradiantDot.push(grad2.dot(dist2));\n        }\n\n        var u = this._fade(input.x);\n\n        var v = this._fade(input.y);\n\n        var value = this._lerp(this._lerp(gradiantDot[0], gradiantDot[2], u), this._lerp(gradiantDot[1], gradiantDot[3], u), v);\n\n        return value;\n      }\n      /**\n       * Samples 3D Perlin Nosie at given coordinates.\n       * @param {THREE.Vector}3 input Coordincates to sample at\n       * @returns {number} Value of Perlin Noise at that coordinate.\n       */\n\n    }, {\n      key: \"get3\",\n      value: function get3(input) {\n        if (input.z === undefined) throw \"Input to Perlin::get3() must be of type THREE.Vector3\";\n        var cell = new THREE__namespace.Vector3(Math.floor(input.x), Math.floor(input.y), Math.floor(input.z));\n        input.sub(cell);\n        cell.x &= 255;\n        cell.y &= 255;\n        cell.z &= 255;\n        var gradiantDot = [];\n\n        for (var i = 0; i < 8; i++) {\n          var s = this._offsetMatrix[i];\n\n          var grad3 = this.gradP[this._gradient(new THREE__namespace.Vector3().addVectors(cell, s))];\n\n          var dist2 = new THREE__namespace.Vector3().subVectors(input, s);\n          gradiantDot.push(grad3.dot(dist2));\n        }\n\n        var u = this._fade(input.x);\n\n        var v = this._fade(input.y);\n\n        var w = this._fade(input.z);\n\n        var value = this._lerp(this._lerp(this._lerp(gradiantDot[0], gradiantDot[4], u), this._lerp(gradiantDot[1], gradiantDot[5], u), w), this._lerp(this._lerp(gradiantDot[2], gradiantDot[6], u), this._lerp(gradiantDot[3], gradiantDot[7], u), w), v);\n\n        return value;\n      }\n    }], [{\n      key: \"map\",\n      value: function map(x, in_min, in_max, out_min, out_max) {\n        return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n      }\n    }]);\n\n    return Perlin;\n  }();\n  /**\n   * This class is an implimentaiton of a Fractal Brownian Motion\n   * function using Perlin Nosie.\n   */\n\n\n  var FBM = /*#__PURE__*/function () {\n    /**\n     * Create an instance of the FBM class.\n     * Use this instance to generate fBm noise.\n     *\n     * @param {Object} options Options for fBm generaiton.\n     * @param {number} options.seed Seed for Perlin Noise\n     * @param {number} options.scale What distance to view the noisemap\n     * @param {number} options.persistance How much each octave contributes to the overall shape\n     * @param {number} options.lacunarity How much detail is added or removed at each octave\n     * @param {number} options.octaves Levels of detail you want you perlin noise to have\n     * @param {number} options.redistribution Level of flatness within the valleys\n     */\n    function FBM(options) {\n      _classCallCheck(this, FBM);\n\n      var seed = options.seed,\n          scale = options.scale,\n          persistance = options.persistance,\n          lacunarity = options.lacunarity,\n          octaves = options.octaves,\n          redistribution = options.redistribution;\n      this._noise = new Perlin(seed);\n      this._scale = scale || 1;\n      this._persistance = persistance || 0.5;\n      this._lacunarity = lacunarity || 2;\n      this._octaves = octaves || 6;\n      this._redistribution = redistribution || 1;\n    }\n    /**\n     * Sample 2D Perlin Noise with fBm at given\n     * coordinates. The function will use <code>Perlin_get2</code> or <code>Perlin_get3</code>\n     * depending on the input vector's type.\n     *\n     * @param {(THREE.Vector2 | THREE.Vector3)} input Coordinates to sample noise at.\n     * @returns {number} Normalized noise in the range [0, 1]\n     */\n\n\n    _createClass(FBM, [{\n      key: \"get2\",\n      value: function get2(input) {\n        var result = 0;\n        var amplitude = 1;\n        var frequency = 1;\n        var max = amplitude;\n\n        var noiseFunction = this._noise.get2.bind(this._noise);\n\n        for (var i = 0; i < this._octaves; i++) {\n          var position = new THREE__namespace.Vector2(input.x * this._scale * frequency, input.y * this._scale * frequency);\n          var noiseVal = noiseFunction(position);\n          result += noiseVal * amplitude;\n          frequency *= this._lacunarity;\n          amplitude *= this._persistance;\n          max += amplitude;\n        }\n\n        var redistributed = Math.pow(result, this._redistribution);\n        return redistributed / max;\n      }\n      /**\n       * Sample 3D Perlin Noise with fBm at given\n       * coordinates. The function will use <code>Perlin_get2</code> or <code>Perlin_get3</code>\n       * depending on the input vector's type.\n       *\n       * @param {THREE.Vector3} input Coordinates to sample noise at.\n       * @returns {number} Normalized noise in the range [0, 1]\n       */\n\n    }, {\n      key: \"get3\",\n      value: function get3(input) {\n        var result = 0;\n        var amplitude = 1;\n        var frequency = 1;\n        var max = amplitude;\n\n        var noiseFunction = this._noise.get3.bind(this._noise);\n\n        for (var i = 0; i < this._octaves; i++) {\n          var position = new THREE__namespace.Vector2(input.x * this._scale * frequency, input.y * this._scale * frequency, input.z * this._scale * frequency);\n          var noiseVal = noiseFunction(position);\n          result += noiseVal * amplitude;\n          frequency *= this._lacunarity;\n          amplitude *= this._persistance;\n          max += amplitude;\n        }\n\n        var redistributed = Math.pow(result, this._redistribution);\n        return redistributed / max;\n      }\n    }]);\n\n    return FBM;\n  }();\n\n  exports.FBM = FBM;\n  exports.Perlin = Perlin;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  return exports;\n}({}, THREE);","map":{"version":3,"sources":["/Users/year12/Desktop/Harvey/alevel_2020-2021/components/Core-API/PerlinNoise/PerlingNoise.js"],"names":["THREE","THREE_Noise","exports","_interopNamespace","e","__esModule","n","Object","create","keys","forEach","k","d","getOwnPropertyDescriptor","defineProperty","get","enumerable","freeze","THREE__namespace","definitions_perlin","p","Perlin","seed","_gradientVecs","Vector3","perm","Array","gradP","Math","floor","i","v","_seed","_offsetMatrix","shaderChunk","defines","header","main","uniforms","three_noise_seed","t","a","b","posInCell","x","y","z","input","undefined","Vector2","cell","sub","gradiantDot","s3","s","grad3","_gradient","addVectors","grad2","dist2","subVectors","push","dot","u","_fade","value","_lerp","w","in_min","in_max","out_min","out_max","FBM","options","scale","persistance","lacunarity","octaves","redistribution","_noise","_scale","_persistance","_lacunarity","_octaves","_redistribution","result","amplitude","frequency","max","noiseFunction","get2","bind","position","noiseVal","redistributed","pow","get3"],"mappings":"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","sourcesContent":["import * as THREE from 'three'\nvar THREE_Noise = (function (exports, THREE) {\n    'use strict';\n  \n    function _interopNamespace(e) {\n      if (e && e.__esModule) return e;\n      var n = Object.create(null);\n      if (e) {\n        Object.keys(e).forEach(function (k) {\n          if (k !== 'default') {\n            var d = Object.getOwnPropertyDescriptor(e, k);\n            Object.defineProperty(n, k, d.get ? d : {\n              enumerable: true,\n              get: function () {\n                return e[k];\n              }\n            });\n          }\n        });\n      }\n      n['default'] = e;\n      return Object.freeze(n);\n    }\n  \n    var THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);\n  \n    var definitions_perlin = \"#define GLSLIFY 1\\n// From https://github.com/hughsk/glsl-noise/blob/master/periodic/2d.glsl\\n\\n//\\n// GLSL textureless classic 2D noise \\\"cnoise\\\",\\n// with an RSL-style periodic variant \\\"pnoise\\\".\\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\\n// Version: 2011-08-22\\n//\\n// Many thanks to Ian McEwan of Ashima Arts for the\\n// ideas for permutation and gradient selection.\\n//\\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\\n// Distributed under the MIT license. See LICENSE file.\\n// https://github.com/ashima/webgl-noise\\n//\\n\\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\\n\\nvec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\\n\\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\\n\\nvec2 fade(vec2 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\\n\\nfloat map(float value, float min1, float max1, float min2, float max2) {\\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\\n}\\n\\n// Classic Perlin noise, periodic variant\\nfloat perlin(vec2 P) {\\n\\n  vec2 rep = vec2(255.0, 255.0);\\n\\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\\n  vec4 ix = Pi.xzxz;\\n  vec4 iy = Pi.yyww;\\n  vec4 fx = Pf.xzxz;\\n  vec4 fy = Pf.yyww;\\n\\n  vec4 i = permute(permute(ix) + iy);\\n\\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\\n  vec4 gy = abs(gx) - 0.5;\\n  vec4 tx = floor(gx + 0.5);\\n  gx = gx - tx;\\n\\n  vec2 g00 = vec2(gx.x, gy.x);\\n  vec2 g10 = vec2(gx.y, gy.y);\\n  vec2 g01 = vec2(gx.z, gy.z);\\n  vec2 g11 = vec2(gx.w, gy.w);\\n\\n  vec4 norm = taylorInvSqrt(\\n      vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\\n  g00 *= norm.x;\\n  g01 *= norm.y;\\n  g10 *= norm.z;\\n  g11 *= norm.w;\\n\\n  float n00 = dot(g00, vec2(fx.x, fy.x));\\n  float n10 = dot(g10, vec2(fx.y, fy.y));\\n  float n01 = dot(g01, vec2(fx.z, fy.z));\\n  float n11 = dot(g11, vec2(fx.w, fy.w));\\n\\n  vec2 fade_xy = fade(Pf.xy);\\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\\n  return map(2.3 * n_xy, -1.0, 1.0, 0.0, 1.0);\\n}\\n\\nfloat fbm(vec2 pos, vec4 props) {\\n  float persistance = props.x;\\n  float lacunarity = props.y;\\n  float redistribution = props.z;\\n  int octaves = int(props.w);\\n\\n  float result = 0.0;\\n  float amplitude = 1.0;\\n  float frequency = 1.0;\\n  float maximum = amplitude;\\n\\n  for (int i = 0; i < 2; i++) {\\n\\n    vec2 p = pos.xy * frequency;\\n\\n    float noiseVal = perlin(p);\\n    result += noiseVal * amplitude;\\n\\n    frequency *= lacunarity;\\n    amplitude *= persistance;\\n    maximum += amplitude;\\n  }\\n\\n  float redistributed = pow(result, redistribution);\\n  return redistributed / maximum;\\n}\\n\"; // eslint-disable-line\n  \n    var p = [\n      151,\n      160,\n      137,\n      91,\n      90,\n      15,\n      131,\n      13,\n      201,\n      95,\n      96,\n      53,\n      194,\n      233,\n      7,\n      225,\n      140,\n      36,\n      103,\n      30,\n      69,\n      142,\n      8,\n      99,\n      37,\n      240,\n      21,\n      10,\n      23,\n      190,\n      6,\n      148,\n      247,\n      120,\n      234,\n      75,\n      0,\n      26,\n      197,\n      62,\n      94,\n      252,\n      219,\n      203,\n      117,\n      35,\n      11,\n      32,\n      57,\n      177,\n      33,\n      88,\n      237,\n      149,\n      56,\n      87,\n      174,\n      20,\n      125,\n      136,\n      171,\n      168,\n      68,\n      175,\n      74,\n      165,\n      71,\n      134,\n      139,\n      48,\n      27,\n      166,\n      77,\n      146,\n      158,\n      231,\n      83,\n      111,\n      229,\n      122,\n      60,\n      211,\n      133,\n      230,\n      220,\n      105,\n      92,\n      41,\n      55,\n      46,\n      245,\n      40,\n      244,\n      102,\n      143,\n      54,\n      65,\n      25,\n      63,\n      161,\n      1,\n      216,\n      80,\n      73,\n      209,\n      76,\n      132,\n      187,\n      208,\n      89,\n      18,\n      169,\n      200,\n      196,\n      135,\n      130,\n      116,\n      188,\n      159,\n      86,\n      164,\n      100,\n      109,\n      198,\n      173,\n      186,\n      3,\n      64,\n      52,\n      217,\n      226,\n      250,\n      124,\n      123,\n      5,\n      202,\n      38,\n      147,\n      118,\n      126,\n      255,\n      82,\n      85,\n      212,\n      207,\n      206,\n      59,\n      227,\n      47,\n      16,\n      58,\n      17,\n      182,\n      189,\n      28,\n      42,\n      223,\n      183,\n      170,\n      213,\n      119,\n      248,\n      152,\n      2,\n      44,\n      154,\n      163,\n      70,\n      221,\n      153,\n      101,\n      155,\n      167,\n      43,\n      172,\n      9,\n      129,\n      22,\n      39,\n      253,\n      19,\n      98,\n      108,\n      110,\n      79,\n      113,\n      224,\n      232,\n      178,\n      185,\n      112,\n      104,\n      218,\n      246,\n      97,\n      228,\n      251,\n      34,\n      242,\n      193,\n      238,\n      210,\n      144,\n      12,\n      191,\n      179,\n      162,\n      241,\n      81,\n      51,\n      145,\n      235,\n      249,\n      14,\n      239,\n      107,\n      49,\n      192,\n      214,\n      31,\n      181,\n      199,\n      106,\n      157,\n      184,\n      84,\n      204,\n      176,\n      115,\n      121,\n      50,\n      45,\n      127,\n      4,\n      150,\n      254,\n      138,\n      236,\n      205,\n      93,\n      222,\n      114,\n      67,\n      29,\n      24,\n      72,\n      243,\n      141,\n      128,\n      195,\n      78,\n      66,\n      215,\n      61,\n      156,\n      180,\n    ];\n  \n    /**\n     * An implimentation of Perlin Noise by Ken Perlin.\n     */\n    class Perlin {\n      /**\n       *\n       * @param {number} seed Seed Value for PRNG.\n       */\n      constructor(seed) {\n        const _gradientVecs = [\n          // 2D Vecs\n          new THREE__namespace.Vector3(1, 1, 0),\n          new THREE__namespace.Vector3(-1, 1, 0),\n          new THREE__namespace.Vector3(1, -1, 0),\n          new THREE__namespace.Vector3(-1, -1, 0),\n          // + 3D Vecs\n          new THREE__namespace.Vector3(1, 0, 1),\n          new THREE__namespace.Vector3(-1, 0, 1),\n          new THREE__namespace.Vector3(1, 0, -1),\n          new THREE__namespace.Vector3(-1, 0, -1),\n          new THREE__namespace.Vector3(0, 1, 1),\n          new THREE__namespace.Vector3(0, -1, 1),\n          new THREE__namespace.Vector3(0, 1, -1),\n          new THREE__namespace.Vector3(0, -1, -1),\n        ];\n  \n        var perm = new Array(512);\n        var gradP = new Array(512);\n  \n        if (!seed) seed = 1;\n        seed *= 65536;\n  \n        seed = Math.floor(seed);\n        if (seed < 256) {\n          seed |= seed << 8;\n        }\n  \n        for (var i = 0; i < 256; i++) {\n          var v;\n          if (i & 1) {\n            v = p[i] ^ (seed & 255);\n          } else {\n            v = p[i] ^ ((seed >> 8) & 255);\n          }\n  \n          perm[i] = perm[i + 256] = v;\n          gradP[i] = gradP[i + 256] = _gradientVecs[v % 12];\n        }\n  \n        this._seed = seed;\n  \n        this._offsetMatrix = [\n          new THREE__namespace.Vector3(0, 0, 0),\n          new THREE__namespace.Vector3(0, 0, 1),\n          new THREE__namespace.Vector3(0, 1, 0),\n          new THREE__namespace.Vector3(0, 1, 1),\n          new THREE__namespace.Vector3(1, 0, 0),\n          new THREE__namespace.Vector3(1, 0, 1),\n          new THREE__namespace.Vector3(1, 1, 0),\n          new THREE__namespace.Vector3(1, 1, 1),\n        ];\n  \n        /**\n         * GLSL Shader Chunk for 2D Perlin Noise. Can be used with\n         * three-CustomShaderMaterial.\n         * See: <a href=\"https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\">three-CustomShaderMaterial</a>\n         */\n        this.shaderChunk = {\n          defines: \"\",\n          header: definitions_perlin,\n          main: \"\",\n          uniforms: [{ three_noise_seed: this._seed }],\n        };\n  \n        this.perm = perm;\n        this.gradP = gradP;\n      }\n  \n      _fade(t) {\n        return t * t * t * (t * (t * 6 - 15) + 10);\n      }\n  \n      _lerp(a, b, t) {\n        return (1 - t) * a + t * b;\n      }\n  \n      _gradient(posInCell) {\n        if (posInCell instanceof THREE__namespace.Vector3) {\n          return posInCell.x + this.perm[posInCell.y + this.perm[posInCell.z]];\n        } else {\n          return posInCell.x + this.perm[posInCell.y];\n        }\n      }\n  \n      /**\n       * Maps a number from one range to another.\n       * @param {number} x       Input Number\n       * @param {number} in_min  Current range minimum\n       * @param {number} in_max  Current range maximum\n       * @param {number} out_min New range minimum\n       * @param {number} out_max New range maximum\n       * @returns {number} Input Mapped to range [out_min, out_max]\n       */\n      static map(x, in_min, in_max, out_min, out_max) {\n        return ((x - in_min) * (out_max - out_min)) / (in_max - in_min) + out_min;\n      }\n  \n      /**\n       * Samples 2D Perlin Nosie at given coordinates.\n       * @param {THREE.Vector2 | THREE.Vector3} input Coordincates to sample at\n       * @returns {number} Value of Perlin Noise at that coordinate.\n       */\n      get2(input) {\n        if (input.z !== undefined) input = new THREE__namespace.Vector2(input.x, input.y);\n  \n        const cell = new THREE__namespace.Vector2(Math.floor(input.x), Math.floor(input.y));\n        input.sub(cell);\n  \n        cell.x &= 255;\n        cell.y &= 255;\n  \n        const gradiantDot = [];\n        for (let i = 0; i < 4; i++) {\n          const s3 = this._offsetMatrix[i * 2];\n          const s = new THREE__namespace.Vector2(s3.x, s3.y);\n  \n          const grad3 =\n            this.gradP[this._gradient(new THREE__namespace.Vector2().addVectors(cell, s))];\n          const grad2 = new THREE__namespace.Vector2(grad3.x, grad3.y);\n          const dist2 = new THREE__namespace.Vector2().subVectors(input, s);\n  \n          gradiantDot.push(grad2.dot(dist2));\n        }\n  \n        const u = this._fade(input.x);\n        const v = this._fade(input.y);\n  \n        const value = this._lerp(\n          this._lerp(gradiantDot[0], gradiantDot[2], u),\n          this._lerp(gradiantDot[1], gradiantDot[3], u),\n          v\n        );\n  \n        return value;\n      }\n  \n      /**\n       * Samples 3D Perlin Nosie at given coordinates.\n       * @param {THREE.Vector}3 input Coordincates to sample at\n       * @returns {number} Value of Perlin Noise at that coordinate.\n       */\n      get3(input) {\n        if (input.z === undefined)\n          throw \"Input to Perlin::get3() must be of type THREE.Vector3\";\n  \n        const cell = new THREE__namespace.Vector3(\n          Math.floor(input.x),\n          Math.floor(input.y),\n          Math.floor(input.z)\n        );\n        input.sub(cell);\n  \n        cell.x &= 255;\n        cell.y &= 255;\n        cell.z &= 255;\n  \n        const gradiantDot = [];\n        for (let i = 0; i < 8; i++) {\n          const s = this._offsetMatrix[i];\n  \n          const grad3 =\n            this.gradP[this._gradient(new THREE__namespace.Vector3().addVectors(cell, s))];\n          const dist2 = new THREE__namespace.Vector3().subVectors(input, s);\n  \n          gradiantDot.push(grad3.dot(dist2));\n        }\n  \n        const u = this._fade(input.x);\n        const v = this._fade(input.y);\n        const w = this._fade(input.z);\n  \n        const value = this._lerp(\n          this._lerp(\n            this._lerp(gradiantDot[0], gradiantDot[4], u),\n            this._lerp(gradiantDot[1], gradiantDot[5], u),\n            w\n          ),\n          this._lerp(\n            this._lerp(gradiantDot[2], gradiantDot[6], u),\n            this._lerp(gradiantDot[3], gradiantDot[7], u),\n            w\n          ),\n          v\n        );\n  \n        return value;\n      }\n    }\n  \n    /**\n     * This class is an implimentaiton of a Fractal Brownian Motion\n     * function using Perlin Nosie.\n     */\n    class FBM {\n      /**\n       * Create an instance of the FBM class.\n       * Use this instance to generate fBm noise.\n       *\n       * @param {Object} options Options for fBm generaiton.\n       * @param {number} options.seed Seed for Perlin Noise\n       * @param {number} options.scale What distance to view the noisemap\n       * @param {number} options.persistance How much each octave contributes to the overall shape\n       * @param {number} options.lacunarity How much detail is added or removed at each octave\n       * @param {number} options.octaves Levels of detail you want you perlin noise to have\n       * @param {number} options.redistribution Level of flatness within the valleys\n       */\n      constructor(options) {\n        const { seed, scale, persistance, lacunarity, octaves, redistribution } =\n          options;\n        this._noise = new Perlin(seed);\n        this._scale = scale || 1;\n        this._persistance = persistance || 0.5;\n        this._lacunarity = lacunarity || 2;\n        this._octaves = octaves || 6;\n        this._redistribution = redistribution || 1;\n      }\n  \n      /**\n       * Sample 2D Perlin Noise with fBm at given\n       * coordinates. The function will use <code>Perlin_get2</code> or <code>Perlin_get3</code>\n       * depending on the input vector's type.\n       *\n       * @param {(THREE.Vector2 | THREE.Vector3)} input Coordinates to sample noise at.\n       * @returns {number} Normalized noise in the range [0, 1]\n       */\n      get2(input) {\n        let result = 0;\n        let amplitude = 1;\n        let frequency = 1;\n        let max = amplitude;\n  \n        let noiseFunction = this._noise.get2.bind(this._noise);\n  \n        for (let i = 0; i < this._octaves; i++) {\n          const position = new THREE__namespace.Vector2(\n            input.x * this._scale * frequency,\n            input.y * this._scale * frequency\n          );\n  \n          const noiseVal = noiseFunction(position);\n          result += noiseVal * amplitude;\n  \n          frequency *= this._lacunarity;\n          amplitude *= this._persistance;\n          max += amplitude;\n        }\n  \n        const redistributed = Math.pow(result, this._redistribution);\n        return redistributed / max;\n      }\n  \n      /**\n       * Sample 3D Perlin Noise with fBm at given\n       * coordinates. The function will use <code>Perlin_get2</code> or <code>Perlin_get3</code>\n       * depending on the input vector's type.\n       *\n       * @param {THREE.Vector3} input Coordinates to sample noise at.\n       * @returns {number} Normalized noise in the range [0, 1]\n       */\n      get3(input) {\n        let result = 0;\n        let amplitude = 1;\n        let frequency = 1;\n        let max = amplitude;\n  \n        let noiseFunction = this._noise.get3.bind(this._noise);\n  \n        for (let i = 0; i < this._octaves; i++) {\n          const position = new THREE__namespace.Vector2(\n            input.x * this._scale * frequency,\n            input.y * this._scale * frequency,\n            input.z * this._scale * frequency\n          );\n  \n          const noiseVal = noiseFunction(position);\n          result += noiseVal * amplitude;\n  \n          frequency *= this._lacunarity;\n          amplitude *= this._persistance;\n          max += amplitude;\n        }\n  \n        const redistributed = Math.pow(result, this._redistribution);\n        return redistributed / max;\n      }\n    }\n  \n    exports.FBM = FBM;\n    exports.Perlin = Perlin;\n  \n    Object.defineProperty(exports, '__esModule', { value: true });\n  \n    return exports;\n  \n  }({}, THREE));"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _regeneratorRuntime from \"/Users/year12/Desktop/Harvey/alevel_2020-2021/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/year12/Desktop/Harvey/alevel_2020-2021/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"/Users/year12/Desktop/Harvey/alevel_2020-2021/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n// Written By Harvey Randall \\\\\n// This file aims to make communicatiom between client and server a lot easier, using promise\n//-------------[   Imports   ]-------------\\\\\nimport { PriorityQueue } from '../Algorithms/PriorityQueue';\nimport * as Joi from 'joi'; //-------------[Core Variables]-------------\\\\\n\nvar client = undefined;\nvar Queue = new PriorityQueue(function (a, b) {\n  return a.prority > b.prority;\n});\n/**\n *  @param {string} socket - The socket io Client\n */\n\nexport function StartSeverClientCommunication(socket) {\n  client = socket; //Data Handshake\n\n  client.emit(\"ConnectionEstablised\", Date.now());\n}\n/**\n *  @param {string} event - The Event name\n *  @param {array} data   - The data to send to the server \n */\n\n_c = StartSeverClientCommunication;\nexport function sendDataWithPromise(event, data) {\n  var _arguments = arguments;\n  //-------------[   Create a basic promise to return data   ]-------------\\\\\n  var DataPromise = new Promise(function (resolve, reject) {\n    var resolved = false;\n\n    try {\n      var _client;\n\n      (_client = client).emit.apply(_client, [event].concat(_toConsumableArray(data)));\n\n      client.on(event + \"_Callback\", function () {\n        resolved = true;\n        resolve.apply(void 0, _toConsumableArray(_arguments));\n      });\n    } catch (err) {\n      resolved = true;\n      reject(err);\n    }\n\n    setTimeout(function () {\n      if (resolved === false) {\n        resolved = true;\n        reject(\"No data returned within 2 seconds, is there a data callback?\");\n      }\n    }, 2000);\n  });\n  return DataPromise;\n}\n/**\n *  @param {string} event        - The Event name\n *  @param {function} callback   - The function that will be called with the data back\n */\n\nexport function ListenToEvent(event, callback) {\n  // Attach event handle to functions\n  client.on(event, callback);\n}\n/**\n *  @param {function} callback   - The function that will listen to all events sent to the client\n */\n\n_c2 = ListenToEvent;\nexport function AttachToMainEventStream(callback) {\n  client.onAny(function (eventName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    callback(eventName, args);\n  });\n}\n/**  \n *  @param {string} event        - The name of the event to listen to\n *  @param {scema} scema         - The data scheme to folow\n *  @param {function} callback   - The function that will be called with the data\n */\n\n_c3 = AttachToMainEventStream;\nexport function ListenForEventWithSchemaValidation(_x, _x2, _x3) {\n  return _ListenForEventWithSchemaValidation.apply(this, arguments);\n}\n_c5 = ListenForEventWithSchemaValidation;\n\nfunction _ListenForEventWithSchemaValidation() {\n  _ListenForEventWithSchemaValidation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(event, scema, callback) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            ListenToEvent(event, function (args) {\n              var _scema$validate = scema.validate(args),\n                  error = _scema$validate.error,\n                  value = _scema$validate.value;\n\n              if (error) {\n                throw new Error(\"Scehma Check Failed\");\n              } else {\n                callback(value);\n                return value;\n              }\n            });\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _ListenForEventWithSchemaValidation.apply(this, arguments);\n}\n\n_c4 = ListenForEventWithSchemaValidation;\nexport function AddDataToQueue(event, data, callback) {\n  var prority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  Queue.push({\n    prority: prority,\n    input: [event, data, callback]\n  });\n} //-------------[   All Non essesntial communcation   ]-------------\\\\\n\n_c6 = AddDataToQueue;\nsetInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n  var func, input, callBack, data;\n  return _regeneratorRuntime.wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (Queue.isEmpty()) {\n            _context.next = 14;\n            break;\n          }\n\n          func = Queue.pop();\n          input = func.input;\n          callBack = input[2];\n          _context.prev = 4;\n          _context.next = 7;\n          return sendDataWithPromise.apply(void 0, [input[0]].concat(_toConsumableArray(input[1])));\n\n        case 7:\n          data = _context.sent;\n          callBack(false, data);\n          _context.next = 14;\n          break;\n\n        case 11:\n          _context.prev = 11;\n          _context.t0 = _context[\"catch\"](4);\n          callBack(true, []);\n\n        case 14:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _callee, null, [[4, 11]]);\n})), 500);\n\nvar _c, _c2, _c3, _c4, _c5, _c6;\n\n$RefreshReg$(_c, \"StartSeverClientCommunication\");\n$RefreshReg$(_c2, \"ListenToEvent\");\n$RefreshReg$(_c3, \"AttachToMainEventStream\");\n$RefreshReg$(_c4, \"ListenForEventWithSchemaValidation\");\n$RefreshReg$(_c5, \"ListenForEventWithSchemaValidation\");\n$RefreshReg$(_c6, \"AddDataToQueue\");","map":{"version":3,"sources":["/Users/year12/Desktop/Harvey/alevel_2020-2021/components/Core-API/ConnectAPI.js"],"names":["PriorityQueue","Joi","client","undefined","Queue","a","b","prority","StartSeverClientCommunication","socket","emit","Date","now","sendDataWithPromise","event","data","DataPromise","Promise","resolve","reject","resolved","on","arguments","err","setTimeout","ListenToEvent","callback","AttachToMainEventStream","onAny","eventName","args","ListenForEventWithSchemaValidation","scema","validate","error","value","Error","AddDataToQueue","push","input","setInterval","isEmpty","func","pop","callBack"],"mappings":"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","sourcesContent":["// Written By Harvey Randall \\\\\n\n// This file aims to make communicatiom between client and server a lot easier, using promise\n\n//-------------[   Imports   ]-------------\\\\\nimport { PriorityQueue } from '../Algorithms/PriorityQueue'\nimport * as Joi from 'joi'\n\n//-------------[Core Variables]-------------\\\\\nlet client = undefined;\nlet Queue = new PriorityQueue((a, b) => a.prority > b.prority)\n\n\n/**\n *  @param {string} socket - The socket io Client\n */\nexport function StartSeverClientCommunication(socket) {\n    client = socket\n\n    //Data Handshake\n    client.emit(\"ConnectionEstablised\", Date.now());\n}\n\n/**\n *  @param {string} event - The Event name\n *  @param {array} data   - The data to send to the server \n */\nexport function sendDataWithPromise(event, data) {\n    //-------------[   Create a basic promise to return data   ]-------------\\\\\n    const DataPromise = new Promise((resolve, reject) => {\n        let resolved = false\n        try {\n            client.emit(event, ...data)\n\n            client.on(event + \"_Callback\", () => {\n                resolved = true\n                resolve(...arguments)\n            })\n        }\n        catch (err) {\n            resolved = true\n            reject(err)\n        }\n        setTimeout(() => {\n            if (resolved === false) {\n                resolved = true\n                reject(\"No data returned within 2 seconds, is there a data callback?\")\n            }\n        }, 2000)\n\n    });\n    return DataPromise\n}\n\n\n/**\n *  @param {string} event        - The Event name\n *  @param {function} callback   - The function that will be called with the data back\n */\nexport function ListenToEvent(event, callback) {\n\n    // Attach event handle to functions\n    client.on(event, callback)\n}\n\n\n/**\n *  @param {function} callback   - The function that will listen to all events sent to the client\n */\nexport function AttachToMainEventStream(callback) {\n    client.onAny((eventName, ...args) => {\n        callback(eventName, args)\n    });\n}\n\n/**  \n *  @param {string} event        - The name of the event to listen to\n *  @param {scema} scema         - The data scheme to folow\n *  @param {function} callback   - The function that will be called with the data\n */\nexport async function ListenForEventWithSchemaValidation(event, scema, callback) {\n    ListenToEvent(event, (args) => {\n        const { error, value } = scema.validate(args);\n        if (error) {\n            throw new Error(\"Scehma Check Failed\")\n        }\n        else {\n            callback(value)\n            return value\n        }\n    })\n}\n\nexport function AddDataToQueue(event, data, callback, prority = 1) {\n    Queue.push({ prority, input: [event, data, callback] })\n}\n\n//-------------[   All Non essesntial communcation   ]-------------\\\\\nsetInterval(async() => {\n    if (!Queue.isEmpty()) {\n        let func = Queue.pop()\n        let input = func.input\n        let callBack = input[2]\n\n        try {\n            //Destructure and send data\n            let data = await sendDataWithPromise(input[0], ...input[1])\n            callBack(false, data)\n        }catch{\n            callBack(true, [])\n        }\n    }\n}, 500)\n"]},"metadata":{},"sourceType":"module"}
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = require('../ssr-module-cache.js');
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete installedModules[moduleId];
/******/ 		}
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./pages/test.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./components/Algorithms/PriorityQueue.js":
/*!************************************************!*\
  !*** ./components/Algorithms/PriorityQueue.js ***!
  \************************************************/
/*! exports provided: PriorityQueue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PriorityQueue\", function() { return PriorityQueue; });\nconst top = 0;\n\nconst parent = i => (i + 1 >>> 1) - 1;\n\nconst left = i => (i << 1) + 1;\n\nconst right = i => i + 1 << 1;\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this._heap = [];\n    this._comparator = comparator;\n  }\n\n  size() {\n    return this._heap.length;\n  }\n\n  isEmpty() {\n    return this.size() == 0;\n  }\n\n  peek() {\n    return this._heap[top];\n  }\n\n  push(...values) {\n    values.forEach(value => {\n      this._heap.push(value);\n\n      this._siftUp();\n    });\n    return this.size();\n  }\n\n  pop() {\n    const poppedValue = this.peek();\n    const bottom = this.size() - 1;\n\n    if (bottom > top) {\n      this._swap(top, bottom);\n    }\n\n    this._heap.pop();\n\n    this._siftDown();\n\n    return poppedValue;\n  }\n\n  replace(value) {\n    const replacedValue = this.peek();\n    this._heap[top] = value;\n\n    this._siftDown();\n\n    return replacedValue;\n  }\n\n  _greater(i, j) {\n    return this._comparator(this._heap[i], this._heap[j]);\n  }\n\n  _swap(i, j) {\n    [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];\n  }\n\n  _siftUp() {\n    let node = this.size() - 1;\n\n    while (node > top && this._greater(node, parent(node))) {\n      this._swap(node, parent(node));\n\n      node = parent(node);\n    }\n  }\n\n  _siftDown() {\n    let node = top;\n\n    while (left(node) < this.size() && this._greater(left(node), node) || right(node) < this.size() && this._greater(right(node), node)) {\n      let maxChild = right(node) < this.size() && this._greater(right(node), left(node)) ? right(node) : left(node);\n\n      this._swap(node, maxChild);\n\n      node = maxChild;\n    }\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL0FsZ29yaXRobXMvUHJpb3JpdHlRdWV1ZS5qcz80ZmExIl0sIm5hbWVzIjpbInRvcCIsInBhcmVudCIsImkiLCJsZWZ0IiwicmlnaHQiLCJQcmlvcml0eVF1ZXVlIiwiY29uc3RydWN0b3IiLCJjb21wYXJhdG9yIiwiYSIsImIiLCJfaGVhcCIsIl9jb21wYXJhdG9yIiwic2l6ZSIsImxlbmd0aCIsImlzRW1wdHkiLCJwZWVrIiwicHVzaCIsInZhbHVlcyIsImZvckVhY2giLCJ2YWx1ZSIsIl9zaWZ0VXAiLCJwb3AiLCJwb3BwZWRWYWx1ZSIsImJvdHRvbSIsIl9zd2FwIiwiX3NpZnREb3duIiwicmVwbGFjZSIsInJlcGxhY2VkVmFsdWUiLCJfZ3JlYXRlciIsImoiLCJub2RlIiwibWF4Q2hpbGQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQSxNQUFNQSxHQUFHLEdBQUcsQ0FBWjs7QUFDQSxNQUFNQyxNQUFNLEdBQUdDLENBQUMsSUFBSSxDQUFFQSxDQUFDLEdBQUcsQ0FBTCxLQUFZLENBQWIsSUFBa0IsQ0FBdEM7O0FBQ0EsTUFBTUMsSUFBSSxHQUFHRCxDQUFDLElBQUksQ0FBQ0EsQ0FBQyxJQUFJLENBQU4sSUFBVyxDQUE3Qjs7QUFDQSxNQUFNRSxLQUFLLEdBQUdGLENBQUMsSUFBS0EsQ0FBQyxHQUFHLENBQUwsSUFBVyxDQUE5Qjs7QUFFTyxNQUFNRyxhQUFOLENBQW9CO0FBQ3pCQyxhQUFXLENBQUNDLFVBQVUsR0FBRyxDQUFDQyxDQUFELEVBQUlDLENBQUosS0FBVUQsQ0FBQyxHQUFHQyxDQUE1QixFQUErQjtBQUN4QyxTQUFLQyxLQUFMLEdBQWEsRUFBYjtBQUNBLFNBQUtDLFdBQUwsR0FBbUJKLFVBQW5CO0FBQ0Q7O0FBQ0RLLE1BQUksR0FBRztBQUNMLFdBQU8sS0FBS0YsS0FBTCxDQUFXRyxNQUFsQjtBQUNEOztBQUNEQyxTQUFPLEdBQUc7QUFDUixXQUFPLEtBQUtGLElBQUwsTUFBZSxDQUF0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VUFBSSxHQUFHQyxRQUFQO0FBQ0Q7QUFDRjs7QUE1RHdCIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9BbGdvcml0aG1zL1ByaW9yaXR5UXVldWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB0b3AgPSAwO1xuY29uc3QgcGFyZW50ID0gaSA9PiAoKGkgKyAxKSA+Pj4gMSkgLSAxO1xuY29uc3QgbGVmdCA9IGkgPT4gKGkgPDwgMSkgKyAxO1xuY29uc3QgcmlnaHQgPSBpID0+IChpICsgMSkgPDwgMTtcblxuZXhwb3J0IGNsYXNzIFByaW9yaXR5UXVldWUge1xuICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yID0gKGEsIGIpID0+IGEgPiBiKSB7XG4gICAgdGhpcy5faGVhcCA9IFtdO1xuICAgIHRoaXMuX2NvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYXAubGVuZ3RoO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSgpID09IDA7XG4gIH1cbiAgcGVlaygpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhcFt0b3BdO1xuICB9XG4gIHB1c2goLi4udmFsdWVzKSB7XG4gICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgdGhpcy5faGVhcC5wdXNoKHZhbHVlKTtcbiAgICAgIHRoaXMuX3NpZnRVcCgpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnNpemUoKTtcbiAgfVxuICBwb3AoKSB7XG4gICAgY29uc3QgcG9wcGVkVmFsdWUgPSB0aGlzLnBlZWsoKTtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLnNpemUoKSAtIDE7XG4gICAgaWYgKGJvdHRvbSA+IHRvcCkge1xuICAgICAgdGhpcy5fc3dhcCh0b3AsIGJvdHRvbSk7XG4gICAgfVxuICAgIHRoaXMuX2hlYXAucG9wKCk7XG4gICAgdGhpcy5fc2lmdERvd24oKTtcbiAgICByZXR1cm4gcG9wcGVkVmFsdWU7XG4gIH1cbiAgcmVwbGFjZSh2YWx1ZSkge1xuICAgIGNvbnN0IHJlcGxhY2VkVmFsdWUgPSB0aGlzLnBlZWsoKTtcbiAgICB0aGlzLl9oZWFwW3RvcF0gPSB2YWx1ZTtcbiAgICB0aGlzLl9zaWZ0RG93bigpO1xuICAgIHJldHVybiByZXBsYWNlZFZhbHVlO1xuICB9XG4gIF9ncmVhdGVyKGksIGopIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcGFyYXRvcih0aGlzLl9oZWFwW2ldLCB0aGlzLl9oZWFwW2pdKTtcbiAgfVxuICBfc3dhcChpLCBqKSB7XG4gICAgW3RoaXMuX2hlYXBbaV0sIHRoaXMuX2hlYXBbal1dID0gW3RoaXMuX2hlYXBbal0sIHRoaXMuX2hlYXBbaV1dO1xuICB9XG4gIF9zaWZ0VXAoKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLnNpemUoKSAtIDE7XG4gICAgd2hpbGUgKG5vZGUgPiB0b3AgJiYgdGhpcy5fZ3JlYXRlcihub2RlLCBwYXJlbnQobm9kZSkpKSB7XG4gICAgICB0aGlzLl9zd2FwKG5vZGUsIHBhcmVudChub2RlKSk7XG4gICAgICBub2RlID0gcGFyZW50KG5vZGUpO1xuICAgIH1cbiAgfVxuICBfc2lmdERvd24oKSB7XG4gICAgbGV0IG5vZGUgPSB0b3A7XG4gICAgd2hpbGUgKFxuICAgICAgKGxlZnQobm9kZSkgPCB0aGlzLnNpemUoKSAmJiB0aGlzLl9ncmVhdGVyKGxlZnQobm9kZSksIG5vZGUpKSB8fFxuICAgICAgKHJpZ2h0KG5vZGUpIDwgdGhpcy5zaXplKCkgJiYgdGhpcy5fZ3JlYXRlcihyaWdodChub2RlKSwgbm9kZSkpXG4gICAgKSB7XG4gICAgICBsZXQgbWF4Q2hpbGQgPSAocmlnaHQobm9kZSkgPCB0aGlzLnNpemUoKSAmJiB0aGlzLl9ncmVhdGVyKHJpZ2h0KG5vZGUpLCBsZWZ0KG5vZGUpKSkgPyByaWdodChub2RlKSA6IGxlZnQobm9kZSk7XG4gICAgICB0aGlzLl9zd2FwKG5vZGUsIG1heENoaWxkKTtcbiAgICAgIG5vZGUgPSBtYXhDaGlsZDtcbiAgICB9XG4gIH1cbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Algorithms/PriorityQueue.js\n");

/***/ }),

/***/ "./components/Context/socketioContext.js":
/*!***********************************************!*\
  !*** ./components/Context/socketioContext.js ***!
  \***********************************************/
/*! exports provided: AppWrapper, useAppContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AppWrapper\", function() { return AppWrapper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useAppContext\", function() { return useAppContext; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"socket.io-client\");\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(socket_io_client__WEBPACK_IMPORTED_MODULE_2__);\n\nvar _jsxFileName = \"/Users/year12/Desktop/Harvey/alevel_2020-2021/components/contextHandler.js\";\n\n\nconst AppContext = /*#__PURE__*/Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createContext\"])();\nfunction AppWrapper({\n  children\n}) {\n  let sharedState = Object(socket_io_client__WEBPACK_IMPORTED_MODULE_2__[\"io\"])();\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(AppContext.Provider, {\n    value: sharedState,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 10,\n    columnNumber: 5\n  }, this);\n}\nfunction useAppContext() {\n  return Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(AppContext);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRleHRIYW5kbGVyLmpzP2NlZjMiXSwibmFtZXMiOlsiQXBwQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJBcHBXcmFwcGVyIiwiY2hpbGRyZW4iLCJzaGFyZWRTdGF0ZSIsImlvIiwidXNlQXBwQ29udGV4dCIsInVzZUNvbnRleHQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUVBLE1BQU1BLFVBQVUsZ0JBQUdDLDJEQUFhLEVBQWhDO0FBRU8sU0FBU0MsVUFBVCxDQUFvQjtBQUFFQztBQUFGLENBQXBCLEVBQWtDO0FBQ3ZDLE1BQUlDLFdBQVcsR0FBR0MsMkRBQUUsRUFBcEI7QUFFQSxzQkFDRSxxRUFBQyxVQUFELENBQVksUUFBWjtBQUFxQixTQUFLLEVBQUVELFdBQTVCO0FBQUEsY0FDR0Q7QUFESDtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBREY7QUFLRDtBQUVNLFNBQVNHLGFBQVQsR0FBeUI7QUFDOUIsU0FBT0Msd0RBQVUsQ0FBQ1AsVUFBRCxDQUFqQjtBQUNEIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9Db250ZXh0L3NvY2tldGlvQ29udGV4dC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpbyB9IGZyb20gXCJzb2NrZXQuaW8tY2xpZW50XCI7XG5cbmNvbnN0IEFwcENvbnRleHQgPSBjcmVhdGVDb250ZXh0KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBBcHBXcmFwcGVyKHsgY2hpbGRyZW4gfSkge1xuICBsZXQgc2hhcmVkU3RhdGUgPSBpbygpXG5cbiAgcmV0dXJuIChcbiAgICA8QXBwQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17c2hhcmVkU3RhdGV9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQXBwQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFwcENvbnRleHQoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/Context/socketioContext.js\n");

/***/ }),

/***/ "./components/Core-API/ConnectAPI.js":
/*!*******************************************!*\
  !*** ./components/Core-API/ConnectAPI.js ***!
  \*******************************************/
/*! exports provided: StartSeverClientCommunication, sendDataWithPromise, ListenToEvent, AttachToMainEventStream, ListenForEventWithSchemaValidation, AddDataToQueue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StartSeverClientCommunication\", function() { return StartSeverClientCommunication; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sendDataWithPromise\", function() { return sendDataWithPromise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ListenToEvent\", function() { return ListenToEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AttachToMainEventStream\", function() { return AttachToMainEventStream; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ListenForEventWithSchemaValidation\", function() { return ListenForEventWithSchemaValidation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AddDataToQueue\", function() { return AddDataToQueue; });\n/* harmony import */ var _Algorithms_PriorityQueue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Algorithms/PriorityQueue */ \"./components/Algorithms/PriorityQueue.js\");\n/* harmony import */ var joi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! joi */ \"./node_modules/joi/lib/index.js\");\n/* harmony import */ var joi__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(joi__WEBPACK_IMPORTED_MODULE_1__);\n// Written By Harvey Randall \\\\\n// This file aims to make communicatiom between client and server a lot easier, using promise\n//-------------[   Imports   ]-------------\\\\\n\n //-------------[Core Variables]-------------\\\\\n\nlet client = undefined;\nlet Queue = new _Algorithms_PriorityQueue__WEBPACK_IMPORTED_MODULE_0__[\"PriorityQueue\"]((a, b) => a.prority > b.prority);\n/**\n *  @param {string} socket - The socket io Client\n */\n\nfunction StartSeverClientCommunication(socket) {\n  client = socket; //Data Handshake\n\n  client.emit(\"ConnectionEstablised\", Date.now());\n}\n/**\n *  @param {string} event - The Event name\n *  @param {array} data   - The data to send to the server \n */\n\nfunction sendDataWithPromise(event, data) {\n  //-------------[   Create a basic promise to return data   ]-------------\\\\\n  const DataPromise = new Promise((resolve, reject) => {\n    let resolved = false;\n\n    try {\n      client.emit(event, ...data);\n      client.on(event + \"_Callback\", () => {\n        resolved = true;\n        resolve(...arguments);\n      });\n    } catch (err) {\n      resolved = true;\n      reject(err);\n    }\n\n    setTimeout(() => {\n      if (resolved === false) {\n        resolved = true;\n        reject(\"No data returned within 2 seconds, is there a data callback?\");\n      }\n    }, 2000);\n  });\n  return DataPromise;\n}\n/**\n *  @param {string} event        - The Event name\n *  @param {function} callback   - The function that will be called with the data back\n */\n\nfunction ListenToEvent(event, callback) {\n  // Attach event handle to functions\n  client.on(event, callback);\n}\n/**\n *  @param {function} callback   - The function that will listen to all events sent to the client\n */\n\nfunction AttachToMainEventStream(callback) {\n  client.onAny((eventName, ...args) => {\n    callback(eventName, args);\n  });\n}\n/**  \n *  @param {string} event        - The name of the event to listen to\n *  @param {scema} scema         - The data scheme to folow\n *  @param {function} callback   - The function that will be called with the data\n */\n\nasync function ListenForEventWithSchemaValidation(event, scema, callback) {\n  ListenToEvent(event, args => {\n    const {\n      error,\n      value\n    } = scema.validate(args);\n\n    if (error) {\n      throw new Error(\"Scehma Check Failed\");\n    } else {\n      callback(value);\n      return value;\n    }\n  });\n}\nfunction AddDataToQueue(event, data, callback, prority = 1) {\n  Queue.push({\n    prority,\n    input: [event, data, callback]\n  });\n} //-------------[   All Non essesntial communcation   ]-------------\\\\\n\nsetInterval(async () => {\n  if (!Queue.isEmpty()) {\n    let func = Queue.pop();\n    let input = func.input;\n    let callBack = input[2];\n\n    try {\n      //Destructure and send data\n      let data = await sendDataWithPromise(input[0], ...input[1]);\n      callBack(false, data);\n    } catch {\n      callBack(true, []);\n    }\n  }\n}, 500);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL0NvcmUtQVBJL0Nvbm5lY3RBUEkuanM/Mjk2YSJdLCJuYW1lcyI6WyJjbGllbnQiLCJ1bmRlZmluZWQiLCJRdWV1ZSIsIlByaW9yaXR5UXVldWUiLCJhIiwiYiIsInByb3JpdHkiLCJTdGFydFNldmVyQ2xpZW50Q29tbXVuaWNhdGlvbiIsInNvY2tldCIsImVtaXQiLCJEYXRlIiwibm93Iiwic2VuZERhdGFXaXRoUHJvbWlzZSIsImV2ZW50IiwiZGF0YSIsIkRhdGFQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZXNvbHZlZCIsIm9uIiwiYXJndW1lbnRzIiwiZXJyIiwic2V0VGltZW91dCIsIkxpc3RlblRvRXZlbnQiLCJjYWxsYmFjayIsIkF0dGFjaFRvTWFpbkV2ZW50U3RyZWFtIiwib25BbnkiLCJldmVudE5hbWUiLCJhcmdzIiwiTGlzdGVuRm9yRXZlbnRXaXRoU2NoZW1hVmFsaWRhdGlvbiIsInNjZW1hIiwiZXJyb3IiLCJ2YWx1ZSIsInZhbGlkYXRlIiwiRXJyb3IiLCJBZGREYXRhVG9RdWV1ZSIsInB1c2giLCJpbnB1dCIsInNldEludGVydmFsIiwiaXNFbXB0eSIsImZ1bmMiLCJwb3AiLCJjYWxsQmFjayJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtDQUdBOztBQUNBLElBQUlBLE1BQU0sR0FBR0MsU0FBYjtBQUNBLElBQUlDLEtBQUssR0FBRyxJQUFJQyx1RUFBSixDQUFrQixDQUFDQyxDQUFELEVBQUlDLENBQUosS0FBVUQsQ0FBQyxDQUFDRSxPQUFGLEdBQVlELENBQUMsQ0FBQ0MsT0FBMUMsQ0FBWjtBQUdBO0FBQ0E7QUFDQTs7QUFDTyxTQUFTQyw2QkFBVCxDQUF1Q0MsTUFBdkMsRUFBK0M7QUFDbERSLFFBQU0sR0FBR1EsTUFBVCxDQURrRCxDQUdsRDs7QUFDQVIs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S0FBSyxDQUFDLENBQUQsQ0FBbkIsQ0FBcEM7QUFDQUssY0FBUSxDQUFDLEtBQUQsRUFBUTdCLElBQVIsQ0FBUjtBQUNILEtBSkQsQ0FJQyxNQUFLO0FBQ0Y2QixjQUFRLENBQUMsSUFBRCxFQUFPLEVBQVAsQ0FBUjtBQUNIO0FBQ0o7QUFDSixDQWRVLEVBY1IsR0FkUSxDQUFYIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9Db3JlLUFQSS9Db25uZWN0QVBJLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gV3JpdHRlbiBCeSBIYXJ2ZXkgUmFuZGFsbCBcXFxcXG5cbi8vIFRoaXMgZmlsZSBhaW1zIHRvIG1ha2UgY29tbXVuaWNhdGlvbSBiZXR3ZWVuIGNsaWVudCBhbmQgc2VydmVyIGEgbG90IGVhc2llciwgdXNpbmcgcHJvbWlzZVxuXG4vLy0tLS0tLS0tLS0tLS1bICAgSW1wb3J0cyAgIF0tLS0tLS0tLS0tLS0tXFxcXFxuaW1wb3J0IHsgUHJpb3JpdHlRdWV1ZSB9IGZyb20gJy4uL0FsZ29yaXRobXMvUHJpb3JpdHlRdWV1ZSdcbmltcG9ydCAqIGFzIEpvaSBmcm9tICdqb2knXG5cbi8vLS0tLS0tLS0tLS0tLVtDb3JlIFZhcmlhYmxlc10tLS0tLS0tLS0tLS0tXFxcXFxubGV0IGNsaWVudCA9IHVuZGVmaW5lZDtcbmxldCBRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKChhLCBiKSA9PiBhLnByb3JpdHkgPiBiLnByb3JpdHkpXG5cblxuLyoqXG4gKiAgQHBhcmFtIHtzdHJpbmd9IHNvY2tldCAtIFRoZSBzb2NrZXQgaW8gQ2xpZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBTdGFydFNldmVyQ2xpZW50Q29tbXVuaWNhdGlvbihzb2NrZXQpIHtcbiAgICBjbGllbnQgPSBzb2NrZXRcblxuICAgIC8vRGF0YSBIYW5kc2hha2VcbiAgICBjbGllbnQuZW1pdChcIkNvbm5lY3Rpb25Fc3RhYmxpc2VkXCIsIERhdGUubm93KCkpO1xufVxuXG4vKipcbiAqICBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBUaGUgRXZlbnQgbmFtZVxuICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgICAtIFRoZSBkYXRhIHRvIHNlbmQgdG8gdGhlIHNlcnZlciBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbmREYXRhV2l0aFByb21pc2UoZXZlbnQsIGRhdGEpIHtcbiAgICAvLy0tLS0tLS0tLS0tLS1bICAgQ3JlYXRlIGEgYmFzaWMgcHJvbWlzZSB0byByZXR1cm4gZGF0YSAgIF0tLS0tLS0tLS0tLS0tXFxcXFxuICAgIGNvbnN0IERhdGFQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2xpZW50LmVtaXQoZXZlbnQsIC4uLmRhdGEpXG5cbiAgICAgICAgICAgIGNsaWVudC5vbihldmVudCArIFwiX0NhbGxiYWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IHRydWVcbiAgICAgICAgICAgICAgICByZXNvbHZlKC4uLmFyZ3VtZW50cylcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlXG4gICAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHJlamVjdChcIk5vIGRhdGEgcmV0dXJuZWQgd2l0aGluIDIgc2Vjb25kcywgaXMgdGhlcmUgYSBkYXRhIGNhbGxiYWNrP1wiKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyMDAwKVxuXG4gICAgfSk7XG4gICAgcmV0dXJuIERhdGFQcm9taXNlXG59XG5cblxuLyoqXG4gKiAgQHBhcmFtIHtzdHJpbmd9IGV2ZW50ICAgICAgICAtIFRoZSBFdmVudCBuYW1lXG4gKiAgQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICAtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGRhdGEgYmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gTGlzdGVuVG9FdmVudChldmVudCwgY2FsbGJhY2spIHtcblxuICAgIC8vIEF0dGFjaCBldmVudCBoYW5kbGUgdG8gZnVuY3Rpb25zXG4gICAgY2xpZW50Lm9uKGV2ZW50LCBjYWxsYmFjaylcbn1cblxuXG4vKipcbiAqICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIC0gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBsaXN0ZW4gdG8gYWxsIGV2ZW50cyBzZW50IHRvIHRoZSBjbGllbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEF0dGFjaFRvTWFpbkV2ZW50U3RyZWFtKGNhbGxiYWNrKSB7XG4gICAgY2xpZW50Lm9uQW55KChldmVudE5hbWUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY2FsbGJhY2soZXZlbnROYW1lLCBhcmdzKVxuICAgIH0pO1xufVxuXG4vKiogIFxuICogIEBwYXJhbSB7c3RyaW5nfSBldmVudCAgICAgICAgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvXG4gKiAgQHBhcmFtIHtzY2VtYX0gc2NlbWEgICAgICAgICAtIFRoZSBkYXRhIHNjaGVtZSB0byBmb2xvd1xuICogIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgLSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBMaXN0ZW5Gb3JFdmVudFdpdGhTY2hlbWFWYWxpZGF0aW9uKGV2ZW50LCBzY2VtYSwgY2FsbGJhY2spIHtcbiAgICBMaXN0ZW5Ub0V2ZW50KGV2ZW50LCAoYXJncykgPT4ge1xuICAgICAgICBjb25zdCB7IGVycm9yLCB2YWx1ZSB9ID0gc2NlbWEudmFsaWRhdGUoYXJncyk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2NlaG1hIENoZWNrIEZhaWxlZFwiKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgfVxuICAgIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBBZGREYXRhVG9RdWV1ZShldmVudCwgZGF0YSwgY2FsbGJhY2ssIHByb3JpdHkgPSAxKSB7XG4gICAgUXVldWUucHVzaCh7IHByb3JpdHksIGlucHV0OiBbZXZlbnQsIGRhdGEsIGNhbGxiYWNrXSB9KVxufVxuXG4vLy0tLS0tLS0tLS0tLS1bICAgQWxsIE5vbiBlc3Nlc250aWFsIGNvbW11bmNhdGlvbiAgIF0tLS0tLS0tLS0tLS0tXFxcXFxuc2V0SW50ZXJ2YWwoYXN5bmMoKSA9PiB7XG4gICAgaWYgKCFRdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgbGV0IGZ1bmMgPSBRdWV1ZS5wb3AoKVxuICAgICAgICBsZXQgaW5wdXQgPSBmdW5jLmlucHV0XG4gICAgICAgIGxldCBjYWxsQmFjayA9IGlucHV0WzJdXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vRGVzdHJ1Y3R1cmUgYW5kIHNlbmQgZGF0YVxuICAgICAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCBzZW5kRGF0YVdpdGhQcm9taXNlKGlucHV0WzBdLCAuLi5pbnB1dFsxXSlcbiAgICAgICAgICAgIGNhbGxCYWNrKGZhbHNlLCBkYXRhKVxuICAgICAgICB9Y2F0Y2h7XG4gICAgICAgICAgICBjYWxsQmFjayh0cnVlLCBbXSlcbiAgICAgICAgfVxuICAgIH1cbn0sIDUwMClcblxuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Core-API/ConnectAPI.js\n");

/***/ }),

/***/ "./components/Core-API/LightingManager.js":
/*!************************************************!*\
  !*** ./components/Core-API/LightingManager.js ***!
  \************************************************/
/*! exports provided: CreateDirectionalLight, CreateAmbientLight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CreateDirectionalLight\", function() { return CreateDirectionalLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CreateAmbientLight\", function() { return CreateAmbientLight; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n// Written By Harvey Randall \\\\\n\nfunction CreateDirectionalLight(Scene, color, brightness, pos) {\n  // ---------- [Simple Directional Light Manager] ---------- \\\\\n  const directionalLight = new three__WEBPACK_IMPORTED_MODULE_0__[\"DirectionalLight\"](color, brightness, 100);\n  directionalLight.position.set(...pos); // ES6 Only way to destructure POS array\n  //Shadown Managers\n\n  directionalLight.castShadow = false; //Add to Scene\n\n  Scene.add(directionalLight);\n  return directionalLight;\n}\nfunction CreateAmbientLight(Scene, color, brightness) {\n  const light = new three__WEBPACK_IMPORTED_MODULE_0__[\"AmbientLight\"](color, brightness); // soft white light\n\n  Scene.add(light);\n  return light;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL0xpZ2h0aW5nTWFuYWdlci5qcz9hNGQxIl0sIm5hbWVzIjpbIkNyZWF0ZURpcmVjdGlvbmFsTGlnaHQiLCJTY2VuZSIsImNvbG9yIiwiYnJpZ2h0bmVzcyIsInBvcyIsImRpcmVjdGlvbmFsTGlnaHQiLCJEaXJlY3Rpb25hbExpZ2h0IiwicG9zaXRpb24iLCJzZXQiLCJjYXN0U2hhZG93IiwiYWRkIiwiQ3JlYXRlQW1iaWVudExpZ2h0IiwibGlnaHQiLCJBbWJpZW50TGlnaHQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBRU8sU0FBU0Esc0JBQVQsQ0FBZ0NDLEtBQWhDLEVBQXVDQyxLQUF2QyxFQUE4Q0MsVUFBOUMsRUFBMERDLEdBQTFELEVBQStEO0FBRWxFO0FBQ0EsUUFBTUMsZ0JBQWdCLEdBQUcsSUFBSUMsc0RBQUosQ0FBcUJKLEtBQXJCLEVBQTRCQyxVQUE1QixFQUF3QyxHQUF4QyxDQUF6QjtBQUNBRSxrQkFBZ0IsQ0FBQ0UsUUFBakIsQ0FBMEJDLEdBQTFCLENBQThCLEdBQUdKLEdBQWpDLEVBSmtFLENBSTVCO0FBRXRDOztBQUNBQyxrQkFBZ0IsQ0FBQ0ksVUFBakIsR0FBOEIsS0FBOUIsQ0FQa0UsQ0FTbEU7O0FBQ0FSLE9BQUssQ0FBQ1MsR0FBTixDQUFVTCxnQkFBVjtBQUNBLFNBQU9BLGdCQUFQO0FBQ0g7QUFHTSxTQUFTTSxrQkFBVCxDQUE0QlYsS0FBNUIsRUFBbUNDLEtBQW5DLEVBQTBDQyxVQUExQyxFQUFxRDtBQUN4RCxRQUFNUyxLQUFLLEdBQUcsSUFBSUMsa0RBQUosQ0FBaUJYLEtBQWpCLEVBQXdCQyxVQUF4QixDQUFkLENBRHdELENBQ0w7O0FBQ25ERixPQUFLLENBQUNTLEdBQU4sQ0FBVUUsS0FBVjtBQUNBLFNBQU9BLEtBQVA7QUFDSCIsImZpbGUiOiIuL2NvbXBvbmVudHMvQ29yZS1BUEkvTGlnaHRpbmdNYW5hZ2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gV3JpdHRlbiBCeSBIYXJ2ZXkgUmFuZGFsbCBcXFxcXG5cbmltcG9ydCB7IEFtYmllbnRMaWdodCwgRGlyZWN0aW9uYWxMaWdodCB9IGZyb20gXCJ0aHJlZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ3JlYXRlRGlyZWN0aW9uYWxMaWdodChTY2VuZSwgY29sb3IsIGJyaWdodG5lc3MsIHBvcykge1xuXG4gICAgLy8gLS0tLS0tLS0tLSBbU2ltcGxlIERpcmVjdGlvbmFsIExpZ2h0IE1hbmFnZXJdIC0tLS0tLS0tLS0gXFxcXFxuICAgIGNvbnN0IGRpcmVjdGlvbmFsTGlnaHQgPSBuZXcgRGlyZWN0aW9uYWxMaWdodChjb2xvciwgYnJpZ2h0bmVzcywgMTAwKTtcbiAgICBkaXJlY3Rpb25hbExpZ2h0LnBvc2l0aW9uLnNldCguLi5wb3MpIC8vIEVTNiBPbmx5IHdheSB0byBkZXN0cnVjdHVyZSBQT1MgYXJyYXlcblxuICAgIC8vU2hhZG93biBNYW5hZ2Vyc1xuICAgIGRpcmVjdGlvbmFsTGlnaHQuY2FzdFNoYWRvdyA9IGZhbHNlXG5cbiAgICAvL0FkZCB0byBTY2VuZVxuICAgIFNjZW5lLmFkZChkaXJlY3Rpb25hbExpZ2h0KTtcbiAgICByZXR1cm4gZGlyZWN0aW9uYWxMaWdodFxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBDcmVhdGVBbWJpZW50TGlnaHQoU2NlbmUsIGNvbG9yLCBicmlnaHRuZXNzKXtcbiAgICBjb25zdCBsaWdodCA9IG5ldyBBbWJpZW50TGlnaHQoY29sb3IsIGJyaWdodG5lc3MpOyAvLyBzb2Z0IHdoaXRlIGxpZ2h0XG4gICAgU2NlbmUuYWRkKGxpZ2h0KTtcbiAgICByZXR1cm4gbGlnaHRcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Core-API/LightingManager.js\n");

/***/ }),

/***/ "./components/Core-API/RenderingHandler.js":
/*!*************************************************!*\
  !*** ./components/Core-API/RenderingHandler.js ***!
  \*************************************************/
/*! exports provided: addToRenderSequence, RenderingInfo, UpdateRenderCycle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addToRenderSequence\", function() { return addToRenderSequence; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RenderingInfo\", function() { return RenderingInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UpdateRenderCycle\", function() { return UpdateRenderCycle; });\n// Written By Harvey Randall \\\\\nlet renderingList = {};\n\nfunction CheckType(type) {\n  if (renderingList[type] === undefined) {\n    console.warn(\"This type does not exist on the renderingList object, is this the right type?\");\n    renderingList[type] = [];\n  }\n}\n\nfunction addToRenderSequence(type, callback, newType = false) {\n  if (newType) {\n    renderingList[type] = [];\n  }\n\n  CheckType(type);\n  renderingList[type].push(callback);\n  console.log(renderingList);\n}\nfunction RenderingInfo(type) {\n  CheckType(type);\n  return renderingList[type].length;\n}\nfunction UpdateRenderCycle(type) {\n  CheckType(type);\n  renderingList[type].forEach(item => {\n    item();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL0NvcmUtQVBJL1JlbmRlcmluZ0hhbmRsZXIuanM/YjBhZSJdLCJuYW1lcyI6WyJyZW5kZXJpbmdMaXN0IiwiQ2hlY2tUeXBlIiwidHlwZSIsInVuZGVmaW5lZCIsImNvbnNvbGUiLCJ3YXJuIiwiYWRkVG9SZW5kZXJTZXF1ZW5jZSIsImNhbGxiYWNrIiwibmV3VHlwZSIsInB1c2giLCJsb2ciLCJSZW5kZXJpbmdJbmZvIiwibGVuZ3RoIiwiVXBkYXRlUmVuZGVyQ3ljbGUiLCJmb3JFYWNoIiwiaXRlbSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLElBQUlBLGFBQWEsR0FBRyxFQUFwQjs7QUFFQSxTQUFTQyxTQUFULENBQW1CQyxJQUFuQixFQUF3QjtBQUNwQixNQUFHRixhQUFhLENBQUNFLElBQUQsQ0FBYixLQUF3QkMsU0FBM0IsRUFBcUM7QUFDakNDLFdBQU8sQ0FBQ0MsSUFBUixDQUFhLCtFQUFiO0FBQ0FMLGlCQUFhLENBQUNFLElBQUQsQ0FBYixHQUFzQixFQUF0QjtBQUNIO0FBQ0o7O0FBRU0sU0FBU0ksbUJBQVQsQ0FBNkJKLElBQTdCLEVBQW1DSyxRQUFuQyxFQUE2Q0MsT0FBTyxHQUFHLEtBQXZELEVBQTZEO0FBQ2hFLE1BQUdBLE9BQUgsRUFBVztBQUNQUixpQkFBYSxDQUFDRSxJQUFELENBQWIsR0FBc0IsRUFBdEI7QUFDSDs7QUFDREQsV0FBUyxDQUFDQyxJQUFELENBQVQ7QUFDQUYsZUFBYSxDQUFDRSxJQUFELENBQWIsQ0FBb0JPLElBQXBCLENBQXlCRixRQUF6QjtBQUNBSCxTQUFPLENBQUNNLEdBQVIsQ0FBWVYsYUFBWjtBQUNIO0FBRU0sU0FBU1csYUFBVCxDQUF1QlQsSUFBdkIsRUFBNEI7QUFDL0JELFdBQVMsQ0FBQ0MsSUFBRCxDQUFUO0FBQ0EsU0FBT0YsYUFBYSxDQUFDRSxJQUFELENBQWIsQ0FBb0JVLE1BQTNCO0FBQ0g7QUFFTSxTQUFTQyxpQkFBVCxDQUEyQlgsSUFBM0IsRUFBZ0M7QUFDbkNELFdBQVMsQ0FBQ0MsSUFBRCxDQUFUO0FBQ0FGLGVBQWEsQ0FBQ0UsSUFBRCxDQUFiLENBQW9CWSxPQUFwQixDQUE2QkMsSUFBRCxJQUFVO0FBQ2xDQSxRQUFJO0FBQ1AsR0FGRDtBQUdIIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9Db3JlLUFQSS9SZW5kZXJpbmdIYW5kbGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gV3JpdHRlbiBCeSBIYXJ2ZXkgUmFuZGFsbCBcXFxcXG5sZXQgcmVuZGVyaW5nTGlzdCA9IHt9XG5cbmZ1bmN0aW9uIENoZWNrVHlwZSh0eXBlKXtcbiAgICBpZihyZW5kZXJpbmdMaXN0W3R5cGVdID09PSB1bmRlZmluZWQpe1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGlzIHR5cGUgZG9lcyBub3QgZXhpc3Qgb24gdGhlIHJlbmRlcmluZ0xpc3Qgb2JqZWN0LCBpcyB0aGlzIHRoZSByaWdodCB0eXBlP1wiKVxuICAgICAgICByZW5kZXJpbmdMaXN0W3R5cGVdID0gW11cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRUb1JlbmRlclNlcXVlbmNlKHR5cGUsIGNhbGxiYWNrLCBuZXdUeXBlID0gZmFsc2Upe1xuICAgIGlmKG5ld1R5cGUpe1xuICAgICAgICByZW5kZXJpbmdMaXN0W3R5cGVdID0gW11cbiAgICB9XG4gICAgQ2hlY2tUeXBlKHR5cGUpXG4gICAgcmVuZGVyaW5nTGlzdFt0eXBlXS5wdXNoKGNhbGxiYWNrKVxuICAgIGNvbnNvbGUubG9nKHJlbmRlcmluZ0xpc3QpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZW5kZXJpbmdJbmZvKHR5cGUpe1xuICAgIENoZWNrVHlwZSh0eXBlKVxuICAgIHJldHVybiByZW5kZXJpbmdMaXN0W3R5cGVdLmxlbmd0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gVXBkYXRlUmVuZGVyQ3ljbGUodHlwZSl7XG4gICAgQ2hlY2tUeXBlKHR5cGUpXG4gICAgcmVuZGVyaW5nTGlzdFt0eXBlXS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGl0ZW0oKVxuICAgIH0pXG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Core-API/RenderingHandler.js\n");

/***/ }),

/***/ "./components/gameFundalmentals/DayNightCycle.js":
/*!*******************************************************!*\
  !*** ./components/gameFundalmentals/DayNightCycle.js ***!
  \*******************************************************/
/*! exports provided: CreateDayNightCycle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CreateDayNightCycle\", function() { return CreateDayNightCycle; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Core_API_LightingManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core-API/LightingManager */ \"./components/Core-API/LightingManager.js\");\n/* harmony import */ var _stars__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stars */ \"./components/gameFundalmentals/stars.js\");\n/* harmony import */ var _rotateAroundPoint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rotateAroundPoint */ \"./components/gameFundalmentals/rotateAroundPoint.js\");\n// Written By Harvey Randall \\\\\n\n\n\n\nclass CreateDayNightCycle {\n  constructor(SceneToGet, Renders) {\n    // ---------- [Two to level global variables] ---------- \\\\\n    this.SceneToGet = SceneToGet;\n    this.Renders = Renders; // ---------- [Create Sun Mesh] ---------- \\\\\n\n    let sun = new three__WEBPACK_IMPORTED_MODULE_0__[\"SphereBufferGeometry\"](20, 20, 100, 100);\n    let sunMaterial = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshLambertMaterial\"]({\n      emissive: 0xf9d71c\n    });\n    let sunmesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](sun, sunMaterial);\n    sunmesh.position.set(1, 300, 300);\n    SceneToGet.add(sunmesh); // ---------- [Create Moon Mesh] ---------- \\\\\n\n    let moon = new three__WEBPACK_IMPORTED_MODULE_0__[\"SphereBufferGeometry\"](10, 10, 100, 100);\n    let moonMaterial = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshLambertMaterial\"]({\n      emissive: 0xffffff\n    });\n    let moonMesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](moon, moonMaterial);\n    moonMesh.position.set(-1, -200, -300);\n    SceneToGet.add(moonMesh); // ---------- [Create Box Gometry for handling rotation] ---------- \\\\\n\n    var geometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxGeometry\"](1, 1, 1);\n    var cube = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](geometry);\n    cube.visible = false;\n    SceneToGet.add(cube); // ^ This is a very bad work around fix later\n    // ---------- [All defintions for the moving part] ---------- \\\\\n\n    this.cube = cube;\n    this.moonMesh = moonMesh;\n    this.sunmesh = sunmesh;\n    this.t = 0;\n    this.dTIme = 0; // ---------- [All defintions for lights to create shadows] ---------- \\\\\n\n    this.directionalLight = Object(_Core_API_LightingManager__WEBPACK_IMPORTED_MODULE_1__[\"CreateDirectionalLight\"])(SceneToGet, 0xddffee, 0.5, [1, 100, 100]);\n    this.directionalLight2 = Object(_Core_API_LightingManager__WEBPACK_IMPORTED_MODULE_1__[\"CreateDirectionalLight\"])(SceneToGet, 0xffffff, 0.2, [1, -100, -100]);\n    this.light = Object(_Core_API_LightingManager__WEBPACK_IMPORTED_MODULE_1__[\"CreateAmbientLight\"])(SceneToGet, 0xaaaaaa, 0.5); // ---------- [Create Stary night] ---------- \\\\\n\n    let skyBox = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxGeometry\"](1200, 1200, 1200);\n    let skyBoxMaterial = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]({\n      map: Object(_stars__WEBPACK_IMPORTED_MODULE_2__[\"getRandomStarField\"])(600, 2048, 2048),\n      side: three__WEBPACK_IMPORTED_MODULE_0__[\"BackSide\"]\n    });\n    this.sky = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](skyBox, skyBoxMaterial);\n  }\n\n  update() {\n    // This two lines are  important as it is part of the hacky work around to get time of day on varying FPS\n    let theta = Object(_rotateAroundPoint__WEBPACK_IMPORTED_MODULE_3__[\"rotateAboutPoint\"])(this.directionalLight, new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](1, 0, 0), 0.001, true);\n    let angle = three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].radToDeg(this.cube.rotation.x); // ---------- [Rotate all the lights and Meshes] ---------- \\\\\n\n    Object(_rotateAroundPoint__WEBPACK_IMPORTED_MODULE_3__[\"rotateAboutPoint\"])(this.sunmesh, new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](100, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](1, 0, 0), 0.001, true);\n    Object(_rotateAroundPoint__WEBPACK_IMPORTED_MODULE_3__[\"rotateAboutPoint\"])(this.moonMesh, new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](100, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](1, 0, 0), 0.001, true);\n    Object(_rotateAroundPoint__WEBPACK_IMPORTED_MODULE_3__[\"rotateAboutPoint\"])(this.directionalLight2, new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](1, 0, 0), 0.001, true); // ---------- [If it is day] ---------- \\\\\n\n    if (angle < 40 && this.dTIme < 1) {\n      this.t = 0;\n      this.directionalLight.color.setHex(0xddffee);\n      this.dTIme += 0.003;\n\n      if (this.dTIme >= 1) {\n        this.dTIme = 1;\n      }\n\n      this.Renders.setClearColor(new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]().lerpColors(new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0xFDB813), new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0x87ceeb), this.dTIme), 1);\n      this.light.intensity = 0.5;\n      this.directionalLight2.color.setHex(0x000000);\n      this.directionalLight.intensity = 0.5;\n      this.directionalLight2.intensity = 0;\n      this.SceneToGet.remove(this.sky);\n    } else if (!(angle < 40) && this.sky.parent !== this.SceneToGet) {\n      // ---------- [If it is night] ---------- \\\\\n      this.dTIme = 0;\n      this.t += 0.01;\n\n      if (this.t >= 1) {\n        this.t = 1;\n        this.SceneToGet.add(this.sky);\n      }\n\n      this.directionalLight2.color.setHex(0xffffff);\n      this.Renders.setClearColor(new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]().lerpColors(new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0x87ceeb), new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0x000000), this.t), 1);\n      this.light.intensity = 0.2;\n      this.directionalLight.intensity = 0;\n      this.directionalLight2.intensity = 0.2;\n    }\n\n    if (this.sky.parent === this.SceneToGet) {\n      this.sky.rotation.x += -0.0004;\n    }\n\n    this.cube.rotateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](1, 0, 0), theta);\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2dhbWVGdW5kYWxtZW50YWxzL0RheU5pZ2h0Q3ljbGUuanM/Yzc4OCJdLCJuYW1lcyI6WyJDcmVhdGVEYXlOaWdodEN5Y2xlIiwiY29uc3RydWN0b3IiLCJTY2VuZVRvR2V0IiwiUmVuZGVycyIsInN1biIsIlNwaGVyZUJ1ZmZlckdlb21ldHJ5Iiwic3VuTWF0ZXJpYWwiLCJNZXNoTGFtYmVydE1hdGVyaWFsIiwiZW1pc3NpdmUiLCJzdW5tZXNoIiwiTWVzaCIsInBvc2l0aW9uIiwic2V0IiwiYWRkIiwibW9vbiIsIm1vb25NYXRlcmlhbCIsIm1vb25NZXNoIiwiZ2VvbWV0cnkiLCJCb3hHZW9tZXRyeSIsImN1YmUiLCJ2aXNpYmxlIiwidCIsImRUSW1lIiwiZGlyZWN0aW9uYWxMaWdodCIsIkNyZWF0ZURpcmVjdGlvbmFsTGlnaHQiLCJkaXJlY3Rpb25hbExpZ2h0MiIsImxpZ2h0IiwiQ3JlYXRlQW1iaWVudExpZ2h0Iiwic2t5Qm94Iiwic2t5Qm94TWF0ZXJpYWwiLCJNZXNoQmFzaWNNYXRlcmlhbCIsIm1hcCIsImdldFJhbmRvbVN0YXJGaWVsZCIsInNpZGUiLCJCYWNrU2lkZSIsInNreSIsInVwZGF0ZSIsInRoZXRhIiwicm90YXRlQWJvdXRQb2ludCIsIlZlY3RvcjMiLCJhbmdsZSIsIk1hdGhVdGlscyIsInJhZFRvRGVnIiwicm90YXRpb24iLCJ4IiwiY29sb3IiLCJzZXRIZXgiLCJzZXRDbGVhckNvbG9yIiwiQ29sb3IiLCJsZXJwQ29sb3JzIiwiaW50ZW5zaXR5IiwicmVtb3ZlIiwicGFyZW50Iiwicm90YXRlT25BeGlzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFTyxNQUFNQSxtQkFBTixDQUEwQjtBQUM3QkMsYUFBVyxDQUFDQyxVQUFELEVBQWFDLE9BQWIsRUFBc0I7QUFFN0I7QUFDQSxTQUFLRCxVQUFMLEdBQWtCQSxVQUFsQjtBQUNBLFNBQUtDLE9BQUwsR0FBZUEsT0FBZixDQUo2QixDQU03Qjs7QUFDQSxRQUFJQyxHQUFHLEdBQUcsSUFBSUMsMERBQUosQ0FBeUIsRUFBekIsRUFBNkIsRUFBN0IsRUFBaUMsR0FBakMsRUFBc0MsR0FBdEMsQ0FBVjtBQUNBLFFBQUlDLFdBQVcsR0FBRyxJQUFJQyx5REFBSixDQUF3QjtBQUN0Q0MsY0FBUSxFQUFFO0FBRDRCLEtBQXhCLENBQWxCO0FBR0EsUUFBSUMsT0FBTyxHQUFHLElBQUlDLDBDQUFKLENBQVNOLEdBQVQsRUFBY0UsV0FBZCxDQUFkO0FBQ0FHLFdBQU8sQ0FBQ0UsUUFBUixDQUFpQkMsR0FBakIsQ0FBcUIsQ0FBckIsRUFBd0IsR0FBeEIsRUFBNkIsR0FBN0I7QUFDQVYsY0FBVSxDQUFDVyxHQUFYLENBQWVKLE9BQWYsRUFiNkIsQ0FnQjdCOztBQUNBLFFBQUlLLElBQUksR0FBRyxJQUFJVCwwREFBSixDQUF5QixFQUF6QixFQUE2QixFQUE3QixFQUFpQyxHQUFqQyxFQUFzQyxHQUF0QyxDQUFYO0FBQ0EsUUFBSVUsWUFBWSxHQUFHLElBQUlSLHlEQUFKLENBQXdCO0FBQ3ZDQyxjQUFRLEVBQUU7QUFENkIsS0FBeEIsQ0FBbkI7QUFHQSxRQUFJUSxRQUFRLEdBQUcsSUFBSU4sMENBQUosQ0FBU0ksSUFBVCxFQUFlQyxZQUFmLENBQWY7QUFDQUMsWUFBUSxDQUFDTCxRQUFULENBQWtCQyxHQUFsQixDQUFzQixDQUFDLENBQXZCLEVBQTBCLENBQUMsR0FBM0IsRUFBZ0MsQ0FBQyxHQUFqQztBQUNBVixjQUFVLENBQUNXLEdBQVgsQ0FBZUcsUUFBZixFQXZCNkIsQ0F5QjdCOztBQUNBLFFBQUlDLFFBQVEsR0FBRyxJQUFJQyxpREFBSixDQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixDQUFmO0FBQ0EsUUFBSUMsSUFBSSxHQUFHLElBQUlULDBDQUFKLENBQVNPLFFBQVQsQ0FBWDtBQUNBRSxRQUFJLENBQUNDLE9BQUwsR0FBZSxLQUFmO0FBQ0FsQixjQUFVLENBQUNXLEdBQVgsQ0FBZU0sSUFBZixFQTdCNkIsQ0E4QjdCO0FBR0E7O0FBQ0EsU0FBS0EsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS0gsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxTQUFLUCxPQUFMLEdBQWVBLE9BQWY7QUFDQSxTQUFLWSxDQUFMLEdBQVMsQ0FBVDtBQUNBLFNBQUtDLEtBQUwsR0FBYSxDQUFiLENBdEM2QixDQXdDN0I7O0FBQ0EsU0FBS0MsZ0JBQUwsR0FBd0JDLHdGQUFzQixDQUFDdEIsVUFBRCxFQUFhLFFBQWIsRUFBdUIsR0FBdkIsRUFBNEIsQ0FBQyxDQUFELEVBQUksR0FBSixFQUFTLEdBQVQsQ0FBNUIsQ0FBOUM7QUFDQSxTQUFLdUIsaUJBQUwsR0FBeUJELHdGQUFzQixDQUFDdEIsVUFBRCxFQUFhLFFBQWIsRUFBdUIsR0FBdkIsRUFBNEIsQ0FBQyxDQUFELEVBQUksQ0FBQyxHQUFMLEVBQVUsQ0FBQyxHQUFYLENBQTVCLENBQS9DO0FBQ0EsU0FBS3dCLEtBQUwsR0FBYUMsb0ZBQWtCLENBQUN6QixVQUFELEVBQWEsUUFBYixFQUF1QixHQUF2QixDQUEvQixDQTNDNkIsQ0E2QzdCOztBQUNBLFFBQUkwQixNQUFNLEdBQUcsSUFBSVYsaURBQUosQ0FBZ0IsSUFBaEIsRUFBc0IsSUFBdEIsRUFBNEIsSUFBNUIsQ0FBYjtBQUNBLFFBQUlXLGNBQWMsR0FBRyxJQUFJQyx1REFBSixDQUFzQjtBQUN2Q0MsU0FBRyxFQUFFQyxpRUFBa0IsQ0FBQyxHQUFELEVBQU0sSUFBTixFQUFZLElBQVosQ0FEZ0I7QUFFdkNDLFVBQUksRUFBRUMsOENBQVFBO0FBRnlCLEtBQXRCLENBQXJCO0FBSUEsU0FBS0MsR0FBTCxHQUFXLElBQUl6QiwwQ0FBSixDQUFTa0IsTUFBVCxFQUFpQkMsY0FBakIsQ0FBWDtBQUNIOztBQUNETyxRQUFNLEdBQUc7QUFDTDtBQUNBLFFBQUlDLEtBQUssR0FBR0MsMkVBQWdCLENBQUMsS0FBS2YsZ0JBQU4sRUFBd0IsSUFBSWdCLDZDQUFKLENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBeEIsRUFBOEMsSUFBSUEsNkNBQUosQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixDQUFsQixDQUE5QyxFQUFvRSxLQUFwRSxFQUEyRSxJQUEzRSxDQUE1QjtBQUNBLFFBQUlDLEtBQUssR0FBR0MsK0NBQVMsQ0FBQ0MsUUFBVixDQUFtQixLQUFLdkIsSUFBTCxDQUFVd0IsUUFBVixDQUFtQkMsQ0FBdEMsQ0FBWixDQUhLLENBS0w7O0FBQ0FOLCtFQUFnQixDQUFDLEtBQUs3QixPQUFOLEVBQWUsSUFBSThCLDZDQUFKLENBQVksR0FBWixFQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUFmLEVBQXVDLElBQUlBLDZDQUFKLENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBdkMsRUFBNkQsS0FBN0QsRUFBb0UsSUFBcEUsQ0FBaEI7QUFDQUQsK0VBQWdCLENBQUMsS0FBS3RCLFFBQU4sRUFBZ0IsSUFBSXVCLDZDQUFKLENBQVksR0FBWixFQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUFoQixFQUF3QyxJQUFJQSw2Q0FBSixDQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCLENBQWxCLENBQXhDLEVBQThELEtBQTlELEVBQXFFLElBQXJFLENBQWhCO0FBQ0FELCtFQUFnQixDQUFDLEtBQUtiLGlCQUFOLEVBQXlCLElBQUljLDZDQUFKLENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBekIsRUFBK0MsSUFBSUEsNkNBQUosQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixDQUFsQixDQUEvQyxFQUFxRSxLQUFyRSxFQUE0RSxJQUE1RSxDQUFoQixDQVJLLENBYUw7O0FBQ0EsUUFBSUMsS0FBSyxHQUFHLEVBQVIsSUFBYyxLQUFLbEIsS0FBTCxHQUFhLENBQS9CLEVBQWtDO0FBQzlCLFdBQUtELENBQUwsR0FBUyxDQUFUO0FBQ0EsV0FBS0UsZ0JBQUwsQ0FBc0JzQixLQUF0QixDQUE0QkMsTUFBNUIsQ0FBbUMsUUFBbkM7QUFDQSxXQUFLeEIsS0FBTCxJQUFjLEtBQWQ7O0FBQ0EsVUFBSSxLQUFLQSxLQUFMLElBQWMsQ0FBbEIsRUFBcUI7QUFDakIsYUFBS0EsS0FBTCxHQUFhLENBQWI7QUFDSDs7QUFDRCxXQUFLbkIsT0FBTCxDQUFhNEMsYUFBYixDQUEyQixJQUFJQywyQ0FBSixHQUFZQyxVQUFaLENBQXVCLElBQUlELDJDQUFKLENBQVUsUUFBVixDQUF2QixFQUE0QyxJQUFJQSwyQ0FBSixDQUFVLFFBQVYsQ0FBNUMsRUFBaUUsS0FBSzFCLEtBQXRFLENBQTNCLEVBQXlHLENBQXpHO0FBQ0EsV0FBS0ksS0FBTCxDQUFXd0IsU0FBWCxHQUF1QixHQUF2QjtBQUNBLFdBQUt6QixpQkFBTCxDQUF1Qm9CLEtBQXZCLENBQTZCQyxNQUE3QixDQUFvQyxRQUFwQztBQUNBLFdBQUt2QixnQkFBTCxDQUFzQjJCLFNBQXRCLEdBQWtDLEdBQWxDO0FBQ0EsV0FBS3pCLGlCQUFMLENBQXVCeUIsU0FBdkIsR0FBbUMsQ0FBbkM7QUFDQSxXQUFLaEQsVUFBTCxDQUFnQmlELE1BQWhCLENBQXVCLEtBQUtoQixHQUE1QjtBQUVILEtBZEQsTUFjTyxJQUFJLEVBQUVLLEtBQUssR0FBRyxFQUFWLEtBQWlCLEtBQUtMLEdBQUwsQ0FBU2lCLE1BQVQsS0FBb0IsS0FBS2xELFVBQTlDLEVBQTBEO0FBQzdEO0FBQ0EsV0FBS29CLEtBQUwsR0FBYSxDQUFiO0FBRUEsV0FBS0QsQ0FBTCxJQUFVLElBQVY7O0FBQ0EsVUFBSSxLQUFLQSxDQUFMLElBQVUsQ0FBZCxFQUFpQjtBQUNiLGFBQUtBLENBQUwsR0FBUyxDQUFUO0FBQ0EsYUFBS25CLFVBQUwsQ0FBZ0JXLEdBQWhCLENBQW9CLEtBQUtzQixHQUF6QjtBQUNIOztBQUNELFdBQUtWLGlCQUFMLENBQXVCb0IsS0FBdkIsQ0FBNkJDLE1BQTdCLENBQW9DLFFBQXBDO0FBQ0EsV0FBSzNDLE9BQUwsQ0FBYTRDLGFBQWIsQ0FBMkIsSUFBSUMsMkNBQUosR0FBWUMsVUFBWixDQUF1QixJQUFJRCwyQ0FBSixDQUFVLFFBQVYsQ0FBdkIsRUFBNEMsSUFBSUEsMkNBQUosQ0FBVSxRQUFWLENBQTVDLEVBQWlFLEtBQUszQixDQUF0RSxDQUEzQixFQUFxRyxDQUFyRztBQUNBLFdBQUtLLEtBQUwsQ0FBV3dCLFNBQVgsR0FBdUIsR0FBdkI7QUFDQSxXQUFLM0IsZ0JBQUwsQ0FBc0IyQixTQUF0QixHQUFrQyxDQUFsQztBQUNBLFdBQUt6QixpQkFBTCxDQUF1QnlCLFNBQXZCLEdBQW1DLEdBQW5DO0FBR0g7O0FBQ0QsUUFBRyxLQUFLZixHQUFMLENBQVNpQixNQUFULEtBQW9CLEtBQUtsRCxVQUE1QixFQUF1QztBQUNuQyxXQUFLaUMsR0FBTCxDQUFTUSxRQUFULENBQWtCQyxDQUFsQixJQUF1QixDQUFDLE1BQXhCO0FBQ0g7O0FBQ0QsU0FBS3pCLElBQUwsQ0FBVWtDLFlBQVYsQ0FBdUIsSUFBSWQsNkNBQUosQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixDQUFsQixDQUF2QixFQUE2Q0YsS0FBN0M7QUFFSDs7QUF4RzRCIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9nYW1lRnVuZGFsbWVudGFscy9EYXlOaWdodEN5Y2xlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gV3JpdHRlbiBCeSBIYXJ2ZXkgUmFuZGFsbCBcXFxcXG5pbXBvcnQgeyBCYWNrU2lkZSwgQm94R2VvbWV0cnksIENvbG9yLCBNYXRoVXRpbHMsIE1lc2gsIE1lc2hCYXNpY01hdGVyaWFsLCBNZXNoTGFtYmVydE1hdGVyaWFsLCBTY2VuZSwgU3BoZXJlQnVmZmVyR2VvbWV0cnksIFZlY3RvcjMgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IENyZWF0ZUFtYmllbnRMaWdodCwgQ3JlYXRlRGlyZWN0aW9uYWxMaWdodCB9IGZyb20gXCIuLi9Db3JlLUFQSS9MaWdodGluZ01hbmFnZXJcIjtcbmltcG9ydCB7IGdldFJhbmRvbVN0YXJGaWVsZCB9IGZyb20gXCIuL3N0YXJzXCI7XG5pbXBvcnQgeyByb3RhdGVBYm91dFBvaW50IH0gZnJvbSBcIi4vcm90YXRlQXJvdW5kUG9pbnRcIjtcblxuZXhwb3J0IGNsYXNzIENyZWF0ZURheU5pZ2h0Q3ljbGUge1xuICAgIGNvbnN0cnVjdG9yKFNjZW5lVG9HZXQsIFJlbmRlcnMpIHtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tIFtUd28gdG8gbGV2ZWwgZ2xvYmFsIHZhcmlhYmxlc10gLS0tLS0tLS0tLSBcXFxcXG4gICAgICAgIHRoaXMuU2NlbmVUb0dldCA9IFNjZW5lVG9HZXRcbiAgICAgICAgdGhpcy5SZW5kZXJzID0gUmVuZGVyc1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0gW0NyZWF0ZSBTdW4gTWVzaF0gLS0tLS0tLS0tLSBcXFxcXG4gICAgICAgIGxldCBzdW4gPSBuZXcgU3BoZXJlQnVmZmVyR2VvbWV0cnkoMjAsIDIwLCAxMDAsIDEwMClcbiAgICAgICAgbGV0IHN1bk1hdGVyaWFsID0gbmV3IE1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuICAgICAgICAgICAgZW1pc3NpdmU6IDB4ZjlkNzFjLFxuICAgICAgICB9KVxuICAgICAgICBsZXQgc3VubWVzaCA9IG5ldyBNZXNoKHN1biwgc3VuTWF0ZXJpYWwpXG4gICAgICAgIHN1bm1lc2gucG9zaXRpb24uc2V0KDEsIDMwMCwgMzAwKVxuICAgICAgICBTY2VuZVRvR2V0LmFkZChzdW5tZXNoKVxuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLSBbQ3JlYXRlIE1vb24gTWVzaF0gLS0tLS0tLS0tLSBcXFxcXG4gICAgICAgIGxldCBtb29uID0gbmV3IFNwaGVyZUJ1ZmZlckdlb21ldHJ5KDEwLCAxMCwgMTAwLCAxMDApXG4gICAgICAgIGxldCBtb29uTWF0ZXJpYWwgPSBuZXcgTWVzaExhbWJlcnRNYXRlcmlhbCh7XG4gICAgICAgICAgICBlbWlzc2l2ZTogMHhmZmZmZmYsXG4gICAgICAgIH0pXG4gICAgICAgIGxldCBtb29uTWVzaCA9IG5ldyBNZXNoKG1vb24sIG1vb25NYXRlcmlhbClcbiAgICAgICAgbW9vbk1lc2gucG9zaXRpb24uc2V0KC0xLCAtMjAwLCAtMzAwKVxuICAgICAgICBTY2VuZVRvR2V0LmFkZChtb29uTWVzaClcblxuICAgICAgICAvLyAtLS0tLS0tLS0tIFtDcmVhdGUgQm94IEdvbWV0cnkgZm9yIGhhbmRsaW5nIHJvdGF0aW9uXSAtLS0tLS0tLS0tIFxcXFxcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IEJveEdlb21ldHJ5KDEsIDEsIDEpO1xuICAgICAgICB2YXIgY3ViZSA9IG5ldyBNZXNoKGdlb21ldHJ5KTtcbiAgICAgICAgY3ViZS52aXNpYmxlID0gZmFsc2VcbiAgICAgICAgU2NlbmVUb0dldC5hZGQoY3ViZSk7XG4gICAgICAgIC8vIF4gVGhpcyBpcyBhIHZlcnkgYmFkIHdvcmsgYXJvdW5kIGZpeCBsYXRlclxuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLSBbQWxsIGRlZmludGlvbnMgZm9yIHRoZSBtb3ZpbmcgcGFydF0gLS0tLS0tLS0tLSBcXFxcXG4gICAgICAgIHRoaXMuY3ViZSA9IGN1YmVcbiAgICAgICAgdGhpcy5tb29uTWVzaCA9IG1vb25NZXNoXG4gICAgICAgIHRoaXMuc3VubWVzaCA9IHN1bm1lc2hcbiAgICAgICAgdGhpcy50ID0gMFxuICAgICAgICB0aGlzLmRUSW1lID0gMFxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0gW0FsbCBkZWZpbnRpb25zIGZvciBsaWdodHMgdG8gY3JlYXRlIHNoYWRvd3NdIC0tLS0tLS0tLS0gXFxcXFxuICAgICAgICB0aGlzLmRpcmVjdGlvbmFsTGlnaHQgPSBDcmVhdGVEaXJlY3Rpb25hbExpZ2h0KFNjZW5lVG9HZXQsIDB4ZGRmZmVlLCAwLjUsIFsxLCAxMDAsIDEwMF0pXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uYWxMaWdodDIgPSBDcmVhdGVEaXJlY3Rpb25hbExpZ2h0KFNjZW5lVG9HZXQsIDB4ZmZmZmZmLCAwLjIsIFsxLCAtMTAwLCAtMTAwXSlcbiAgICAgICAgdGhpcy5saWdodCA9IENyZWF0ZUFtYmllbnRMaWdodChTY2VuZVRvR2V0LCAweGFhYWFhYSwgMC41KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0gW0NyZWF0ZSBTdGFyeSBuaWdodF0gLS0tLS0tLS0tLSBcXFxcXG4gICAgICAgIGxldCBza3lCb3ggPSBuZXcgQm94R2VvbWV0cnkoMTIwMCwgMTIwMCwgMTIwMCk7XG4gICAgICAgIGxldCBza3lCb3hNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgICAgICBtYXA6IGdldFJhbmRvbVN0YXJGaWVsZCg2MDAsIDIwNDgsIDIwNDgpLFxuICAgICAgICAgICAgc2lkZTogQmFja1NpZGUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNreSA9IG5ldyBNZXNoKHNreUJveCwgc2t5Qm94TWF0ZXJpYWwpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIC8vIFRoaXMgdHdvIGxpbmVzIGFyZSAgaW1wb3J0YW50IGFzIGl0IGlzIHBhcnQgb2YgdGhlIGhhY2t5IHdvcmsgYXJvdW5kIHRvIGdldCB0aW1lIG9mIGRheSBvbiB2YXJ5aW5nIEZQU1xuICAgICAgICBsZXQgdGhldGEgPSByb3RhdGVBYm91dFBvaW50KHRoaXMuZGlyZWN0aW9uYWxMaWdodCwgbmV3IFZlY3RvcjMoMCwgMCwgMCksIG5ldyBWZWN0b3IzKDEsIDAsIDApLCAwLjAwMSwgdHJ1ZSlcbiAgICAgICAgbGV0IGFuZ2xlID0gTWF0aFV0aWxzLnJhZFRvRGVnKHRoaXMuY3ViZS5yb3RhdGlvbi54KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0gW1JvdGF0ZSBhbGwgdGhlIGxpZ2h0cyBhbmQgTWVzaGVzXSAtLS0tLS0tLS0tIFxcXFxcbiAgICAgICAgcm90YXRlQWJvdXRQb2ludCh0aGlzLnN1bm1lc2gsIG5ldyBWZWN0b3IzKDEwMCwgMCwgMCksIG5ldyBWZWN0b3IzKDEsIDAsIDApLCAwLjAwMSwgdHJ1ZSlcbiAgICAgICAgcm90YXRlQWJvdXRQb2ludCh0aGlzLm1vb25NZXNoLCBuZXcgVmVjdG9yMygxMDAsIDAsIDApLCBuZXcgVmVjdG9yMygxLCAwLCAwKSwgMC4wMDEsIHRydWUpXG4gICAgICAgIHJvdGF0ZUFib3V0UG9pbnQodGhpcy5kaXJlY3Rpb25hbExpZ2h0MiwgbmV3IFZlY3RvcjMoMCwgMCwgMCksIG5ldyBWZWN0b3IzKDEsIDAsIDApLCAwLjAwMSwgdHJ1ZSlcblxuXG4gICAgXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLSBbSWYgaXQgaXMgZGF5XSAtLS0tLS0tLS0tIFxcXFxcbiAgICAgICAgaWYgKGFuZ2xlIDwgNDAgJiYgdGhpcy5kVEltZSA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMudCA9IDBcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uYWxMaWdodC5jb2xvci5zZXRIZXgoMHhkZGZmZWUpXG4gICAgICAgICAgICB0aGlzLmRUSW1lICs9IDAuMDAzXG4gICAgICAgICAgICBpZiAodGhpcy5kVEltZSA+PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kVEltZSA9IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuUmVuZGVycy5zZXRDbGVhckNvbG9yKG5ldyBDb2xvcigpLmxlcnBDb2xvcnMobmV3IENvbG9yKDB4RkRCODEzKSwgbmV3IENvbG9yKDB4ODdjZWViKSwgdGhpcy5kVEltZSksIDEpO1xuICAgICAgICAgICAgdGhpcy5saWdodC5pbnRlbnNpdHkgPSAwLjVcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uYWxMaWdodDIuY29sb3Iuc2V0SGV4KDB4MDAwMDAwKVxuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb25hbExpZ2h0LmludGVuc2l0eSA9IDAuNVxuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb25hbExpZ2h0Mi5pbnRlbnNpdHkgPSAwXG4gICAgICAgICAgICB0aGlzLlNjZW5lVG9HZXQucmVtb3ZlKHRoaXMuc2t5KTtcblxuICAgICAgICB9IGVsc2UgaWYgKCEoYW5nbGUgPCA0MCkgJiYgdGhpcy5za3kucGFyZW50ICE9PSB0aGlzLlNjZW5lVG9HZXQpIHtcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0gW0lmIGl0IGlzIG5pZ2h0XSAtLS0tLS0tLS0tIFxcXFxcbiAgICAgICAgICAgIHRoaXMuZFRJbWUgPSAwXG5cbiAgICAgICAgICAgIHRoaXMudCArPSAwLjAxO1xuICAgICAgICAgICAgaWYgKHRoaXMudCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ID0gMVxuICAgICAgICAgICAgICAgIHRoaXMuU2NlbmVUb0dldC5hZGQodGhpcy5za3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb25hbExpZ2h0Mi5jb2xvci5zZXRIZXgoMHhmZmZmZmYpXG4gICAgICAgICAgICB0aGlzLlJlbmRlcnMuc2V0Q2xlYXJDb2xvcihuZXcgQ29sb3IoKS5sZXJwQ29sb3JzKG5ldyBDb2xvcigweDg3Y2VlYiksIG5ldyBDb2xvcigweDAwMDAwMCksIHRoaXMudCksIDEpO1xuICAgICAgICAgICAgdGhpcy5saWdodC5pbnRlbnNpdHkgPSAwLjJcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uYWxMaWdodC5pbnRlbnNpdHkgPSAwXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbmFsTGlnaHQyLmludGVuc2l0eSA9IDAuMlxuXG4gICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuc2t5LnBhcmVudCA9PT0gdGhpcy5TY2VuZVRvR2V0KXtcbiAgICAgICAgICAgIHRoaXMuc2t5LnJvdGF0aW9uLnggKz0gLTAuMDAwNFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3ViZS5yb3RhdGVPbkF4aXMobmV3IFZlY3RvcjMoMSwgMCwgMCksIHRoZXRhKVxuXG4gICAgfVxufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/gameFundalmentals/DayNightCycle.js\n");

/***/ }),

/***/ "./components/gameFundalmentals/MainSceneHandler.js":
/*!**********************************************************!*\
  !*** ./components/gameFundalmentals/MainSceneHandler.js ***!
  \**********************************************************/
/*! exports provided: GenerateMainScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GenerateMainScene\", function() { return GenerateMainScene; });\n/* harmony import */ var _Core_API_RenderingHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core-API/RenderingHandler */ \"./components/Core-API/RenderingHandler.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _clouds__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./clouds */ \"./components/gameFundalmentals/clouds.js\");\n/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./controls */ \"./components/gameFundalmentals/controls.js\");\n/* harmony import */ var _DayNightCycle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DayNightCycle */ \"./components/gameFundalmentals/DayNightCycle.js\");\n/* harmony import */ var _ProceduleTerrain__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ProceduleTerrain */ \"./components/gameFundalmentals/ProceduleTerrain.js\");\n// Written By Harvey Randall \\\\\n// Render Handler\n\n\n\n\n\n\nlet debug = true;\nfunction GenerateMainScene(SceneToGet, Renders, document, seed, child2, Camera) {\n  let clouds = [];\n\n  for (let i = 0; i < 40; i++) {\n    clouds.push(new _clouds__WEBPACK_IMPORTED_MODULE_2__[\"GenerateClouds\"](new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](Math.random() * 300 - 300, 80 + Math.random() * 20, Math.random() * 600 - 400), SceneToGet, Math.random() * 0.2, Math.random() * 6 + 1));\n  }\n\n  let daynight = new _DayNightCycle__WEBPACK_IMPORTED_MODULE_4__[\"CreateDayNightCycle\"](SceneToGet, Renders);\n  Object(_ProceduleTerrain__WEBPACK_IMPORTED_MODULE_5__[\"GenerateTerrain\"])(seed, SceneToGet);\n  Object(_controls__WEBPACK_IMPORTED_MODULE_3__[\"ControlHandlerInit\"])(document, child2);\n\n  if (debug) {\n    const planeGeometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"PlaneGeometry\"](20, 20, 32, 32);\n    planeGeometry.rotateX(Math.PI / 2);\n    const planeMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"MeshStandardMaterial\"]({\n      color: 0x567d46,\n      side: three__WEBPACK_IMPORTED_MODULE_1__[\"DoubleSide\"]\n    });\n    const plane = new three__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](planeGeometry, planeMaterial);\n    plane.position.y = -0.5;\n    SceneToGet.add(plane);\n    const gridHelper = new three__WEBPACK_IMPORTED_MODULE_1__[\"GridHelper\"](50, 50);\n    gridHelper.position.y = -1;\n    SceneToGet.add(gridHelper);\n  } // Add all updating parts to a function\n\n\n  Object(_Core_API_RenderingHandler__WEBPACK_IMPORTED_MODULE_0__[\"addToRenderSequence\"])(\"Main\", () => {\n    clouds.forEach((e, i) => {\n      e.update();\n    });\n  }, true);\n  Object(_Core_API_RenderingHandler__WEBPACK_IMPORTED_MODULE_0__[\"addToRenderSequence\"])(\"Main\", () => Object(_controls__WEBPACK_IMPORTED_MODULE_3__[\"ControlHandlerUpdate\"])(Camera));\n  Object(_Core_API_RenderingHandler__WEBPACK_IMPORTED_MODULE_0__[\"addToRenderSequence\"])(\"Main\", () => daynight.update());\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2dhbWVGdW5kYWxtZW50YWxzL01haW5TY2VuZUhhbmRsZXIuanM/MDEyYiJdLCJuYW1lcyI6WyJkZWJ1ZyIsIkdlbmVyYXRlTWFpblNjZW5lIiwiU2NlbmVUb0dldCIsIlJlbmRlcnMiLCJkb2N1bWVudCIsInNlZWQiLCJjaGlsZDIiLCJDYW1lcmEiLCJjbG91ZHMiLCJpIiwicHVzaCIsIkdlbmVyYXRlQ2xvdWRzIiwiVmVjdG9yMyIsIk1hdGgiLCJyYW5kb20iLCJkYXluaWdodCIsIkNyZWF0ZURheU5pZ2h0Q3ljbGUiLCJHZW5lcmF0ZVRlcnJhaW4iLCJDb250cm9sSGFuZGxlckluaXQiLCJwbGFuZUdlb21ldHJ5IiwiUGxhbmVHZW9tZXRyeSIsInJvdGF0ZVgiLCJQSSIsInBsYW5lTWF0ZXJpYWwiLCJNZXNoU3RhbmRhcmRNYXRlcmlhbCIsImNvbG9yIiwic2lkZSIsIkRvdWJsZVNpZGUiLCJwbGFuZSIsIk1lc2giLCJwb3NpdGlvbiIsInkiLCJhZGQiLCJncmlkSGVscGVyIiwiR3JpZEhlbHBlciIsImFkZFRvUmVuZGVyU2VxdWVuY2UiLCJmb3JFYWNoIiwiZSIsInVwZGF0ZSIsIkNvbnRyb2xIYW5kbGVyVXBkYXRlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBSUEsS0FBSyxHQUFHLElBQVo7QUFFTyxTQUFTQyxpQkFBVCxDQUEyQkMsVUFBM0IsRUFBdUNDLE9BQXZDLEVBQWdEQyxRQUFoRCxFQUEwREMsSUFBMUQsRUFBZ0VDLE1BQWhFLEVBQXdFQyxNQUF4RSxFQUErRTtBQUVsRixNQUFJQyxNQUFNLEdBQUcsRUFBYjs7QUFDQSxPQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsRUFBcEIsRUFBd0JBLENBQUMsRUFBekIsRUFBNkI7QUFDekJELFVBQU0sQ0FBQ0UsSUFBUCxDQUFZLElBQUlDLHNEQUFKLENBQW1CLElBQUlDLDZDQUFKLENBQWFDLElBQUksQ0FBQ0MsTUFBTCxLQUFnQixHQUFqQixHQUF3QixHQUFwQyxFQUF5QyxLQUFLRCxJQUFJLENBQUNDLE1BQUwsS0FBZ0IsRUFBOUQsRUFBbUVELElBQUksQ0FBQ0MsTUFBTCxLQUFnQixHQUFqQixHQUF3QixHQUExRixDQUFuQixFQUFtSFosVUFBbkgsRUFBK0hXLElBQUksQ0FBQ0MsTUFBTCxLQUFnQixHQUEvSSxFQUFvSkQsSUFBSSxDQUFDQyxNQUFMLEtBQWdCLENBQWhCLEdBQW9CLENBQXhLLENBQVo7QUFDSDs7QUFFRCxNQUFJQyxRQUFRLEdBQUcsSUFBSUMsa0VBQUosQ0FBd0JkLFVBQXhCLEVBQW9DQyxPQUFwQyxDQUFmO0FBQ0FjLDJFQUFlLENBQUNaLElBQUQsRUFBT0gsVUFBUCxDQUFmO0FBQ0FnQixzRUFBa0IsQ0FBQ2QsUUFBRCxFQUFXRSxNQUFYLENBQWxCOztBQUVBLE1BQUdOLEtBQUgsRUFBUztBQUNMLFVBQU1tQixhQUFhLEdBQUcsSUFBSUMsbURBQUosQ0FBa0IsRUFBbEIsRUFBc0IsRUFBdEIsRUFBMEIsRUFBMUIsRUFBOEIsRUFBOUIsQ0FBdEI7QUFDQUQsaUJBQWEsQ0FBQ0UsT0FBZCxDQUFzQlIsSUFBSSxDQUFDUyxFQUFMLEdBQVUsQ0FBaEM7QUFDQSxVQUFNQyxhQUFhLEdBQUcsSUFBSUMsMERBQUosQ0FBeUI7QUFBRUMsV0FBSyxFQUFFLFFBQVQ7QUFBbUJDLFVBQUksRUFBRUMsZ0RBQVVBO0FBQW5DLEtBQXpCLENBQXRCO0FBQ0EsVUFBTUMsS0FBSyxHQUFHLElBQUlDLDBDQUFKLENBQVNWLGFBQVQsRUFBd0JJLGFBQXhCLENBQWQ7QUFDQUssU0FBSyxDQUFDRSxRQUFOLENBQWVDLENBQWYsR0FBbUIsQ0FBQyxHQUFwQjtBQUNBN0IsY0FBVSxDQUFDOEIsR0FBWCxDQUFlSixLQUFmO0FBQ0EsVUFBTUssVUFBVSxHQUFHLElBQUlDLGdEQUFKLENBQWUsRUFBZixFQUFtQixFQUFuQixDQUFuQjtBQUNBRCxjQUFVLENBQUNILFFBQVgsQ0FBb0JDLENBQXBCLEdBQXdCLENBQUMsQ0FBekI7QUFDQTdCLGNBQVUsQ0FBQzhCLEdBQVgsQ0FBZUMsVUFBZjtBQUNILEdBckJpRixDQXVCbEY7OztBQUNBRSx3RkFBbUIsQ0FBQyxNQUFELEVBQVMsTUFBTTtBQUM5QjNCLFVBQU0sQ0FBQzRCLE9BQVAsQ0FBZSxDQUFDQyxDQUFELEVBQUk1QixDQUFKLEtBQVU7QUFDckI0QixPQUFDLENBQUNDLE1BQUY7QUFDSCxLQUZEO0FBR0gsR0FKa0IsRUFJaEIsSUFKZ0IsQ0FBbkI7QUFNQUgsd0ZBQW1CLENBQUMsTUFBRCxFQUFTLE1BQU1JLHNFQUFvQixDQUFDaEMsTUFBRCxDQUFuQyxDQUFuQjtBQUNBNEIsd0ZBQW1CLENBQUMsTUFBRCxFQUFTLE1BQU9wQixRQUFRLENBQUN1QixNQUFULEVBQWhCLENBQW5CO0FBRUgiLCJmaWxlIjoiLi9jb21wb25lbnRzL2dhbWVGdW5kYWxtZW50YWxzL01haW5TY2VuZUhhbmRsZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIEJ5IEhhcnZleSBSYW5kYWxsIFxcXFxcblxuLy8gUmVuZGVyIEhhbmRsZXJcbmltcG9ydCB7IGFkZFRvUmVuZGVyU2VxdWVuY2UgfSBmcm9tIFwiLi4vQ29yZS1BUEkvUmVuZGVyaW5nSGFuZGxlclwiXG5cbmltcG9ydCB7IERvdWJsZVNpZGUsIEdyaWRIZWxwZXIsIE1lc2gsIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBQbGFuZUdlb21ldHJ5LCBWZWN0b3IzIH0gZnJvbSBcInRocmVlXCJcbmltcG9ydCB7IEdlbmVyYXRlQ2xvdWRzIH0gZnJvbSBcIi4vY2xvdWRzXCJcbmltcG9ydCB7IENvbnRyb2xIYW5kbGVySW5pdCwgQ29udHJvbEhhbmRsZXJVcGRhdGUgfSBmcm9tIFwiLi9jb250cm9sc1wiXG5pbXBvcnQgeyBDcmVhdGVEYXlOaWdodEN5Y2xlIH0gZnJvbSBcIi4vRGF5TmlnaHRDeWNsZVwiXG5pbXBvcnQgeyBHZW5lcmF0ZVRlcnJhaW4gfSBmcm9tIFwiLi9Qcm9jZWR1bGVUZXJyYWluXCJcblxubGV0IGRlYnVnID0gdHJ1ZVxuXG5leHBvcnQgZnVuY3Rpb24gR2VuZXJhdGVNYWluU2NlbmUoU2NlbmVUb0dldCwgUmVuZGVycywgZG9jdW1lbnQsIHNlZWQsIGNoaWxkMiwgQ2FtZXJhKXtcblxuICAgIGxldCBjbG91ZHMgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkrKykge1xuICAgICAgICBjbG91ZHMucHVzaChuZXcgR2VuZXJhdGVDbG91ZHMobmV3IFZlY3RvcjMoKE1hdGgucmFuZG9tKCkgKiAzMDApIC0gMzAwLCA4MCArIE1hdGgucmFuZG9tKCkgKiAyMCwgKE1hdGgucmFuZG9tKCkgKiA2MDApIC0gNDAwKSwgU2NlbmVUb0dldCwgTWF0aC5yYW5kb20oKSAqIDAuMiwgTWF0aC5yYW5kb20oKSAqIDYgKyAxKSlcbiAgICB9XG5cbiAgICBsZXQgZGF5bmlnaHQgPSBuZXcgQ3JlYXRlRGF5TmlnaHRDeWNsZShTY2VuZVRvR2V0LCBSZW5kZXJzKVxuICAgIEdlbmVyYXRlVGVycmFpbihzZWVkLCBTY2VuZVRvR2V0KVxuICAgIENvbnRyb2xIYW5kbGVySW5pdChkb2N1bWVudCwgY2hpbGQyKVxuXG4gICAgaWYoZGVidWcpe1xuICAgICAgICBjb25zdCBwbGFuZUdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkoMjAsIDIwLCAzMiwgMzIpO1xuICAgICAgICBwbGFuZUdlb21ldHJ5LnJvdGF0ZVgoTWF0aC5QSSAvIDIpXG4gICAgICAgIGNvbnN0IHBsYW5lTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoeyBjb2xvcjogMHg1NjdkNDYsIHNpZGU6IERvdWJsZVNpZGUgfSlcbiAgICAgICAgY29uc3QgcGxhbmUgPSBuZXcgTWVzaChwbGFuZUdlb21ldHJ5LCBwbGFuZU1hdGVyaWFsKTtcbiAgICAgICAgcGxhbmUucG9zaXRpb24ueSA9IC0wLjVcbiAgICAgICAgU2NlbmVUb0dldC5hZGQocGxhbmUpO1xuICAgICAgICBjb25zdCBncmlkSGVscGVyID0gbmV3IEdyaWRIZWxwZXIoNTAsIDUwKTtcbiAgICAgICAgZ3JpZEhlbHBlci5wb3NpdGlvbi55ID0gLTE7XG4gICAgICAgIFNjZW5lVG9HZXQuYWRkKGdyaWRIZWxwZXIpO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgdXBkYXRpbmcgcGFydHMgdG8gYSBmdW5jdGlvblxuICAgIGFkZFRvUmVuZGVyU2VxdWVuY2UoXCJNYWluXCIsICgpID0+IHtcbiAgICAgICAgY2xvdWRzLmZvckVhY2goKGUsIGkpID0+IHtcbiAgICAgICAgICAgIGUudXBkYXRlKClcbiAgICAgICAgfSlcbiAgICB9LCB0cnVlKVxuXG4gICAgYWRkVG9SZW5kZXJTZXF1ZW5jZShcIk1haW5cIiwgKCkgPT4gQ29udHJvbEhhbmRsZXJVcGRhdGUoQ2FtZXJhKSlcbiAgICBhZGRUb1JlbmRlclNlcXVlbmNlKFwiTWFpblwiLCAoKSA9PiAgZGF5bmlnaHQudXBkYXRlKCkpXG5cbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/gameFundalmentals/MainSceneHandler.js\n");

/***/ }),

/***/ "./components/gameFundalmentals/ProceduleTerrain.js":
/*!**********************************************************!*\
  !*** ./components/gameFundalmentals/ProceduleTerrain.js ***!
  \**********************************************************/
/*! exports provided: GenerateTerrain */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GenerateTerrain\", function() { return GenerateTerrain; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n// Written By Harvey Randall \\\\\n\n\nvar SimplexNoise = __webpack_require__(/*! simplex-noise */ \"simplex-noise\");\n\nfunction GenerateTerrain(seed, SceneToGet) {\n  //------------[MAIN FUNCTION VARIABLES]------------\\\\\n  const simplex = new SimplexNoise(seed);\n  let geometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"PlaneBufferGeometry\"](500, 500, 100, 100);\n  let colours = []; //------------[Edit the Geomtry Accordingly]------------\\\\\n\n  for (var i = 0, l = geometry.attributes.position.count; i < l; i++) {\n    // Get Data position\n    let x = geometry.attributes.position.array[i * 3] / 128;\n    let y = geometry.attributes.position.array[i * 3 + 1] / 128; // Check Height from Perlin Noise Generator\n\n    let height = simplex.noise2D(x, y) * 30; // Set the height accordingly\n\n    geometry.attributes.position.array[i * 3 + 2] = height; // Update Vertice colours accordinly\n\n    if (height > 23) {\n      colours.push(1, 1, 1);\n    } else if (height > 5) {\n      colours.push(0.56, 0.54, 0.48);\n    } else if (height < -20) {\n      colours.push(0.501, 0.772, 0.87);\n    } else {\n      colours.push(0.56, 0.68, 0.166);\n    }\n  } //------------[Create Material]------------\\\\\n\n\n  var material = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshPhongMaterial\"]({\n    vertexColors: colours,\n    reflectivity: 0,\n    roughness: 2,\n    flatShading: true\n  }); //------------[Create MEsh]------------\\\\\n\n  var plane2 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](geometry, material);\n  plane2.receiveShadow = true;\n  plane2.castShadow = true;\n  plane2.position.y = -3;\n  plane2.rotateX(Math.PI / 2 + Math.PI); //------------[Edit colour attribute]------------\\\\\n\n  geometry.setAttribute('color', new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferAttribute\"](new Float32Array(colours), 3));\n  geometry.computeVertexNormals(); //------------[Add to Base Scene]------------\\\\\n\n  SceneToGet.add(plane2);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2dhbWVGdW5kYWxtZW50YWxzL1Byb2NlZHVsZVRlcnJhaW4uanM/NTU3YiJdLCJuYW1lcyI6WyJTaW1wbGV4Tm9pc2UiLCJyZXF1aXJlIiwiR2VuZXJhdGVUZXJyYWluIiwic2VlZCIsIlNjZW5lVG9HZXQiLCJzaW1wbGV4IiwiZ2VvbWV0cnkiLCJQbGFuZUJ1ZmZlckdlb21ldHJ5IiwiY29sb3VycyIsImkiLCJsIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiY291bnQiLCJ4IiwiYXJyYXkiLCJ5IiwiaGVpZ2h0Iiwibm9pc2UyRCIsInB1c2giLCJtYXRlcmlhbCIsIk1lc2hQaG9uZ01hdGVyaWFsIiwidmVydGV4Q29sb3JzIiwicmVmbGVjdGl2aXR5Iiwicm91Z2huZXNzIiwiZmxhdFNoYWRpbmciLCJwbGFuZTIiLCJNZXNoIiwicmVjZWl2ZVNoYWRvdyIsImNhc3RTaGFkb3ciLCJyb3RhdGVYIiwiTWF0aCIsIlBJIiwic2V0QXR0cmlidXRlIiwiQnVmZmVyQXR0cmlidXRlIiwiRmxvYXQzMkFycmF5IiwiY29tcHV0ZVZlcnRleE5vcm1hbHMiLCJhZGQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7QUFDQSxJQUFJQSxZQUFZLEdBQUdDLG1CQUFPLENBQUMsb0NBQUQsQ0FBMUI7O0FBRU8sU0FBU0MsZUFBVCxDQUF5QkMsSUFBekIsRUFBK0JDLFVBQS9CLEVBQTJDO0FBRTlDO0FBQ0EsUUFBTUMsT0FBTyxHQUFHLElBQUlMLFlBQUosQ0FBaUJHLElBQWpCLENBQWhCO0FBQ0EsTUFBSUcsUUFBUSxHQUFHLElBQUlDLHlEQUFKLENBQXdCLEdBQXhCLEVBQTZCLEdBQTdCLEVBQWtDLEdBQWxDLEVBQXVDLEdBQXZDLENBQWY7QUFDQSxNQUFJQyxPQUFPLEdBQUcsRUFBZCxDQUw4QyxDQU85Qzs7QUFDQSxPQUFLLElBQUlDLENBQUMsR0FBRyxDQUFSLEVBQVdDLENBQUMsR0FBR0osUUFBUSxDQUFDSyxVQUFULENBQW9CQyxRQUFwQixDQUE2QkMsS0FBakQsRUFBd0RKLENBQUMsR0FBR0MsQ0FBNUQsRUFBK0RELENBQUMsRUFBaEUsRUFBb0U7QUFDaEU7QUFDQSxRQUFJSyxDQUFDLEdBQUdSLFFBQVEsQ0FBQ0ssVUFBVCxDQUFvQkMsUUFBcEIsQ0FBNkJHLEtBQTdCLENBQW9DTixDQUFDLEdBQUcsQ0FBeEMsSUFBOEMsR0FBdEQ7QUFDQSxRQUFJTyxDQUFDLEdBQUdWLFFBQVEsQ0FBQ0ssVUFBVCxDQUFvQkMsUUFBcEIsQ0FBNkJHLEtBQTdCLENBQW9DTixDQUFDLEdBQUcsQ0FBTCxHQUFVLENBQTdDLElBQWtELEdBQTFELENBSGdFLENBS2hFOztBQUNBLFFBQUlRLE1BQU0sR0FBR1osT0FBTyxDQUFDYSxPQUFSLENBQWdCSixDQUFoQixFQUFtQkUsQ0FBbkIsSUFBd0IsRUFBckMsQ0FOZ0UsQ0FPaEU7O0FBQ0FWLFlBQVEsQ0FBQ0ssVUFBVCxDQUFvQkMsUUFBcEIsQ0FBNkJHLEtBQTdCLENBQW9DTixDQUFDLEdBQUcsQ0FBTCxHQUFVLENBQTdDLElBQWtEUSxNQUFsRCxDQVJnRSxDQVVoRTs7QUFDQSxRQUFJQSxNQUFNLEdBQUcsRUFBYixFQUFpQjtBQUNiVCxhQUFPLENBQUNXLElBQVIsQ0FBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CO0FBQ0gsS0FGRCxNQUdLLElBQUlGLE1BQU0sR0FBRyxDQUFiLEVBQWdCO0FBQ2pCVCxhQUFPLENBQUNXLElBQVIsQ0FBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCO0FBQ0gsS0FGSSxNQUdBLElBQUlGLE1BQU0sR0FBRyxDQUFDLEVBQWQsRUFBa0I7QUFDbkJULGFBQU8sQ0FBQ1csSUFBUixDQUFhLEtBQWIsRUFBb0IsS0FBcEIsRUFBMkIsSUFBM0I7QUFDSCxLQUZJLE1BR0E7QUFDRFgsYUFBTyxDQUFDVyxJQUFSLENBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixLQUF6QjtBQUNIO0FBQ0osR0EvQjZDLENBaUM5Qzs7O0FBQ0EsTUFBSUMsUUFBUSxHQUFHLElBQUlDLHVEQUFKLENBQXNCO0FBQ2pDQyxnQkFBWSxFQUFFZCxPQURtQjtBQUVqQ2UsZ0JBQVksRUFBRSxDQUZtQjtBQUdqQ0MsYUFBUyxFQUFFLENBSHNCO0FBSWpDQyxlQUFXLEVBQUU7QUFKb0IsR0FBdEIsQ0FBZixDQWxDOEMsQ0F5QzlDOztBQUNBLE1BQUlDLE1BQU0sR0FBRyxJQUFJQywwQ0FBSixDQUFTckIsUUFBVCxFQUFtQmMsUUFBbkIsQ0FBYjtBQUNBTSxRQUFNLENBQUNFLGFBQVAsR0FBdUIsSUFBdkI7QUFDQUYsUUFBTSxDQUFDRyxVQUFQLEdBQW9CLElBQXBCO0FBQ0FILFFBQU0sQ0FBQ2QsUUFBUCxDQUFnQkksQ0FBaEIsR0FBb0IsQ0FBQyxDQUFyQjtBQUNBVSxRQUFNLENBQUNJLE9BQVAsQ0FBZ0JDLElBQUksQ0FBQ0MsRUFBTCxHQUFVLENBQVgsR0FBZ0JELElBQUksQ0FBQ0MsRUFBcEMsRUE5QzhDLENBZ0Q5Qzs7QUFDQTFCLFVBQVEsQ0FBQzJCLFlBQVQsQ0FBc0IsT0FBdEIsRUFBK0IsSUFBSUMscURBQUosQ0FBb0IsSUFBSUMsWUFBSixDQUFpQjNCLE9BQWpCLENBQXBCLEVBQStDLENBQS9DLENBQS9CO0FBQ0FGLFVBQVEsQ0FBQzhCLG9CQUFULEdBbEQ4QyxDQXFEOUM7O0FBQ0FoQyxZQUFVLENBQUNpQyxHQUFYLENBQWVYLE1BQWY7QUFDSCIsImZpbGUiOiIuL2NvbXBvbmVudHMvZ2FtZUZ1bmRhbG1lbnRhbHMvUHJvY2VkdWxlVGVycmFpbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFdyaXR0ZW4gQnkgSGFydmV5IFJhbmRhbGwgXFxcXFxuXG5pbXBvcnQgeyBCdWZmZXJBdHRyaWJ1dGUsIE1lc2gsIE1lc2hQaG9uZ01hdGVyaWFsLCBQbGFuZUJ1ZmZlckdlb21ldHJ5LCB9IGZyb20gXCJ0aHJlZVwiXG52YXIgU2ltcGxleE5vaXNlID0gcmVxdWlyZSgnc2ltcGxleC1ub2lzZScpO1xuXG5leHBvcnQgZnVuY3Rpb24gR2VuZXJhdGVUZXJyYWluKHNlZWQsIFNjZW5lVG9HZXQpIHtcblxuICAgIC8vLS0tLS0tLS0tLS0tW01BSU4gRlVOQ1RJT04gVkFSSUFCTEVTXS0tLS0tLS0tLS0tLVxcXFxcbiAgICBjb25zdCBzaW1wbGV4ID0gbmV3IFNpbXBsZXhOb2lzZShzZWVkKVxuICAgIGxldCBnZW9tZXRyeSA9IG5ldyBQbGFuZUJ1ZmZlckdlb21ldHJ5KDUwMCwgNTAwLCAxMDAsIDEwMClcbiAgICBsZXQgY29sb3VycyA9IFtdXG5cbiAgICAvLy0tLS0tLS0tLS0tLVtFZGl0IHRoZSBHZW9tdHJ5IEFjY29yZGluZ2x5XS0tLS0tLS0tLS0tLVxcXFxcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgLy8gR2V0IERhdGEgcG9zaXRpb25cbiAgICAgICAgbGV0IHggPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5WyhpICogMyldIC8gMTI4XG4gICAgICAgIGxldCB5ID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVsoaSAqIDMpICsgMV0gLyAxMjhcblxuICAgICAgICAvLyBDaGVjayBIZWlnaHQgZnJvbSBQZXJsaW4gTm9pc2UgR2VuZXJhdG9yXG4gICAgICAgIGxldCBoZWlnaHQgPSBzaW1wbGV4Lm5vaXNlMkQoeCwgeSkgKiAzMFxuICAgICAgICAvLyBTZXQgdGhlIGhlaWdodCBhY2NvcmRpbmdseVxuICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5WyhpICogMykgKyAyXSA9IGhlaWdodFxuXG4gICAgICAgIC8vIFVwZGF0ZSBWZXJ0aWNlIGNvbG91cnMgYWNjb3JkaW5seVxuICAgICAgICBpZiAoaGVpZ2h0ID4gMjMpIHtcbiAgICAgICAgICAgIGNvbG91cnMucHVzaCgxLCAxLCAxKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhlaWdodCA+IDUpIHtcbiAgICAgICAgICAgIGNvbG91cnMucHVzaCgwLjU2LCAwLjU0LCAwLjQ4KVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhlaWdodCA8IC0yMCkge1xuICAgICAgICAgICAgY29sb3Vycy5wdXNoKDAuNTAxLCAwLjc3MiwgMC44NylcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbG91cnMucHVzaCgwLjU2LCAwLjY4LCAwLjE2NilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tW0NyZWF0ZSBNYXRlcmlhbF0tLS0tLS0tLS0tLS1cXFxcXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IE1lc2hQaG9uZ01hdGVyaWFsKHtcbiAgICAgICAgdmVydGV4Q29sb3JzOiBjb2xvdXJzLFxuICAgICAgICByZWZsZWN0aXZpdHk6IDAsXG4gICAgICAgIHJvdWdobmVzczogMixcbiAgICAgICAgZmxhdFNoYWRpbmc6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvLy0tLS0tLS0tLS0tLVtDcmVhdGUgTUVzaF0tLS0tLS0tLS0tLS1cXFxcXG4gICAgdmFyIHBsYW5lMiA9IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgcGxhbmUyLnJlY2VpdmVTaGFkb3cgPSB0cnVlXG4gICAgcGxhbmUyLmNhc3RTaGFkb3cgPSB0cnVlXG4gICAgcGxhbmUyLnBvc2l0aW9uLnkgPSAtM1xuICAgIHBsYW5lMi5yb3RhdGVYKChNYXRoLlBJIC8gMikgKyBNYXRoLlBJKVxuXG4gICAgLy8tLS0tLS0tLS0tLS1bRWRpdCBjb2xvdXIgYXR0cmlidXRlXS0tLS0tLS0tLS0tLVxcXFxcbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGNvbG91cnMpLCAzKSk7XG4gICAgZ2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcbiAgICBcbiAgICBcbiAgICAvLy0tLS0tLS0tLS0tLVtBZGQgdG8gQmFzZSBTY2VuZV0tLS0tLS0tLS0tLS1cXFxcXG4gICAgU2NlbmVUb0dldC5hZGQocGxhbmUyKTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/gameFundalmentals/ProceduleTerrain.js\n");

/***/ }),

/***/ "./components/gameFundalmentals/clouds.js":
/*!************************************************!*\
  !*** ./components/gameFundalmentals/clouds.js ***!
  \************************************************/
/*! exports provided: GenerateClouds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GenerateClouds\", function() { return GenerateClouds; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n// Written By Harvey Randall \\\\\n // Randomly delplace cloud verticies\n\nconst map = (val, smin, smax, emin, emax) => (emax - emin) * (val - smin) / (smax - smin) + emin;\n\nconst jitter = (geometry, per) => {\n  for (var i = 0, l = geometry.attributes.position.count; i < l; i++) {\n    geometry.attributes.position.array[i * 3] += map(Math.random(), 0, 1, -per, per);\n    geometry.attributes.position.array[i * 3 + 1] += map(Math.random(), 0, 1, -per, per);\n    geometry.attributes.position.array[i * 3 + 2] += map(Math.random(), 0, 1, -per, per);\n  }\n\n  ;\n};\n\nclass GenerateClouds {\n  constructor(pos, scene, speed, scale) {\n    const group = new three__WEBPACK_IMPORTED_MODULE_0__[\"Group\"]();\n    const tuft1 = new three__WEBPACK_IMPORTED_MODULE_0__[\"SphereGeometry\"](1.5 * scale, 7, 11);\n    tuft1.translate(-2 * scale, 0, 0);\n    const tuft3 = new three__WEBPACK_IMPORTED_MODULE_0__[\"SphereGeometry\"](1.5 * scale, 7, 11);\n    tuft3.translate(2 * scale, 0, 0);\n    const tuft2 = new three__WEBPACK_IMPORTED_MODULE_0__[\"SphereGeometry\"](2.0 * scale, 7, 11);\n    tuft2.translate(0, 0, 0);\n    jitter(tuft1, 0.2);\n    jitter(tuft2, 0.1);\n    jitter(tuft3, 0.1);\n    tuft1.computeVertexNormals();\n    const mat = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshPhongMaterial\"]({\n      color: 'white',\n      flatShading: true,\n      side: three__WEBPACK_IMPORTED_MODULE_0__[\"DoubleSide\"]\n    });\n    let cloud = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](tuft1, mat);\n    let cloud1 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](tuft2, mat);\n    let cloud2 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](tuft3, mat);\n    group.add(cloud);\n    group.add(cloud1);\n    group.add(cloud2);\n    scene.add(group);\n    group.castShadow = true;\n    group.receiveShadow = true;\n    group.position.x = pos.x;\n    group.position.y = pos.y;\n    group.position.z = pos.z;\n    this.grass = group;\n    this.speed = speed;\n    this.pos = pos;\n  }\n\n  update() {\n    let geos = this.grass;\n    geos.position.x += this.speed;\n\n    if (geos.position.x > 400) {\n      geos.position.x = this.pos.x;\n    }\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2dhbWVGdW5kYWxtZW50YWxzL2Nsb3Vkcy5qcz9iMWVjIl0sIm5hbWVzIjpbIm1hcCIsInZhbCIsInNtaW4iLCJzbWF4IiwiZW1pbiIsImVtYXgiLCJqaXR0ZXIiLCJnZW9tZXRyeSIsInBlciIsImkiLCJsIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiY291bnQiLCJhcnJheSIsIk1hdGgiLCJyYW5kb20iLCJHZW5lcmF0ZUNsb3VkcyIsImNvbnN0cnVjdG9yIiwicG9zIiwic2NlbmUiLCJzcGVlZCIsInNjYWxlIiwiZ3JvdXAiLCJHcm91cCIsInR1ZnQxIiwiU3BoZXJlR2VvbWV0cnkiLCJ0cmFuc2xhdGUiLCJ0dWZ0MyIsInR1ZnQyIiwiY29tcHV0ZVZlcnRleE5vcm1hbHMiLCJtYXQiLCJNZXNoUGhvbmdNYXRlcmlhbCIsImNvbG9yIiwiZmxhdFNoYWRpbmciLCJzaWRlIiwiRG91YmxlU2lkZSIsImNsb3VkIiwiTWVzaCIsImNsb3VkMSIsImNsb3VkMiIsImFkZCIsImNhc3RTaGFkb3ciLCJyZWNlaXZlU2hhZG93IiwieCIsInkiLCJ6IiwiZ3Jhc3MiLCJ1cGRhdGUiLCJnZW9zIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0NBSUE7O0FBQ0EsTUFBTUEsR0FBRyxHQUFHLENBQUNDLEdBQUQsRUFBTUMsSUFBTixFQUFZQyxJQUFaLEVBQWtCQyxJQUFsQixFQUF3QkMsSUFBeEIsS0FBaUMsQ0FBQ0EsSUFBSSxHQUFHRCxJQUFSLEtBQWlCSCxHQUFHLEdBQUdDLElBQXZCLEtBQWdDQyxJQUFJLEdBQUdELElBQXZDLElBQStDRSxJQUE1Rjs7QUFDQSxNQUFNRSxNQUFNLEdBQUcsQ0FBQ0MsUUFBRCxFQUFXQyxHQUFYLEtBQW1CO0FBQzlCLE9BQUssSUFBSUMsQ0FBQyxHQUFHLENBQVIsRUFBV0MsQ0FBQyxHQUFHSCxRQUFRLENBQUNJLFVBQVQsQ0FBb0JDLFFBQXBCLENBQTZCQyxLQUFq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Q0FBQ29CLGFBQU4sR0FBc0IsSUFBdEI7QUFDQXBCLFNBQUssQ0FBQ1gsUUFBTixDQUFlZ0MsQ0FBZixHQUFtQnpCLEdBQUcsQ0FBQ3lCLENBQXZCO0FBQ0FyQixTQUFLLENBQUNYLFFBQU4sQ0FBZWlDLENBQWYsR0FBbUIxQixHQUFHLENBQUMwQixDQUF2QjtBQUNBdEIsU0FBSyxDQUFDWCxRQUFOLENBQWVrQyxDQUFmLEdBQW1CM0IsR0FBRyxDQUFDMkIsQ0FBdkI7QUFFQSxTQUFLQyxLQUFMLEdBQWF4QixLQUFiO0FBQ0EsU0FBS0YsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBS0YsR0FBTCxHQUFXQSxHQUFYO0FBQ0g7O0FBRUQ2QixRQUFNLEdBQUc7QUFDTCxRQUFJQyxJQUFJLEdBQUcsS0FBS0YsS0FBaEI7QUFDQUUsUUFBSSxDQUFDckMsUUFBTCxDQUFjZ0MsQ0FBZCxJQUFtQixLQUFLdkIsS0FBeEI7O0FBQ0EsUUFBSTRCLElBQUksQ0FBQ3JDLFFBQUwsQ0FBY2dDLENBQWQsR0FBa0IsR0FBdEIsRUFBMkI7QUFDdkJLLFVBQUksQ0FBQ3JDLFFBQUwsQ0FBY2dDLENBQWQsR0FBa0IsS0FBS3pCLEdBQUwsQ0FBU3lCLENBQTNCO0FBQ0g7QUFDSjs7QUFoRXVCIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9nYW1lRnVuZGFsbWVudGFscy9jbG91ZHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIEJ5IEhhcnZleSBSYW5kYWxsIFxcXFxcblxuaW1wb3J0IHsgRG91YmxlU2lkZSwgR3JvdXAsIE1lc2gsIE1lc2hQaG9uZ01hdGVyaWFsLCBTcGhlcmVHZW9tZXRyeSB9IGZyb20gJ3RocmVlJztcblxuLy8gUmFuZG9tbHkgZGVscGxhY2UgY2xvdWQgdmVydGljaWVzXG5jb25zdCBtYXAgPSAodmFsLCBzbWluLCBzbWF4LCBlbWluLCBlbWF4KSA9PiAoZW1heCAtIGVtaW4pICogKHZhbCAtIHNtaW4pIC8gKHNtYXggLSBzbWluKSArIGVtaW5cbmNvbnN0IGppdHRlciA9IChnZW9tZXRyeSwgcGVyKSA9PiB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50OyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbKGkgKiAzKV0gKz0gbWFwKE1hdGgucmFuZG9tKCksIDAsIDEsIC1wZXIsIHBlcilcbiAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVsoaSAqIDMpICsgMV0gKz0gbWFwKE1hdGgucmFuZG9tKCksIDAsIDEsIC1wZXIsIHBlcilcbiAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVsoaSAqIDMpICsgMl0gKz0gbWFwKE1hdGgucmFuZG9tKCksIDAsIDEsIC1wZXIsIHBlcilcbiAgICB9O1xufVxuXG5leHBvcnQgY2xhc3MgR2VuZXJhdGVDbG91ZHMge1xuICAgIGNvbnN0cnVjdG9yKHBvcywgc2NlbmUsIHNwZWVkLCBzY2FsZSkge1xuXG5cbiAgICAgICAgY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcblxuICAgICAgICBjb25zdCB0dWZ0MSA9IG5ldyBTcGhlcmVHZW9tZXRyeSgxLjUgKiBzY2FsZSwgNywgMTEpXG4gICAgICAgIHR1ZnQxLnRyYW5zbGF0ZSgtMiAqIHNjYWxlLCAwLCAwKVxuXG5cbiAgICAgICAgY29uc3QgdHVmdDMgPSBuZXcgU3BoZXJlR2VvbWV0cnkoMS41ICogc2NhbGUsIDcsIDExKVxuICAgICAgICB0dWZ0My50cmFuc2xhdGUoMiAqIHNjYWxlLCAwLCAwKVxuXG4gICAgICAgIGNvbnN0IHR1ZnQyID0gbmV3IFNwaGVyZUdlb21ldHJ5KDIuMCAqIHNjYWxlLCA3LCAxMSlcbiAgICAgICAgdHVmdDIudHJhbnNsYXRlKDAsIDAsIDApXG5cbiAgICAgICAgaml0dGVyKHR1ZnQxLCAwLjIpXG4gICAgICAgIGppdHRlcih0dWZ0MiwgMC4xKVxuICAgICAgICBqaXR0ZXIodHVmdDMsIDAuMSlcblxuICAgICAgICB0dWZ0MS5jb21wdXRlVmVydGV4Tm9ybWFscygpXG5cblxuICAgICAgICBjb25zdCBtYXQgPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoe1xuICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICBmbGF0U2hhZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIHNpZGU6RG91YmxlU2lkZSxcbiAgICAgICAgfSlcblxuICAgICAgICBsZXQgY2xvdWQgPSBuZXcgTWVzaChcbiAgICAgICAgICAgIHR1ZnQxLFxuICAgICAgICAgICAgbWF0XG4gICAgICAgIClcbiAgICAgICAgbGV0IGNsb3VkMSA9IG5ldyBNZXNoKFxuICAgICAgICAgICAgdHVmdDIsXG4gICAgICAgICAgICBtYXRcbiAgICAgICAgKVxuICAgICAgICBsZXQgY2xvdWQyID0gbmV3IE1lc2goXG4gICAgICAgICAgICB0dWZ0MyxcbiAgICAgICAgICAgIG1hdFxuICAgICAgICApXG5cbiAgICAgICAgZ3JvdXAuYWRkKGNsb3VkKVxuICAgICAgICBncm91cC5hZGQoY2xvdWQxKVxuICAgICAgICBncm91cC5hZGQoY2xvdWQyKVxuXG4gICAgICAgIHNjZW5lLmFkZChncm91cClcbiAgICAgICAgZ3JvdXAuY2FzdFNoYWRvdyA9IHRydWVcbiAgICAgICAgZ3JvdXAucmVjZWl2ZVNoYWRvdyA9IHRydWVcbiAgICAgICAgZ3JvdXAucG9zaXRpb24ueCA9IHBvcy54XG4gICAgICAgIGdyb3VwLnBvc2l0aW9uLnkgPSBwb3MueVxuICAgICAgICBncm91cC5wb3NpdGlvbi56ID0gcG9zLnpcblxuICAgICAgICB0aGlzLmdyYXNzID0gZ3JvdXBcbiAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkXG4gICAgICAgIHRoaXMucG9zID0gcG9zXG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgZ2VvcyA9IHRoaXMuZ3Jhc3NcbiAgICAgICAgZ2Vvcy5wb3NpdGlvbi54ICs9IHRoaXMuc3BlZWRcbiAgICAgICAgaWYgKGdlb3MucG9zaXRpb24ueCA+IDQwMCkge1xuICAgICAgICAgICAgZ2Vvcy5wb3NpdGlvbi54ID0gdGhpcy5wb3MueFxuICAgICAgICB9XG4gICAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/gameFundalmentals/clouds.js\n");

/***/ }),

/***/ "./components/gameFundalmentals/controls.js":
/*!**************************************************!*\
  !*** ./components/gameFundalmentals/controls.js ***!
  \**************************************************/
/*! exports provided: ControlHandlerInit, ControlHandlerUpdate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ControlHandlerInit\", function() { return ControlHandlerInit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ControlHandlerUpdate\", function() { return ControlHandlerUpdate; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n// Written By Harvey Randall \\\\\n\nlet [w, a, s, d, up, down, e, q, shift] = [false, false, false, false, false, false, false, false, 1];\nfunction ControlHandlerInit(document, child2) {\n  document.addEventListener(\"keydown\", e => {\n    onDocumentKeyDown(e, true);\n  }, false);\n  document.addEventListener(\"keyup\", e => {\n    onDocumentKeyDown(e, false);\n  }, false);\n\n  function onDocumentKeyDown(event, val) {\n    if (child2 === document.activeElement) return;\n    var keyCode = event.which;\n\n    if (keyCode == 87) {\n      w = val;\n    }\n\n    if (keyCode == 83) {\n      s = val;\n    }\n\n    if (keyCode == 65) {\n      a = val;\n    }\n\n    if (keyCode == 68) {\n      d = val;\n    }\n\n    if (keyCode == 38) {\n      up = val;\n    }\n\n    if (keyCode == 40) {\n      down = val;\n    }\n\n    if (keyCode == 69) {\n      e = val;\n    }\n\n    if (keyCode == 81) {\n      q = val;\n    }\n\n    if (keyCode == 16) {\n      shift = val ? 0.5 : 1;\n    }\n  }\n\n  ;\n}\nfunction ControlHandlerUpdate(Camera) {\n  if (w) {\n    var direction = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n    Camera.getWorldDirection(direction);\n    Camera.position.add(direction.multiplyScalar(shift == 1 ? 1 : 0.25));\n  }\n\n  if (s) {\n    var direction = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n    Camera.getWorldDirection(direction);\n    Camera.position.add(direction.multiplyScalar(-(shift == 1 ? 1 : 0.25)));\n  }\n\n  if (a) {\n    Camera.rotateY(0.04 * shift);\n  }\n\n  if (d) {\n    Camera.rotateY(-0.04 * shift);\n  }\n\n  if (up) {\n    Camera.rotateX(0.04 * shift);\n  }\n\n  if (down) {\n    Camera.rotateX(-0.04 * shift);\n  }\n\n  if (q) {\n    Camera.rotateZ(0.02 * shift);\n  }\n\n  if (e) {\n    Camera.rotateZ(-0.02 * shift);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2dhbWVGdW5kYWxtZW50YWxzL2NvbnRyb2xzLmpzPzU3OWEiXSwibmFtZXMiOlsidyIsImEiLCJzIiwiZCIsInVwIiwiZG93biIsImUiLCJxIiwic2hpZnQiLCJDb250cm9sSGFuZGxlckluaXQiLCJkb2N1bWVudCIsImNoaWxkMiIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbkRvY3VtZW50S2V5RG93biIsImV2ZW50IiwidmFsIiwiYWN0aXZlRWxlbWVudCIsImtleUNvZGUiLCJ3aGljaCIsIkNvbnRyb2xIYW5kbGVyVXBkYXRlIiwiQ2FtZXJhIiwiZGlyZWN0aW9uIiwiVmVjdG9yMyIsImdldFdvcmxkRGlyZWN0aW9uIiwicG9zaXRpb24iLCJhZGQiLCJtdWx0aXBseVNjYWxhciIsInJvdGF0ZVkiLCJyb3RhdGVYIiwicm90YXRlWiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQSxJQUFJLENBQUNBLENBQUQsRUFBSUMsQ0FBSixFQUFPQyxDQUFQLEVBQVVDLENBQVYsRUFBYUMsRUFBYixFQUFpQkMsSUFBakIsRUFBdUJDLENBQXZCLEVBQTBCQyxDQUExQixFQUE2QkMsS0FBN0IsSUFBc0MsQ0FBQyxLQUFELEVBQVEsS0FBUixFQUFlLEtBQWYsRUFBc0IsS0FBdEIsRUFBNkIsS0FBN0IsRUFBb0MsS0FBcEMsRUFBMkMsS0FBM0MsRUFBa0QsS0FBbEQsRUFBeUQsQ0FBekQsQ0FBMUM7QUFFTyxTQUFTQyxrQkFBVCxDQUE0QkMsUUFBNUIsRUFBc0NDLE1BQXRDLEVBQThDO0FBRWpERCxVQUFRLENBQUNFLGdCQUFULENBQTBCLFNBQTFCLEVBQXNDTixDQUFELElBQU87QUFBRU8scUJBQWlCLENBQUNQLENBQUQsRUFBSSxJQUFKLENBQWpCO0FBQTRCLEdBQTFFLEVBQTRFLEtBQTVFO0FBQ0FJLFVBQVEsQ0FBQ0UsZ0JBQVQsQ0FBMEIsT0FBMUIsRUFBb0NOLENBQUQsSUFBTztBQUFFTyxxQkFBaUIsQ0FBQ1AsQ0FBRCxFQUFJLEtBQUosQ0FBakI7QUFBNkIsR0FBekUsRUFBMkUsS0FBM0U7O0FBRUEsV0FBU08saUJBQVQsQ0FBMkJDLEtBQTNCLEVBQWtDQyxHQUFsQyxFQUF1QztBQUNuQyxRQUFJSixNQUFNLEtBQUtELFFBQVEsQ0FBQ00sYUFBeEIsRUFBdUM7QUFDdkMsUUFBSUMsT0FBTyxHQUFHSCxLQUFLLENBQUNJLEtBQXBCOztBQUNBLFFBQUlELE9BQU8sSUFBSSxFQUFmLEVBQW1CO0FBQ2ZqQixPQUFDLEdBQUdlLEdBQUo7QUFDSDs7QUFDRCxRQUFJRSxPQUFPLElBQUksRUFBZixFQUFtQjtBQUNmZixPQUFDLEdBQUdhLEdBQUo7QUFDSDs7QUFDRCxRQUFJRSxPQUFPLElBQUksRUFBZixFQUFtQjtBQUNmaEIsT0FBQyxHQUFHYyxHQUFKO0FBQ0g7O0FBQ0QsUUFBSUUsT0FBTyxJQUFJLEVBQWYsRUFBbUI7QUFDZmQsT0FBQyxHQUFHWSxHQUFKO0FBQ0g7O0FBQ0QsUUFBSUUsT0FBTyxJQUFJLEVBQWYsRUFBbUI7QUFDZmIsUUFBRSxHQUFHVyxHQUFMO0FBQ0g7O0FBQ0QsUUFBSUUsT0FBTyxJQUFJLEVBQWYsRUFBbUI7QUFDZlosVUFBSSxHQUFHVSxHQUFQO0FBQ0g7O0FBQ0QsUUFBSUUsT0FBTyxJQUFJLEVBQWYsRUFBbUI7QUFDZlgsT0FBQyxHQUFHUyxHQUFKO0FBQ0g7O0FBQ0QsUUFBSUUsT0FBTyxJQUFJLEVBQWYsRUFBbUI7QUFDZlYsT0FBQyxHQUFHUSxHQUFKO0FBQ0g7O0FBQ0QsUUFBSUUsT0FBTyxJQUFJLEVBQWYsRUFBbUI7QUFDZlQsV0FBSyxHQUFHTyxHQUFHLEdBQUcsR0FBSCxHQUFTLENBQXBCO0FBQ0g7QUFDSjs7QUFBQTtBQUNKO0FBRU0sU0FBU0ksb0JBQVQsQ0FBOEJDLE1BQTlCLEVBQXNDO0FBQ3pDLE1BQUlwQixDQUFKLEVBQU87QUFDSCxRQUFJcUIsU0FBUyxHQUFHLElBQUlDLDZDQUFKLEVBQWhCO0FBQ0FGLFVBQU0sQ0FBQ0csaUJBQVAsQ0FBeUJGLFNBQXpCO0FBQ0FELFVBQU0sQ0FBQ0ksUUFBUCxDQUFnQkMsR0FBaEIsQ0FBb0JKLFNBQVMsQ0FBQ0ssY0FBVixDQUF5QmxCLEtBQUssSUFBSSxDQUFULEdBQWEsQ0FBYixHQUFpQixJQUExQyxDQUFwQjtBQUNIOztBQUNELE1BQUlOLENBQUosRUFBTztBQUNILFFBQUltQixTQUFTLEdBQUcsSUFBSUMsNkNBQUosRUFBaEI7QUFDQUYsVUFBTSxDQUFDRyxpQkFBUCxDQUF5QkYsU0FBekI7QUFDQUQsVUFBTSxDQUFDSSxRQUFQLENBQWdCQyxHQUFoQixDQUFvQkosU0FBUyxDQUFDSyxjQUFWLENBQXlCLEVBQUVsQixLQUFLLElBQUksQ0FBVCxHQUFhLENBQWIsR0FBaUIsSUFBbkIsQ0FBekIsQ0FBcEI7QUFDSDs7QUFDRCxNQUFJUCxDQUFKLEVBQU87QUFDSG1CLFVBQU0sQ0FBQ08sT0FBUCxDQUFlLE9BQU9uQixLQUF0QjtBQUNIOztBQUNELE1BQUlMLENBQUosRUFBTztBQUNIaUIsVUFBTSxDQUFDTyxPQUFQLENBQWUsQ0FBQyxJQUFELEdBQVFuQixLQUF2QjtBQUNIOztBQUNELE1BQUlKLEVBQUosRUFBUTtBQUNKZ0IsVUFBTSxDQUFDUSxPQUFQLENBQWUsT0FBT3BCLEtBQXRCO0FBQ0g7O0FBQ0QsTUFBSUgsSUFBSixFQUFVO0FBQ05lLFVBQU0sQ0FBQ1EsT0FBUCxDQUFlLENBQUMsSUFBRCxHQUFRcEIsS0FBdkI7QUFDSDs7QUFDRCxNQUFJRCxDQUFKLEVBQU87QUFDSGEsVUFBTSxDQUFDUyxPQUFQLENBQWUsT0FBT3JCLEtBQXRCO0FBQ0g7O0FBQ0QsTUFBSUYsQ0FBSixFQUFPO0FBQ0hjLFVBQU0sQ0FBQ1MsT0FBUCxDQUFlLENBQUMsSUFBRCxHQUFRckIsS0FBdkI7QUFDSDtBQUNKIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9nYW1lRnVuZGFsbWVudGFscy9jb250cm9scy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFdyaXR0ZW4gQnkgSGFydmV5IFJhbmRhbGwgXFxcXFxuXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSBcInRocmVlXCI7XG5sZXQgW3csIGEsIHMsIGQsIHVwLCBkb3duLCBlLCBxLCBzaGlmdF0gPSBbZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAxXVxuXG5leHBvcnQgZnVuY3Rpb24gQ29udHJvbEhhbmRsZXJJbml0KGRvY3VtZW50LCBjaGlsZDIpIHtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlKSA9PiB7IG9uRG9jdW1lbnRLZXlEb3duKGUsIHRydWUpIH0sIGZhbHNlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgKGUpID0+IHsgb25Eb2N1bWVudEtleURvd24oZSwgZmFsc2UpIH0sIGZhbHNlKTtcblxuICAgIGZ1bmN0aW9uIG9uRG9jdW1lbnRLZXlEb3duKGV2ZW50LCB2YWwpIHtcbiAgICAgICAgaWYgKGNoaWxkMiA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG4gICAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQud2hpY2g7XG4gICAgICAgIGlmIChrZXlDb2RlID09IDg3KSB7XG4gICAgICAgICAgICB3ID0gdmFsXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUNvZGUgPT0gODMpIHtcbiAgICAgICAgICAgIHMgPSB2YWxcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5Q29kZSA9PSA2NSkge1xuICAgICAgICAgICAgYSA9IHZhbFxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlDb2RlID09IDY4KSB7XG4gICAgICAgICAgICBkID0gdmFsXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUNvZGUgPT0gMzgpIHtcbiAgICAgICAgICAgIHVwID0gdmFsXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUNvZGUgPT0gNDApIHtcbiAgICAgICAgICAgIGRvd24gPSB2YWxcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5Q29kZSA9PSA2OSkge1xuICAgICAgICAgICAgZSA9IHZhbFxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlDb2RlID09IDgxKSB7XG4gICAgICAgICAgICBxID0gdmFsXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUNvZGUgPT0gMTYpIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gdmFsID8gMC41IDogMVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENvbnRyb2xIYW5kbGVyVXBkYXRlKENhbWVyYSkge1xuICAgIGlmICh3KSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICBDYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgICAgQ2FtZXJhLnBvc2l0aW9uLmFkZChkaXJlY3Rpb24ubXVsdGlwbHlTY2FsYXIoc2hpZnQgPT0gMSA/IDEgOiAwLjI1KSk7XG4gICAgfVxuICAgIGlmIChzKSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICBDYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgICAgQ2FtZXJhLnBvc2l0aW9uLmFkZChkaXJlY3Rpb24ubXVsdGlwbHlTY2FsYXIoLShzaGlmdCA9PSAxID8gMSA6IDAuMjUpKSk7XG4gICAgfVxuICAgIGlmIChhKSB7XG4gICAgICAgIENhbWVyYS5yb3RhdGVZKDAuMDQgKiBzaGlmdClcbiAgICB9XG4gICAgaWYgKGQpIHtcbiAgICAgICAgQ2FtZXJhLnJvdGF0ZVkoLTAuMDQgKiBzaGlmdClcbiAgICB9XG4gICAgaWYgKHVwKSB7XG4gICAgICAgIENhbWVyYS5yb3RhdGVYKDAuMDQgKiBzaGlmdClcbiAgICB9XG4gICAgaWYgKGRvd24pIHtcbiAgICAgICAgQ2FtZXJhLnJvdGF0ZVgoLTAuMDQgKiBzaGlmdClcbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgICAgQ2FtZXJhLnJvdGF0ZVooMC4wMiAqIHNoaWZ0KVxuICAgIH1cbiAgICBpZiAoZSkge1xuICAgICAgICBDYW1lcmEucm90YXRlWigtMC4wMiAqIHNoaWZ0KVxuICAgIH1cbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/gameFundalmentals/controls.js\n");

/***/ }),

/***/ "./components/gameFundalmentals/multiplayer/MainPlayerHandler.js":
/*!***********************************************************************!*\
  !*** ./components/gameFundalmentals/multiplayer/MainPlayerHandler.js ***!
  \***********************************************************************/
/*! exports provided: MakeNewCubePlayer, InitMainGameHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MakeNewCubePlayer\", function() { return MakeNewCubePlayer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InitMainGameHandler\", function() { return InitMainGameHandler; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Core_API_ConnectAPI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Core-API/ConnectAPI */ \"./components/Core-API/ConnectAPI.js\");\n/* harmony import */ var _nametag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../nametag */ \"./components/gameFundalmentals/nametag.js\");\n// Written By Harvey Randall \\\\\n\n\n\nlet players = [];\nfunction MakeNewCubePlayer(color = \"rgb(0,0,0)\", name = \"unkown\", SceneToGet) {\n  const group = new three__WEBPACK_IMPORTED_MODULE_0__[\"Group\"]();\n  const geometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxGeometry\"](1, 1, 1);\n  const material = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshLambertMaterial\"]({\n    color: new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](color),\n    emissive: new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](color)\n  });\n  const cube = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](geometry, material);\n  group.add(cube);\n  const cyclinder = new three__WEBPACK_IMPORTED_MODULE_0__[\"CylinderGeometry\"](0.3, 0.3, 0.6, 30);\n  const material2 = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshLambertMaterial\"]({\n    color: 0x000000\n  });\n  const cylinderBuild = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](cyclinder, material2);\n  cylinderBuild.rotateX(Math.PI / 2 + Math.PI);\n  cylinderBuild.position.set(0, 0, -0.6);\n  group.add(cylinderBuild);\n  Object(_nametag__WEBPACK_IMPORTED_MODULE_2__[\"GenerateLabel\"])(name, group);\n  SceneToGet.add(group);\n  group.name = name;\n  return group;\n}\nfunction InitMainGameHandler() {\n  Object(_Core_API_ConnectAPI__WEBPACK_IMPORTED_MODULE_1__[\"ListenToEvent\"])(\"NewPlayer\", (id, data) => {\n    console.log(data);\n    console.log(\"New PLyer \" + id);\n    let cube = MakeCube(data.color, data.name);\n    addtoGameFeed(data === null || data === void 0 ? void 0 : data.name, \"Joined the game!\");\n    players[id] = cube;\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2dhbWVGdW5kYWxtZW50YWxzL211bHRpcGxheWVyL01haW5QbGF5ZXJIYW5kbGVyLmpzP2JjMzUiXSwibmFtZXMiOlsicGxheWVycyIsIk1ha2VOZXdDdWJlUGxheWVyIiwiY29sb3IiLCJuYW1lIiwiU2NlbmVUb0dldCIsImdyb3VwIiwiR3JvdXAiLCJnZW9tZXRyeSIsIkJveEdlb21ldHJ5IiwibWF0ZXJpYWwiLCJNZXNoTGFtYmVydE1hdGVyaWFsIiwiQ29sb3IiLCJlbWlzc2l2ZSIsImN1YmUiLCJNZXNoIiwiYWRkIiwiY3ljbGluZGVyIiwiQ3lsaW5kZXJHZW9tZXRyeSIsIm1hdGVyaWFsMiIsImN5bGluZGVyQnVpbGQiLCJyb3RhdGVYIiwiTWF0aCIsIlBJIiwicG9zaXRpb24iLCJzZXQiLCJHZW5lcmF0ZUxhYmVsIiwiSW5pdE1haW5HYW1lSGFuZGxlciIsIkxpc3RlblRvRXZlbnQiLCJpZCIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwiTWFrZUN1YmUiLCJhZGR0b0dhbWVGZWVkIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSUEsT0FBTyxHQUFHLEVBQWQ7QUFFTyxTQUFTQyxpQkFBVCxDQUEyQkMsS0FBSyxHQUFHLFlBQW5DLEVBQWlEQyxJQUFJLEdBQUcsUUFBeEQsRUFBa0VDLFVBQWxFLEVBQThFO0FBQ2pGLFFBQU1DLEtBQUssR0FBRyxJQUFJQywyQ0FBSixFQUFkO0FBQ0EsUUFBTUMsUUFBUSxHQUFHLElBQUlDLGlEQUFKLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLENBQWpCO0FBQ0EsUUFBTUMsUUFBUSxHQUFHLElBQUlDLHlEQUFKLENBQXdCO0FBQUVSLFNBQUssRUFBRSxJQUFJUywyQ0FBSixDQUFVVCxLQUFWLENBQVQ7QUFBMkJVLFlBQVEsRUFBRSxJQUFJRCwyQ0FBSixDQUFVVCxLQUFWO0FBQXJDLEdBQXhCLENBQWpCO0FBQ0EsUUFBTVcsSUFBSSxHQUFHLElBQUlDLDBDQUFKLENBQVNQLFFBQVQsRUFBbUJFLFFBQW5CLENBQWI7QUFDQUosT0FBSyxDQUFDVSxHQUFOLENBQVVGLElBQVY7QUFDQSxRQUFNRyxTQUFTLEdBQUcsSUFBSUMsc0RBQUosQ0FBcUIsR0FBckIsRUFBMEIsR0FBMUIsRUFBK0IsR0FBL0IsRUFBb0MsRUFBcEMsQ0FBbEI7QUFDQSxRQUFNQyxTQUFTLEdBQUcsSUFBSVIseURBQUosQ0FBd0I7QUFBRVIsU0FBSyxFQUFFO0FBQVQsR0FBeEIsQ0FBbEI7QUFDQSxRQUFNaUIsYUFBYSxHQUFHLElBQUlMLDBDQUFKLENBQVNFLFNBQVQsRUFBb0JFLFNBQXBCLENBQXRCO0FBQ0FDLGVBQWEsQ0FBQ0MsT0FBZCxDQUF1QkMsSUFBSSxDQUFDQyxFQUFMLEdBQVUsQ0FBWCxHQUFnQkQsSUFBSSxDQUFDQyxFQUEzQztBQUNBSCxlQUFhLENBQUNJLFFBQWQsQ0FBdUJDLEdBQXZCLENBQTJCLENBQTNCLEVBQThCLENBQTlCLEVBQWlDLENBQUMsR0FBbEM7QUFDQW5CLE9BQUssQ0FBQ1UsR0FBTixDQUFVSSxhQUFWO0FBRUFNLGdFQUFhLENBQUN0QixJQUFELEVBQU9FLEtBQVAsQ0FBYjtBQUNBRCxZQUFVLENBQUNXLEdBQVgsQ0FBZVYsS0FBZjtBQUNBQSxPQUFLLENBQUNGLElBQU4sR0FBYUEsSUFBYjtBQUNBLFNBQU9FLEtBQVA7QUFDSDtBQUVNLFNBQVNxQixtQkFBVCxHQUErQjtBQUNsQ0MsNEVBQWEsQ0FBQyxXQUFELEVBQWMsQ0FBQ0MsRUFBRCxFQUFLQyxJQUFMLEtBQWM7QUFDckNDLFdBQU8sQ0FBQ0MsR0FBUixDQUFZRixJQUFaO0FBQ0FDLFdBQU8sQ0FBQ0MsR0FBUixDQUFZLGVBQWVILEVBQTNCO0FBQ0EsUUFBSWYsSUFBSSxHQUFHbUIsUUFBUSxDQUFDSCxJQUFJLENBQUMzQixLQUFOLEVBQWEyQixJQUFJLENBQUMxQixJQUFsQixDQUFuQjtBQUNBOEIsaUJBQWEsQ0FBQ0osSUFBRCxhQUFDQSxJQUFELHVCQUFDQSxJQUFJLENBQUUxQixJQUFQLEVBQWEsa0JBQWIsQ0FBYjtBQUVBSCxXQUFPLENBQUM0QixFQUFELENBQVAsR0FBY2YsSUFBZDtBQUNILEdBUFksQ0FBYjtBQVFIIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9nYW1lRnVuZGFsbWVudGFscy9tdWx0aXBsYXllci9NYWluUGxheWVySGFuZGxlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFdyaXR0ZW4gQnkgSGFydmV5IFJhbmRhbGwgXFxcXFxuXG5pbXBvcnQgeyBCb3hHZW9tZXRyeSwgQ29sb3IsIEN5bGluZGVyR2VvbWV0cnksIEdyb3VwLCBNZXNoLCBNZXNoTGFtYmVydE1hdGVyaWFsIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyBMaXN0ZW5Ub0V2ZW50IH0gZnJvbSBcIi4uLy4uL0NvcmUtQVBJL0Nvbm5lY3RBUElcIjtcbmltcG9ydCB7IEdlbmVyYXRlTGFiZWwgfSBmcm9tIFwiLi4vbmFtZXRhZ1wiO1xubGV0IHBsYXllcnMgPSBbXVxuXG5leHBvcnQgZnVuY3Rpb24gTWFrZU5ld0N1YmVQbGF5ZXIoY29sb3IgPSBcInJnYigwLDAsMClcIiwgbmFtZSA9IFwidW5rb3duXCIsIFNjZW5lVG9HZXQpIHtcbiAgICBjb25zdCBncm91cCA9IG5ldyBHcm91cCgpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJveEdlb21ldHJ5KDEsIDEsIDEpO1xuICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IE1lc2hMYW1iZXJ0TWF0ZXJpYWwoeyBjb2xvcjogbmV3IENvbG9yKGNvbG9yKSwgZW1pc3NpdmU6IG5ldyBDb2xvcihjb2xvcikgfSk7XG4gICAgY29uc3QgY3ViZSA9IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgZ3JvdXAuYWRkKGN1YmUpXG4gICAgY29uc3QgY3ljbGluZGVyID0gbmV3IEN5bGluZGVyR2VvbWV0cnkoMC4zLCAwLjMsIDAuNiwgMzApO1xuICAgIGNvbnN0IG1hdGVyaWFsMiA9IG5ldyBNZXNoTGFtYmVydE1hdGVyaWFsKHsgY29sb3I6IDB4MDAwMDAwIH0pO1xuICAgIGNvbnN0IGN5bGluZGVyQnVpbGQgPSBuZXcgTWVzaChjeWNsaW5kZXIsIG1hdGVyaWFsMik7XG4gICAgY3lsaW5kZXJCdWlsZC5yb3RhdGVYKChNYXRoLlBJIC8gMikgKyBNYXRoLlBJKVxuICAgIGN5bGluZGVyQnVpbGQucG9zaXRpb24uc2V0KDAsIDAsIC0wLjYpXG4gICAgZ3JvdXAuYWRkKGN5bGluZGVyQnVpbGQpXG5cbiAgICBHZW5lcmF0ZUxhYmVsKG5hbWUsIGdyb3VwKVxuICAgIFNjZW5lVG9HZXQuYWRkKGdyb3VwKVxuICAgIGdyb3VwLm5hbWUgPSBuYW1lXG4gICAgcmV0dXJuIGdyb3VwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBJbml0TWFpbkdhbWVIYW5kbGVyKCkge1xuICAgIExpc3RlblRvRXZlbnQoXCJOZXdQbGF5ZXJcIiwgKGlkLCBkYXRhKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIGNvbnNvbGUubG9nKFwiTmV3IFBMeWVyIFwiICsgaWQpXG4gICAgICAgIGxldCBjdWJlID0gTWFrZUN1YmUoZGF0YS5jb2xvciwgZGF0YS5uYW1lKVxuICAgICAgICBhZGR0b0dhbWVGZWVkKGRhdGE/Lm5hbWUsIFwiSm9pbmVkIHRoZSBnYW1lIVwiKVxuXG4gICAgICAgIHBsYXllcnNbaWRdID0gY3ViZVxuICAgIH0pXG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/gameFundalmentals/multiplayer/MainPlayerHandler.js\n");

/***/ }),

/***/ "./components/gameFundalmentals/nametag.js":
/*!*************************************************!*\
  !*** ./components/gameFundalmentals/nametag.js ***!
  \*************************************************/
/*! exports provided: CreateTag, GenerateLabel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CreateTag\", function() { return CreateTag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GenerateLabel\", function() { return GenerateLabel; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction CreateTag(baseWidth, size, name) {\n  const borderSize = 2;\n  const ctx = document.createElement('canvas').getContext('2d');\n  const font = `${size}px Verdana`;\n  ctx.font = font; // measure how long the name will be\n\n  const textWidth = ctx.measureText(name).width;\n  const doubleBorderSize = borderSize * 2;\n  const width = baseWidth + doubleBorderSize;\n  const height = size + doubleBorderSize;\n  ctx.canvas.width = width;\n  ctx.canvas.height = height; // need to set font again after resizing canvas\n\n  ctx.font = font;\n  ctx.textBaseline = 'middle';\n  ctx.textAlign = 'center'; //ctx.fillStyle = 'blue';\n  //ctx.fillRect(0, 0, width, height);\n  // scale to fit but don't stretch\n\n  const scaleFactor = Math.min(1, baseWidth / textWidth);\n  ctx.translate(width / 2, height / 2);\n  ctx.scale(scaleFactor, 1);\n  ctx.fillStyle = 'white';\n  ctx.fillText(name, 0, 0);\n  return ctx.canvas;\n}\nfunction GenerateLabel(name, group) {\n  const canvas = CreateTag(300, 32, name);\n  const texture = new three__WEBPACK_IMPORTED_MODULE_0__[\"CanvasTexture\"](canvas); // because our canvas is likely not a power of 2\n  // in both dimensions set the filtering appropriately.\n\n  texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"LinearFilter\"];\n  texture.wrapS = three__WEBPACK_IMPORTED_MODULE_0__[\"ClampToEdgeWrapping\"];\n  texture.wrapT = three__WEBPACK_IMPORTED_MODULE_0__[\"ClampToEdgeWrapping\"];\n  const labelMaterial = new three__WEBPACK_IMPORTED_MODULE_0__[\"SpriteMaterial\"]({\n    map: texture,\n    transparent: true\n  }); // if units are meters then 0.01 here makes size\n  // of the label into centimeters.\n\n  const labelBaseScale = 0.01;\n  const label = new three__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"](labelMaterial);\n  group.add(label);\n  label.position.y = 1;\n  label.scale.x = canvas.width * labelBaseScale;\n  label.scale.y = canvas.height * labelBaseScale;\n  return group;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL25hbWV0YWcuanM/NDgwNyJdLCJuYW1lcyI6WyJDcmVhdGVUYWciLCJiYXNlV2lkdGgiLCJzaXplIiwibmFtZSIsImJvcmRlclNpemUiLCJjdHgiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJnZXRDb250ZXh0IiwiZm9udCIsInRleHRXaWR0aCIsIm1lYXN1cmVUZXh0Iiwid2lkdGgiLCJkb3VibGVCb3JkZXJTaXplIiwiaGVpZ2h0IiwiY2FudmFzIiwidGV4dEJhc2VsaW5lIiwidGV4dEFsaWduIiwic2NhbGVGYWN0b3IiLCJNYXRoIiwibWluIiwidHJhbnNsYXRlIiwic2NhbGUiLCJmaWxsU3R5bGUiLCJmaWxsVGV4dCIsIkdlbmVyYXRlTGFiZWwiLCJncm91cCIsInRleHR1cmUiLCJUSFJFRSIsIm1pbkZpbHRlciIsIndyYXBTIiwid3JhcFQiLCJsYWJlbE1hdGVyaWFsIiwibWFwIiwidHJhbnNwYXJlbnQiLCJsYWJlbEJhc2VTY2FsZSIsImxhYmVsIiwiYWRkIiwicG9zaXRpb24iLCJ5IiwieCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRU8sU0FBU0EsU0FBVCxDQUFtQkMsU0FBbkIsRUFBOEJDLElBQTlCLEVBQW9DQyxJQUFwQyxFQUEwQztBQUM3QyxRQUFNQyxVQUFVLEdBQUcsQ0FBbkI7QUFDQSxRQUFNQyxHQUFHLEdBQUdDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixRQUF2QixFQUFpQ0MsVUFBakMsQ0FBNEMsSUFBNUMsQ0FBWjtBQUVBLFFBQU1DLElBQUksR0FBSSxHQUFFUCxJQUFLLFlBQXJCO0FBQ0FHLEtBQUcsQ0FBQ0ksSUFBSixHQUFXQSxJQUFYLENBTDZDLENBTTdDOztBQUNBLFFBQU1DLFNBQVMsR0FBR0wsR0FBRyxDQUFDTSxXQUFKLENBQWdCUixJQUFoQixFQUFzQlMsS0FBeEM7QUFFQSxRQUFNQyxnQkFBZ0IsR0FBR1QsVUFBVSxHQUFHLENBQXRDO0FBQ0EsUUFBTVEsS0FBSyxHQUFHWCxTQUFTLEdBQUdZLGdCQUExQjtBQUNBLFFBQU1DLE1BQU0sR0FBR1osSUFBSSxHQUFHVyxnQkFBdEI7QUFDQVIsS0FBRyxDQUFDVSxNQUFKLENBQVdILEtBQVgsR0FBbUJBLEtBQW5CO0FBQ0FQLEtBQUcsQ0FBQ1UsTUFBSixDQUFXRCxNQUFYLEdBQW9CQSxNQUFwQixDQWI2QyxDQWU3Qzs7QUFDQVQsS0FBRyxDQUFDSSxJQUFKLEdBQVdBLElBQVg7QUFDQUosS0FBRyxDQUFDVyxZQUFKLEdBQW1CLFFBQW5CO0FBQ0FYLEtBQUcsQ0FBQ1ksU0FBSixHQUFnQixRQUFoQixDQWxCNkMsQ0FvQjdDO0FBQ0E7QUFFQTs7QUFDQSxRQUFNQyxXQUFXLEdBQUdDLElBQUksQ0FBQ0MsR0FBTCxDQUFTLENBQVQsRUFBWW5CLFNBQVMsR0FBR1MsU0FBeEIsQ0FBcEI7QUFDQUwsS0FBRyxDQUFDZ0IsU0FBSixDQUFjVCxLQUFLLEdBQUcsQ0FBdEIsRUFBeUJFLE1BQU0sR0FBRyxDQUFsQztBQUNBVCxLQUFHLENBQUNpQixLQUFKLENBQVVKLFdBQVYsRUFBdUIsQ0FBdkI7QUFDQWIsS0FBRyxDQUFDa0IsU0FBSixHQUFnQixPQUFoQjtBQUNBbEIsS0FBRyxDQUFDbUIsUUFBSixDQUFhckIsSUFBYixFQUFtQixDQUFuQixFQUFzQixDQUF0QjtBQUVBLFNBQU9FLEdBQUcsQ0FBQ1UsTUFBWDtBQUNIO0FBRU0sU0FBU1UsYUFBVCxDQUF1QnRCLElBQXZCLEVBQTZCdUIsS0FBN0IsRUFBb0M7QUFDdkMsUUFBTVgsTUFBTSxHQUFHZixTQUFTLENBQUMsR0FBRCxFQUFNLEVBQU4sRUFBVUcsSUFBVixDQUF4QjtBQUNBLFFBQU13QixPQUFPLEdBQUcsSUFBSUMsbURBQUosQ0FBd0JiLE1BQXhCLENBQWhCLENBRnVDLENBR3ZDO0FBQ0E7O0FBQ0FZLFNBQU8sQ0FBQ0UsU0FBUixHQUFvQkQsa0RBQXBCO0FBQ0FELFNBQU8sQ0FBQ0csS0FBUixHQUFnQkYseURBQWhCO0FBQ0FELFNBQU8sQ0FBQ0ksS0FBUixHQUFnQkgseURBQWhCO0FBRUEsUUFBTUksYUFBYSxHQUFHLElBQUlKLG9EQUFKLENBQXlCO0FBQzNDSyxPQUFHLEVBQUVOLE9BRHNDO0FBRTNDTyxlQUFXLEVBQUU7QUFGOEIsR0FBekIsQ0FBdEIsQ0FUdUMsQ0FhdkM7QUFDQTs7QUFDQSxRQUFNQyxjQUFjLEdBQUcsSUFBdkI7QUFFQSxRQUFNQyxLQUFLLEdBQUcsSUFBSVIsNENBQUosQ0FBaUJJLGFBQWpCLENBQWQ7QUFDQU4sT0FBSyxDQUFDVyxHQUFOLENBQVVELEtBQVY7QUFDQUEsT0FBSyxDQUFDRSxRQUFOLENBQWVDLENBQWYsR0FBbUIsQ0FBbkI7QUFFQUgsT0FBSyxDQUFDZCxLQUFOLENBQVlrQixDQUFaLEdBQWdCekIsTUFBTSxDQUFDSCxLQUFQLEdBQWV1QixjQUEvQjtBQUNBQyxPQUFLLENBQUNkLEtBQU4sQ0FBWWlCLENBQVosR0FBZ0J4QixNQUFNLENBQUNELE1BQVAsR0FBZ0JxQixjQUFoQztBQUNBLFNBQU9ULEtBQVA7QUFDSCIsImZpbGUiOiIuL2NvbXBvbmVudHMvZ2FtZUZ1bmRhbG1lbnRhbHMvbmFtZXRhZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcblxuZXhwb3J0IGZ1bmN0aW9uIENyZWF0ZVRhZyhiYXNlV2lkdGgsIHNpemUsIG5hbWUpIHtcbiAgICBjb25zdCBib3JkZXJTaXplID0gMjtcbiAgICBjb25zdCBjdHggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgY29uc3QgZm9udCA9IGAke3NpemV9cHggVmVyZGFuYWA7XG4gICAgY3R4LmZvbnQgPSBmb250O1xuICAgIC8vIG1lYXN1cmUgaG93IGxvbmcgdGhlIG5hbWUgd2lsbCBiZVxuICAgIGNvbnN0IHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChuYW1lKS53aWR0aDtcblxuICAgIGNvbnN0IGRvdWJsZUJvcmRlclNpemUgPSBib3JkZXJTaXplICogMjtcbiAgICBjb25zdCB3aWR0aCA9IGJhc2VXaWR0aCArIGRvdWJsZUJvcmRlclNpemU7XG4gICAgY29uc3QgaGVpZ2h0ID0gc2l6ZSArIGRvdWJsZUJvcmRlclNpemU7XG4gICAgY3R4LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGN0eC5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgLy8gbmVlZCB0byBzZXQgZm9udCBhZ2FpbiBhZnRlciByZXNpemluZyBjYW52YXNcbiAgICBjdHguZm9udCA9IGZvbnQ7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblxuICAgIC8vY3R4LmZpbGxTdHlsZSA9ICdibHVlJztcbiAgICAvL2N0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIC8vIHNjYWxlIHRvIGZpdCBidXQgZG9uJ3Qgc3RyZXRjaFxuICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gTWF0aC5taW4oMSwgYmFzZVdpZHRoIC8gdGV4dFdpZHRoKTtcbiAgICBjdHgudHJhbnNsYXRlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgY3R4LnNjYWxlKHNjYWxlRmFjdG9yLCAxKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFRleHQobmFtZSwgMCwgMCk7XG5cbiAgICByZXR1cm4gY3R4LmNhbnZhcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEdlbmVyYXRlTGFiZWwobmFtZSwgZ3JvdXApIHtcbiAgICBjb25zdCBjYW52YXMgPSBDcmVhdGVUYWcoMzAwLCAzMiwgbmFtZSk7XG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUSFJFRS5DYW52YXNUZXh0dXJlKGNhbnZhcyk7XG4gICAgLy8gYmVjYXVzZSBvdXIgY2FudmFzIGlzIGxpa2VseSBub3QgYSBwb3dlciBvZiAyXG4gICAgLy8gaW4gYm90aCBkaW1lbnNpb25zIHNldCB0aGUgZmlsdGVyaW5nIGFwcHJvcHJpYXRlbHkuXG4gICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG4gICAgdGV4dHVyZS53cmFwUyA9IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG4gICAgdGV4dHVyZS53cmFwVCA9IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cbiAgICBjb25zdCBsYWJlbE1hdGVyaWFsID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHtcbiAgICAgICAgbWFwOiB0ZXh0dXJlLFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICB9KTtcbiAgICAvLyBpZiB1bml0cyBhcmUgbWV0ZXJzIHRoZW4gMC4wMSBoZXJlIG1ha2VzIHNpemVcbiAgICAvLyBvZiB0aGUgbGFiZWwgaW50byBjZW50aW1ldGVycy5cbiAgICBjb25zdCBsYWJlbEJhc2VTY2FsZSA9IDAuMDE7XG5cbiAgICBjb25zdCBsYWJlbCA9IG5ldyBUSFJFRS5TcHJpdGUobGFiZWxNYXRlcmlhbCk7XG4gICAgZ3JvdXAuYWRkKGxhYmVsKTtcbiAgICBsYWJlbC5wb3NpdGlvbi55ID0gMVxuXG4gICAgbGFiZWwuc2NhbGUueCA9IGNhbnZhcy53aWR0aCAqIGxhYmVsQmFzZVNjYWxlO1xuICAgIGxhYmVsLnNjYWxlLnkgPSBjYW52YXMuaGVpZ2h0ICogbGFiZWxCYXNlU2NhbGU7XG4gICAgcmV0dXJuIGdyb3VwXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/gameFundalmentals/nametag.js\n");

/***/ }),

/***/ "./components/gameFundalmentals/rotateAroundPoint.js":
/*!***********************************************************!*\
  !*** ./components/gameFundalmentals/rotateAroundPoint.js ***!
  \***********************************************************/
/*! exports provided: rotateAboutPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateAboutPoint\", function() { return rotateAboutPoint; });\nfunction rotateAboutPoint(obj, point, axis, theta, pointIsWorld) {\n  pointIsWorld = pointIsWorld === undefined ? false : pointIsWorld;\n\n  if (pointIsWorld) {\n    obj.parent.localToWorld(obj.position);\n  }\n\n  obj.position.sub(point);\n  obj.position.applyAxisAngle(axis, theta);\n  obj.position.add(point);\n\n  if (pointIsWorld) {\n    obj.parent.worldToLocal(obj.position);\n  }\n\n  obj.rotateOnAxis(axis, theta);\n  return theta;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2dhbWVGdW5kYWxtZW50YWxzL3JvdGF0ZUFyb3VuZFBvaW50LmpzP2NhOTYiXSwibmFtZXMiOlsicm90YXRlQWJvdXRQb2ludCIsIm9iaiIsInBvaW50IiwiYXhpcyIsInRoZXRhIiwicG9pbnRJc1dvcmxkIiwidW5kZWZpbmVkIiwicGFyZW50IiwibG9jYWxUb1dvcmxkIiwicG9zaXRpb24iLCJzdWIiLCJhcHBseUF4aXNBbmdsZSIsImFkZCIsIndvcmxkVG9Mb2NhbCIsInJvdGF0ZU9uQXhpcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFPLFNBQVNBLGdCQUFULENBQTBCQyxHQUExQixFQUErQkMsS0FBL0IsRUFBc0NDLElBQXRDLEVBQTRDQyxLQUE1QyxFQUFtREMsWUFBbkQsRUFBaUU7QUFDcEVBLGNBQVksR0FBSUEsWUFBWSxLQUFLQyxTQUFsQixHQUErQixLQUEvQixHQUF1Q0QsWUFBdEQ7O0FBRUEsTUFBSUEsWUFBSixFQUFrQjtBQUNkSixPQUFHLENBQUNNLE1BQUosQ0FBV0MsWUFBWCxDQUF3QlAsR0FBRyxDQUFDUSxRQUE1QjtBQUNIOztBQUVEUixLQUFHLENBQUNRLFFBQUosQ0FBYUMsR0FBYixDQUFpQlIsS0FBakI7QUFDQUQsS0FBRyxDQUFDUSxRQUFKLENBQWFFLGNBQWIsQ0FBNEJSLElBQTVCLEVBQWtDQyxLQUFsQztBQUNBSCxLQUFHLENBQUNRLFFBQUosQ0FBYUcsR0FBYixDQUFpQlYsS0FBakI7O0FBRUEsTUFBSUcsWUFBSixFQUFrQjtBQUNkSixPQUFHLENBQUNNLE1BQUosQ0FBV00sWUFBWCxDQUF3QlosR0FBRyxDQUFDUSxRQUE1QjtBQUNIOztBQUVEUixLQUFHLENBQUNhLFlBQUosQ0FBaUJYLElBQWpCLEVBQXVCQyxLQUF2QjtBQUNBLFNBQU9BLEtBQVA7QUFDSCIsImZpbGUiOiIuL2NvbXBvbmVudHMvZ2FtZUZ1bmRhbG1lbnRhbHMvcm90YXRlQXJvdW5kUG9pbnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gcm90YXRlQWJvdXRQb2ludChvYmosIHBvaW50LCBheGlzLCB0aGV0YSwgcG9pbnRJc1dvcmxkKSB7XG4gICAgcG9pbnRJc1dvcmxkID0gKHBvaW50SXNXb3JsZCA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogcG9pbnRJc1dvcmxkO1xuXG4gICAgaWYgKHBvaW50SXNXb3JsZCkge1xuICAgICAgICBvYmoucGFyZW50LmxvY2FsVG9Xb3JsZChvYmoucG9zaXRpb24pOyBcbiAgICB9XG5cbiAgICBvYmoucG9zaXRpb24uc3ViKHBvaW50KTsgXG4gICAgb2JqLnBvc2l0aW9uLmFwcGx5QXhpc0FuZ2xlKGF4aXMsIHRoZXRhKTtcbiAgICBvYmoucG9zaXRpb24uYWRkKHBvaW50KTsgXG5cbiAgICBpZiAocG9pbnRJc1dvcmxkKSB7XG4gICAgICAgIG9iai5wYXJlbnQud29ybGRUb0xvY2FsKG9iai5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgb2JqLnJvdGF0ZU9uQXhpcyhheGlzLCB0aGV0YSk7XG4gICAgcmV0dXJuIHRoZXRhXG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/gameFundalmentals/rotateAroundPoint.js\n");

/***/ }),

/***/ "./components/gameFundalmentals/stars.js":
/*!***********************************************!*\
  !*** ./components/gameFundalmentals/stars.js ***!
  \***********************************************/
/*! exports provided: getRandomStarField */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRandomStarField\", function() { return getRandomStarField; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction getRandomStarField(numberOfStars, width, height) {\n  var canvas = document.createElement('CANVAS');\n  canvas.width = width;\n  canvas.height = height;\n  var ctx = canvas.getContext('2d');\n  ctx.fillStyle = \"black\"; //ctx.globalAlpha = 1\n\n  ctx.fillRect(0, 0, width, height);\n\n  for (var i = 0; i < numberOfStars; ++i) {\n    var radius = Math.random() * 2;\n    var x = Math.floor(Math.random() * width);\n    var y = Math.floor(Math.random() * height);\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, 2 * Math.PI, false);\n    ctx.fillStyle = 'white';\n    ctx.fill();\n  }\n\n  var texture = new three__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"](canvas);\n  texture.needsUpdate = true;\n  return texture;\n}\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3N0YXJzLmpzPzc3OWMiXSwibmFtZXMiOlsiZ2V0UmFuZG9tU3RhckZpZWxkIiwibnVtYmVyT2ZTdGFycyIsIndpZHRoIiwiaGVpZ2h0IiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiaSIsInJhZGl1cyIsIk1hdGgiLCJyYW5kb20iLCJ4IiwiZmxvb3IiLCJ5IiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJmaWxsIiwidGV4dHVyZSIsIlRIUkVFIiwibmVlZHNVcGRhdGUiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDTyxTQUFTQSxrQkFBVCxDQUE0QkMsYUFBNUIsRUFBMkNDLEtBQTNDLEVBQWtEQyxNQUFsRCxFQUEwRDtBQUM3RCxNQUFJQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixRQUF2QixDQUFiO0FBRUhGLFFBQU0sQ0FBQ0YsS0FBUCxHQUFlQSxLQUFmO0FBQ0FFLFFBQU0sQ0FBQ0QsTUFBUCxHQUFnQkEsTUFBaEI7QUFFQSxNQUFJSSxHQUFHLEdBQUdILE1BQU0sQ0FBQ0ksVUFBUCxDQUFrQixJQUFsQixDQUFWO0FBRUFELEtBQUcsQ0FBQ0UsU0FBSixHQUFjLE9BQWQsQ0FSZ0UsQ0FTaEU7O0FBQ0FGLEtBQUcsQ0FBQ0csUUFBSixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUJSLEtBQW5CLEVBQTBCQyxNQUExQjs7QUFFQSxPQUFLLElBQUlRLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdWLGFBQXBCLEVBQW1DLEVBQUVVLENBQXJDLEVBQXdDO0FBQ3ZDLFFBQUlDLE1BQU0sR0FBR0MsSUFBSSxDQUFDQyxNQUFMLEtBQWdCLENBQTdCO0FBQ0EsUUFBSUMsQ0FBQyxHQUFHRixJQUFJLENBQUNHLEtBQUwsQ0FBV0gsSUFBSSxDQUFDQyxNQUFMLEtBQWdCWixLQUEzQixDQUFSO0FBQ0EsUUFBSWUsQ0FBQyxHQUFHSixJQUFJLENBQUNHLEtBQUwsQ0FBV0gsSUFBSSxDQUFDQyxNQUFMLEtBQWdCWCxNQUEzQixDQUFSO0FBRUFJLE9BQUcsQ0FBQ1csU0FBSjtBQUNBWCxPQUFHLENBQUNZLEdBQUosQ0FBUUosQ0FBUixFQUFXRSxDQUFYLEVBQWNMLE1BQWQsRUFBc0IsQ0FBdEIsRUFBeUIsSUFBSUMsSUFBSSxDQUFDTyxFQUFsQyxFQUFzQyxLQUF0QztBQUNBYixPQUFHLENBQUNFLFNBQUosR0FBZ0IsT0FBaEI7QUFDQUYsT0FBRyxDQUFDYyxJQUFKO0FBQ0E7O0FBRUQsTUFBSUMsT0FBTyxHQUFHLElBQUlDLDZDQUFKLENBQWtCbkIsTUFBbEIsQ0FBZDtBQUNBa0IsU0FBTyxDQUFDRSxXQUFSLEdBQXNCLElBQXRCO0FBQ0EsU0FBT0YsT0FBUDtBQUNBO0FBQUEiLCJmaWxlIjoiLi9jb21wb25lbnRzL2dhbWVGdW5kYWxtZW50YWxzL3N0YXJzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmRvbVN0YXJGaWVsZChudW1iZXJPZlN0YXJzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0NBTlZBUycpO1xuXG5cdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRjdHguZmlsbFN0eWxlPVwiYmxhY2tcIjtcblx0Ly9jdHguZ2xvYmFsQWxwaGEgPSAxXG5cdGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mU3RhcnM7ICsraSkge1xuXHRcdHZhciByYWRpdXMgPSBNYXRoLnJhbmRvbSgpICogMjtcblx0XHR2YXIgeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHdpZHRoKTtcblx0XHR2YXIgeSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGhlaWdodCk7XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG5cdFx0Y3R4LmZpbGwoKTtcblx0fVxuXG5cdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoY2FudmFzKTtcblx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdHJldHVybiB0ZXh0dXJlO1xufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/gameFundalmentals/stars.js\n");

/***/ }),

/***/ "./components/gameUI/gameFeed.js":
/*!***************************************!*\
  !*** ./components/gameUI/gameFeed.js ***!
  \***************************************/
/*! exports provided: CreateUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CreateUI\", function() { return CreateUI; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Core_API_ConnectAPI__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Core-API/ConnectAPI */ \"./components/Core-API/ConnectAPI.js\");\n/* harmony import */ var _gameFundalmentals_multiplayer_MainPlayerHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gameFundalmentals/multiplayer/MainPlayerHandler */ \"./components/gameFundalmentals/multiplayer/MainPlayerHandler.js\");\n\nvar _jsxFileName = \"/Users/year12/Desktop/Harvey/alevel_2020-2021/components/gameUI/gameFeed.js\";\n\n\n\nfunction CreateUI() {\n  let {\n    0: gamefeed,\n    1: setGameFeed\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])();\n  Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(() => {\n    Object(_Core_API_ConnectAPI__WEBPACK_IMPORTED_MODULE_2__[\"ListenToEvent\"])('NewPlayer', (id, data) => {\n      console.log(data);\n      console.log(\"New PLyer \" + id);\n      let cube = Object(_gameFundalmentals_multiplayer_MainPlayerHandler__WEBPACK_IMPORTED_MODULE_3__[\"MakeNewCubePlayer\"])(data.color, data.name); //MakeNewCubePlayer(data?.name, \"Joined the game!\")\n\n      players[id] = cube;\n    });\n  }, []);\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"h1\", {\n    children: \"Hello\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 18,\n    columnNumber: 9\n  }, this);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2dhbWVVSS9nYW1lRmVlZC5qcz9iNWRlIl0sIm5hbWVzIjpbIkNyZWF0ZVVJIiwiZ2FtZWZlZWQiLCJzZXRHYW1lRmVlZCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiTGlzdGVuVG9FdmVudCIsImlkIiwiZGF0YSIsImNvbnNvbGUiLCJsb2ciLCJjdWJlIiwiTWFrZU5ld0N1YmVQbGF5ZXIiLCJjb2xvciIsIm5hbWUiLCJwbGF5ZXJzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBRU8sU0FBU0EsUUFBVCxHQUFvQjtBQUN2QixNQUFJO0FBQUEsT0FBQ0MsUUFBRDtBQUFBLE9BQVdDO0FBQVgsTUFBMEJDLHNEQUFRLEVBQXRDO0FBQ0FDLHlEQUFTLENBQUMsTUFBTTtBQUNaQyw4RUFBYSxDQUFDLFdBQUQsRUFBYyxDQUFDQyxFQUFELEVBQUtDLElBQUwsS0FBYztBQUNyQ0MsYUFBTyxDQUFDQyxHQUFSLENBQVlGLElBQVo7QUFDQUMsYUFBTyxDQUFDQyxHQUFSLENBQVksZUFBZUgsRUFBM0I7QUFDQSxVQUFJSSxJQUFJLEdBQUdDLDBHQUFpQixDQUFDSixJQUFJLENBQUNLLEtBQU4sRUFBYUwsSUFBSSxDQUFDTSxJQUFsQixDQUE1QixDQUhxQyxDQUlyQzs7QUFFQUMsYUFBTyxDQUFDUixFQUFELENBQVAsR0FBY0ksSUFBZDtBQUNILEtBUFksQ0FBYjtBQVFILEdBVFEsRUFTTixFQVRNLENBQVQ7QUFVQSxzQkFDSTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQURKO0FBR0giLCJmaWxlIjoiLi9jb21wb25lbnRzL2dhbWVVSS9nYW1lRmVlZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgTGlzdGVuVG9FdmVudCB9IGZyb20gXCIuLi9Db3JlLUFQSS9Db25uZWN0QVBJXCJcbmltcG9ydCB7IE1ha2VOZXdDdWJlUGxheWVyIH0gZnJvbSBcIi4uL2dhbWVGdW5kYWxtZW50YWxzL211bHRpcGxheWVyL01haW5QbGF5ZXJIYW5kbGVyXCJcblxuZXhwb3J0IGZ1bmN0aW9uIENyZWF0ZVVJKCkge1xuICAgIGxldCBbZ2FtZWZlZWQsIHNldEdhbWVGZWVkXSA9IHVzZVN0YXRlKClcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBMaXN0ZW5Ub0V2ZW50KCdOZXdQbGF5ZXInLCAoaWQsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5ldyBQTHllciBcIiArIGlkKVxuICAgICAgICAgICAgbGV0IGN1YmUgPSBNYWtlTmV3Q3ViZVBsYXllcihkYXRhLmNvbG9yLCBkYXRhLm5hbWUpXG4gICAgICAgICAgICAvL01ha2VOZXdDdWJlUGxheWVyKGRhdGE/Lm5hbWUsIFwiSm9pbmVkIHRoZSBnYW1lIVwiKVxuXG4gICAgICAgICAgICBwbGF5ZXJzW2lkXSA9IGN1YmVcbiAgICAgICAgfSlcbiAgICB9LCBbXSlcbiAgICByZXR1cm4gKFxuICAgICAgICA8aDE+SGVsbG88L2gxPlxuICAgIClcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/gameUI/gameFeed.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/annotate.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/annotate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"@hapi/hoek/lib/clone\");\n\nconst Common = __webpack_require__(/*! ./common */ \"./node_modules/joi/lib/common.js\");\n\n\nconst internals = {\n    annotations: Symbol('annotations')\n};\n\n\nexports.error = function (stripColorCodes) {\n\n    if (!this._original ||\n        typeof this._original !== 'object') {\n\n        return this.details[0].message;\n    }\n\n    const redFgEscape = stripColorCodes ? '' : '\\u001b[31m';\n    const redBgEscape = stripColorCodes ? '' : '\\u001b[41m';\n    const endColor = stripColorCodes ? '' : '\\u001b[0m';\n\n    const obj = Clone(this._original);\n\n    for (let i = this.details.length - 1; i >= 0; --i) {        // Reverse order to process deepest child first\n        const pos = i + 1;\n        const error = this.details[i];\n        const path = error.path;\n        let node = obj;\n        for (let j = 0; ; ++j) {\n            const seg = path[j];\n\n            if (Common.isSchema(node)) {\n                node = node.clone();                              // joi schemas are not cloned by hoek, we have to take this extra step\n            }\n\n            if (j + 1 < path.length &&\n                typeof node[seg] !== 'string') {\n\n                node = node[seg];\n            }\n            else {\n                const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };\n                node[internals.annotations] = refAnnotations;\n\n                const cacheKey = seg || error.context.key;\n\n                if (node[seg] !== undefined) {\n                    refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];\n                    refAnnotations.errors[cacheKey].push(pos);\n                }\n                else {\n                    refAnnotations.missing[cacheKey] = pos;\n                }\n\n                break;\n            }\n        }\n    }\n\n    const replacers = {\n        key: /_\\$key\\$_([, \\d]+)_\\$end\\$_\"/g,\n        missing: /\"_\\$miss\\$_([^|]+)\\|(\\d+)_\\$end\\$_\": \"__missing__\"/g,\n        arrayIndex: /\\s*\"_\\$idx\\$_([, \\d]+)_\\$end\\$_\",?\\n(.*)/g,\n        specials: /\"\\[(NaN|Symbol.*|-?Infinity|function.*|\\(.*)]\"/g\n    };\n\n    let message = internals.safeStringify(obj, 2)\n        .replace(replacers.key, ($0, $1) => `\" ${redFgEscape}[${$1}]${endColor}`)\n        .replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}\"${$1}\"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`)\n        .replace(replacers.arrayIndex, ($0, $1, $2) => `\\n${$2} ${redFgEscape}[${$1}]${endColor}`)\n        .replace(replacers.specials, ($0, $1) => $1);\n\n    message = `${message}\\n${redFgEscape}`;\n\n    for (let i = 0; i < this.details.length; ++i) {\n        const pos = i + 1;\n        message = `${message}\\n[${pos}] ${this.details[i].message}`;\n    }\n\n    message = message + endColor;\n\n    return message;\n};\n\n\n// Inspired by json-stringify-safe\n\ninternals.safeStringify = function (obj, spaces) {\n\n    return JSON.stringify(obj, internals.serializer(), spaces);\n};\n\n\ninternals.serializer = function () {\n\n    const keys = [];\n    const stack = [];\n\n    const cycleReplacer = (key, value) => {\n\n        if (stack[0] === value) {\n            return '[Circular ~]';\n        }\n\n        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';\n    };\n\n    return function (key, value) {\n\n        if (stack.length > 0) {\n            const thisPos = stack.indexOf(this);\n            if (~thisPos) {\n                stack.length = thisPos + 1;\n                keys.length = thisPos + 1;\n                keys[thisPos] = key;\n            }\n            else {\n                stack.push(this);\n                keys.push(key);\n            }\n\n            if (~stack.indexOf(value)) {\n                value = cycleReplacer.call(this, key, value);\n            }\n        }\n        else {\n            stack.push(value);\n        }\n\n        if (value) {\n            const annotations = value[internals.annotations];\n            if (annotations) {\n                if (Array.isArray(value)) {\n                    const annotated = [];\n\n                    for (let i = 0; i < value.length; ++i) {\n                        if (annotations.errors[i]) {\n                            annotated.push(`_$idx$_${annotations.errors[i].sort().join(', ')}_$end$_`);\n                        }\n\n                        annotated.push(value[i]);\n                    }\n\n                    value = annotated;\n                }\n                else {\n                    for (const errorKey in annotations.errors) {\n                        value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(', ')}_$end$_`] = value[errorKey];\n                        value[errorKey] = undefined;\n                    }\n\n                    for (const missingKey in annotations.missing) {\n                        value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = '__missing__';\n                    }\n                }\n\n                return value;\n            }\n        }\n\n        if (value === Infinity ||\n            value === -Infinity ||\n            Number.isNaN(value) ||\n            typeof value === 'function' ||\n            typeof value === 'symbol') {\n\n            return '[' + value.toString() + ']';\n        }\n\n        return value;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9hbm5vdGF0ZS5qcz84NGU1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxrREFBc0I7O0FBRTVDLGVBQWUsbUJBQU8sQ0FBQyxrREFBVTs7O0FBR2pDO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUSxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUU7QUFDekI7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsV0FBVyxhQUFhO0FBQy9GOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxZQUFZLEdBQUcsR0FBRyxHQUFHLFNBQVM7QUFDL0UsdURBQXVELFlBQVksR0FBRyxHQUFHLEdBQUcsU0FBUyxFQUFFLFlBQVksSUFBSSxHQUFHLGtCQUFrQixTQUFTO0FBQ3JJLDREQUE0RCxHQUFHLEdBQUcsWUFBWSxHQUFHLEdBQUcsR0FBRyxTQUFTO0FBQ2hHOztBQUVBLGlCQUFpQixRQUFRLElBQUksWUFBWTs7QUFFekMsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBLHFCQUFxQixRQUFRLEtBQUssSUFBSSxJQUFJLHdCQUF3QjtBQUNsRTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0EscURBQXFELHdDQUF3QztBQUM3Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVMsU0FBUywrQ0FBK0M7QUFDbEc7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxXQUFXLEdBQUcsZ0NBQWdDO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvam9pL2xpYi9hbm5vdGF0ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBhbm5vdGF0aW9uczogU3ltYm9sKCdhbm5vdGF0aW9ucycpXG59O1xuXG5cbmV4cG9ydHMuZXJyb3IgPSBmdW5jdGlvbiAoc3RyaXBDb2xvckNvZGVzKSB7XG5cbiAgICBpZiAoIXRoaXMuX29yaWdpbmFsIHx8XG4gICAgICAgIHR5cGVvZiB0aGlzLl9vcmlnaW5hbCAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kZXRhaWxzWzBdLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgY29uc3QgcmVkRmdFc2NhcGUgPSBzdHJpcENvbG9yQ29kZXMgPyAnJyA6ICdcXHUwMDFiWzMxbSc7XG4gICAgY29uc3QgcmVkQmdFc2NhcGUgPSBzdHJpcENvbG9yQ29kZXMgPyAnJyA6ICdcXHUwMDFiWzQxbSc7XG4gICAgY29uc3QgZW5kQ29sb3IgPSBzdHJpcENvbG9yQ29kZXMgPyAnJyA6ICdcXHUwMDFiWzBtJztcblxuICAgIGNvbnN0IG9iaiA9IENsb25lKHRoaXMuX29yaWdpbmFsKTtcblxuICAgIGZvciAobGV0IGkgPSB0aGlzLmRldGFpbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgICAgICAgIC8vIFJldmVyc2Ugb3JkZXIgdG8gcHJvY2VzcyBkZWVwZXN0IGNoaWxkIGZpcnN0XG4gICAgICAgIGNvbnN0IHBvcyA9IGkgKyAxO1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuZGV0YWlsc1tpXTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGVycm9yLnBhdGg7XG4gICAgICAgIGxldCBub2RlID0gb2JqO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZyA9IHBhdGhbal07XG5cbiAgICAgICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jbG9uZSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGpvaSBzY2hlbWFzIGFyZSBub3QgY2xvbmVkIGJ5IGhvZWssIHdlIGhhdmUgdG8gdGFrZSB0aGlzIGV4dHJhIHN0ZXBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGogKyAxIDwgcGF0aC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZVtzZWddICE9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVbc2VnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZkFubm90YXRpb25zID0gbm9kZVtpbnRlcm5hbHMuYW5ub3RhdGlvbnNdIHx8IHsgZXJyb3JzOiB7fSwgbWlzc2luZzoge30gfTtcbiAgICAgICAgICAgICAgICBub2RlW2ludGVybmFscy5hbm5vdGF0aW9uc10gPSByZWZBbm5vdGF0aW9ucztcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2VnIHx8IGVycm9yLmNvbnRleHQua2V5O1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVbc2VnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0gPSByZWZBbm5vdGF0aW9ucy5lcnJvcnNbY2FjaGVLZXldIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICByZWZBbm5vdGF0aW9ucy5lcnJvcnNbY2FjaGVLZXldLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLm1pc3NpbmdbY2FjaGVLZXldID0gcG9zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVwbGFjZXJzID0ge1xuICAgICAgICBrZXk6IC9fXFwka2V5XFwkXyhbLCBcXGRdKylfXFwkZW5kXFwkX1wiL2csXG4gICAgICAgIG1pc3Npbmc6IC9cIl9cXCRtaXNzXFwkXyhbXnxdKylcXHwoXFxkKylfXFwkZW5kXFwkX1wiOiBcIl9fbWlzc2luZ19fXCIvZyxcbiAgICAgICAgYXJyYXlJbmRleDogL1xccypcIl9cXCRpZHhcXCRfKFssIFxcZF0rKV9cXCRlbmRcXCRfXCIsP1xcbiguKikvZyxcbiAgICAgICAgc3BlY2lhbHM6IC9cIlxcWyhOYU58U3ltYm9sLip8LT9JbmZpbml0eXxmdW5jdGlvbi4qfFxcKC4qKV1cIi9nXG4gICAgfTtcblxuICAgIGxldCBtZXNzYWdlID0gaW50ZXJuYWxzLnNhZmVTdHJpbmdpZnkob2JqLCAyKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMua2V5LCAoJDAsICQxKSA9PiBgXCIgJHtyZWRGZ0VzY2FwZX1bJHskMX1dJHtlbmRDb2xvcn1gKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMubWlzc2luZywgKCQwLCAkMSwgJDIpID0+IGAke3JlZEJnRXNjYXBlfVwiJHskMX1cIiR7ZW5kQ29sb3J9JHtyZWRGZ0VzY2FwZX0gWyR7JDJ9XTogLS0gbWlzc2luZyAtLSR7ZW5kQ29sb3J9YClcbiAgICAgICAgLnJlcGxhY2UocmVwbGFjZXJzLmFycmF5SW5kZXgsICgkMCwgJDEsICQyKSA9PiBgXFxuJHskMn0gJHtyZWRGZ0VzY2FwZX1bJHskMX1dJHtlbmRDb2xvcn1gKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMuc3BlY2lhbHMsICgkMCwgJDEpID0+ICQxKTtcblxuICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcbiR7cmVkRmdFc2NhcGV9YDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZXRhaWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGkgKyAxO1xuICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX1cXG5bJHtwb3N9XSAke3RoaXMuZGV0YWlsc1tpXS5tZXNzYWdlfWA7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgKyBlbmRDb2xvcjtcblxuICAgIHJldHVybiBtZXNzYWdlO1xufTtcblxuXG4vLyBJbnNwaXJlZCBieSBqc29uLXN0cmluZ2lmeS1zYWZlXG5cbmludGVybmFscy5zYWZlU3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaiwgc3BhY2VzKSB7XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBpbnRlcm5hbHMuc2VyaWFsaXplcigpLCBzcGFjZXMpO1xufTtcblxuXG5pbnRlcm5hbHMuc2VyaWFsaXplciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuXG4gICAgY29uc3QgY3ljbGVSZXBsYWNlciA9IChrZXksIHZhbHVlKSA9PiB7XG5cbiAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXIgfl0nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXIgfi4nICsga2V5cy5zbGljZSgwLCBzdGFjay5pbmRleE9mKHZhbHVlKSkuam9pbignLicpICsgJ10nO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdGhpc1BvcyA9IHN0YWNrLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgICBpZiAofnRoaXNQb3MpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5sZW5ndGggPSB0aGlzUG9zICsgMTtcbiAgICAgICAgICAgICAgICBrZXlzLmxlbmd0aCA9IHRoaXNQb3MgKyAxO1xuICAgICAgICAgICAgICAgIGtleXNbdGhpc1Bvc10gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjeWNsZVJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSB2YWx1ZVtpbnRlcm5hbHMuYW5ub3RhdGlvbnNdO1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRlZCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5lcnJvcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWQucHVzaChgXyRpZHgkXyR7YW5ub3RhdGlvbnMuZXJyb3JzW2ldLnNvcnQoKS5qb2luKCcsICcpfV8kZW5kJF9gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVkLnB1c2godmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhbm5vdGF0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVycm9yS2V5IGluIGFubm90YXRpb25zLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbYCR7ZXJyb3JLZXl9XyRrZXkkXyR7YW5ub3RhdGlvbnMuZXJyb3JzW2Vycm9yS2V5XS5zb3J0KCkuam9pbignLCAnKX1fJGVuZCRfYF0gPSB2YWx1ZVtlcnJvcktleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtlcnJvcktleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1pc3NpbmdLZXkgaW4gYW5ub3RhdGlvbnMubWlzc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbYF8kbWlzcyRfJHttaXNzaW5nS2V5fXwke2Fubm90YXRpb25zLm1pc3NpbmdbbWlzc2luZ0tleV19XyRlbmQkX2BdID0gJ19fbWlzc2luZ19fJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSAtSW5maW5pdHkgfHxcbiAgICAgICAgICAgIE51bWJlci5pc05hTih2YWx1ZSkgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXG4gICAgICAgICAgICByZXR1cm4gJ1snICsgdmFsdWUudG9TdHJpbmcoKSArICddJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/annotate.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/base.js":
/*!**************************************!*\
  !*** ./node_modules/joi/lib/base.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"@hapi/hoek/lib/clone\");\nconst DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ \"@hapi/hoek/lib/deepEqual\");\nconst Merge = __webpack_require__(/*! @hapi/hoek/lib/merge */ \"@hapi/hoek/lib/merge\");\n\nconst Cache = __webpack_require__(/*! ./cache */ \"./node_modules/joi/lib/cache.js\");\nconst Common = __webpack_require__(/*! ./common */ \"./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ./compile */ \"./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"./node_modules/joi/lib/errors.js\");\nconst Extend = __webpack_require__(/*! ./extend */ \"./node_modules/joi/lib/extend.js\");\nconst Manifest = __webpack_require__(/*! ./manifest */ \"./node_modules/joi/lib/manifest.js\");\nconst Messages = __webpack_require__(/*! ./messages */ \"./node_modules/joi/lib/messages.js\");\nconst Modify = __webpack_require__(/*! ./modify */ \"./node_modules/joi/lib/modify.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"./node_modules/joi/lib/ref.js\");\nconst Trace = __webpack_require__(/*! ./trace */ \"./node_modules/joi/lib/trace.js\");\nconst Validator = __webpack_require__(/*! ./validator */ \"./node_modules/joi/lib/validator.js\");\nconst Values = __webpack_require__(/*! ./values */ \"./node_modules/joi/lib/values.js\");\n\n\nconst internals = {};\n\n\ninternals.Base = class {\n\n    constructor(type) {\n\n        // Naming: public, _private, $_extension, $_mutate{action}\n\n        this.type = type;\n\n        this.$_root = null;\n        this._definition = {};\n        this._reset();\n    }\n\n    _reset() {\n\n        this._ids = new Modify.Ids();\n        this._preferences = null;\n        this._refs = new Ref.Manager();\n        this._cache = null;\n\n        this._valids = null;\n        this._invalids = null;\n\n        this._flags = {};\n        this._rules = [];\n        this._singleRules = new Map();              // The rule options passed for non-multi rules\n\n        this.$_terms = {};                          // Hash of arrays of immutable objects (extended by other types)\n\n        this.$_temp = {                             // Runtime state (not cloned)\n            ruleset: null,                          // null: use last, false: error, number: start position\n            whens: {}                               // Runtime cache of generated whens\n        };\n    }\n\n    // Manifest\n\n    describe() {\n\n        Assert(typeof Manifest.describe === 'function', 'Manifest functionality disabled');\n        return Manifest.describe(this);\n    }\n\n    // Rules\n\n    allow(...values) {\n\n        Common.verifyFlat(values, 'allow');\n        return this._values(values, '_valids');\n    }\n\n    alter(targets) {\n\n        Assert(targets && typeof targets === 'object' && !Array.isArray(targets), 'Invalid targets argument');\n        Assert(!this._inRuleset(), 'Cannot set alterations inside a ruleset');\n\n        const obj = this.clone();\n        obj.$_terms.alterations = obj.$_terms.alterations || [];\n        for (const target in targets) {\n            const adjuster = targets[target];\n            Assert(typeof adjuster === 'function', 'Alteration adjuster for', target, 'must be a function');\n            obj.$_terms.alterations.push({ target, adjuster });\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    artifact(id) {\n\n        Assert(id !== undefined, 'Artifact cannot be undefined');\n        Assert(!this._cache, 'Cannot set an artifact with a rule cache');\n\n        return this.$_setFlag('artifact', id);\n    }\n\n    cast(to) {\n\n        Assert(to === false || typeof to === 'string', 'Invalid to value');\n        Assert(to === false || this._definition.cast[to], 'Type', this.type, 'does not support casting to', to);\n\n        return this.$_setFlag('cast', to === false ? undefined : to);\n    }\n\n    default(value, options) {\n\n        return this._default('default', value, options);\n    }\n\n    description(desc) {\n\n        Assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n\n        return this.$_setFlag('description', desc);\n    }\n\n    empty(schema) {\n\n        const obj = this.clone();\n\n        if (schema !== undefined) {\n            schema = obj.$_compile(schema, { override: false });\n        }\n\n        return obj.$_setFlag('empty', schema, { clone: false });\n    }\n\n    error(err) {\n\n        Assert(err, 'Missing error');\n        Assert(err instanceof Error || typeof err === 'function', 'Must provide a valid Error object or a function');\n\n        return this.$_setFlag('error', err);\n    }\n\n    example(example, options = {}) {\n\n        Assert(example !== undefined, 'Missing example');\n        Common.assertOptions(options, ['override']);\n\n        return this._inner('examples', example, { single: true, override: options.override });\n    }\n\n    external(method, description) {\n\n        if (typeof method === 'object') {\n            Assert(!description, 'Cannot combine options with description');\n            description = method.description;\n            method = method.method;\n        }\n\n        Assert(typeof method === 'function', 'Method must be a function');\n        Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');\n\n        return this._inner('externals', { method, description }, { single: true });\n    }\n\n    failover(value, options) {\n\n        return this._default('failover', value, options);\n    }\n\n    forbidden() {\n\n        return this.presence('forbidden');\n    }\n\n    id(id) {\n\n        if (!id) {\n            return this.$_setFlag('id', undefined);\n        }\n\n        Assert(typeof id === 'string', 'id must be a non-empty string');\n        Assert(/^[^\\.]+$/.test(id), 'id cannot contain period character');\n\n        return this.$_setFlag('id', id);\n    }\n\n    invalid(...values) {\n\n        return this._values(values, '_invalids');\n    }\n\n    label(name) {\n\n        Assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n\n        return this.$_setFlag('label', name);\n    }\n\n    meta(meta) {\n\n        Assert(meta !== undefined, 'Meta cannot be undefined');\n\n        return this._inner('metas', meta, { single: true });\n    }\n\n    note(...notes) {\n\n        Assert(notes.length, 'Missing notes');\n        for (const note of notes) {\n            Assert(note && typeof note === 'string', 'Notes must be non-empty strings');\n        }\n\n        return this._inner('notes', notes);\n    }\n\n    only(mode = true) {\n\n        Assert(typeof mode === 'boolean', 'Invalid mode:', mode);\n\n        return this.$_setFlag('only', mode);\n    }\n\n    optional() {\n\n        return this.presence('optional');\n    }\n\n    prefs(prefs) {\n\n        Assert(prefs, 'Missing preferences');\n        Assert(prefs.context === undefined, 'Cannot override context');\n        Assert(prefs.externals === undefined, 'Cannot override externals');\n        Assert(prefs.warnings === undefined, 'Cannot override warnings');\n        Assert(prefs.debug === undefined, 'Cannot override debug');\n\n        Common.checkPreferences(prefs);\n\n        const obj = this.clone();\n        obj._preferences = Common.preferences(obj._preferences, prefs);\n        return obj;\n    }\n\n    presence(mode) {\n\n        Assert(['optional', 'required', 'forbidden'].includes(mode), 'Unknown presence mode', mode);\n\n        return this.$_setFlag('presence', mode);\n    }\n\n    raw(enabled = true) {\n\n        return this.$_setFlag('result', enabled ? 'raw' : undefined);\n    }\n\n    result(mode) {\n\n        Assert(['raw', 'strip'].includes(mode), 'Unknown result mode', mode);\n\n        return this.$_setFlag('result', mode);\n    }\n\n    required() {\n\n        return this.presence('required');\n    }\n\n    strict(enabled) {\n\n        const obj = this.clone();\n\n        const convert = enabled === undefined ? false : !enabled;\n        obj._preferences = Common.preferences(obj._preferences, { convert });\n        return obj;\n    }\n\n    strip(enabled = true) {\n\n        return this.$_setFlag('result', enabled ? 'strip' : undefined);\n    }\n\n    tag(...tags) {\n\n        Assert(tags.length, 'Missing tags');\n        for (const tag of tags) {\n            Assert(tag && typeof tag === 'string', 'Tags must be non-empty strings');\n        }\n\n        return this._inner('tags', tags);\n    }\n\n    unit(name) {\n\n        Assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n\n        return this.$_setFlag('unit', name);\n    }\n\n    valid(...values) {\n\n        Common.verifyFlat(values, 'valid');\n\n        const obj = this.allow(...values);\n        obj.$_setFlag('only', !!obj._valids, { clone: false });\n        return obj;\n    }\n\n    when(condition, options) {\n\n        const obj = this.clone();\n\n        if (!obj.$_terms.whens) {\n            obj.$_terms.whens = [];\n        }\n\n        const when = Compile.when(obj, condition, options);\n        if (!['any', 'link'].includes(obj.type)) {\n            const conditions = when.is ? [when] : when.switch;\n            for (const item of conditions) {\n                Assert(!item.then || item.then.type === 'any' || item.then.type === obj.type, 'Cannot combine', obj.type, 'with', item.then && item.then.type);\n                Assert(!item.otherwise || item.otherwise.type === 'any' || item.otherwise.type === obj.type, 'Cannot combine', obj.type, 'with', item.otherwise && item.otherwise.type);\n\n            }\n        }\n\n        obj.$_terms.whens.push(when);\n        return obj.$_mutateRebuild();\n    }\n\n    // Helpers\n\n    cache(cache) {\n\n        Assert(!this._inRuleset(), 'Cannot set caching inside a ruleset');\n        Assert(!this._cache, 'Cannot override schema cache');\n        Assert(this._flags.artifact === undefined, 'Cannot cache a rule with an artifact');\n\n        const obj = this.clone();\n        obj._cache = cache || Cache.provider.provision();\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    clone() {\n\n        const obj = Object.create(Object.getPrototypeOf(this));\n        return this._assign(obj);\n    }\n\n    concat(source) {\n\n        Assert(Common.isSchema(source), 'Invalid schema object');\n        Assert(this.type === 'any' || source.type === 'any' || source.type === this.type, 'Cannot merge type', this.type, 'with another type:', source.type);\n        Assert(!this._inRuleset(), 'Cannot concatenate onto a schema with open ruleset');\n        Assert(!source._inRuleset(), 'Cannot concatenate a schema with open ruleset');\n\n        let obj = this.clone();\n\n        if (this.type === 'any' &&\n            source.type !== 'any') {\n\n            // Change obj to match source type\n\n            const tmpObj = source.clone();\n            for (const key of Object.keys(obj)) {\n                if (key !== 'type') {\n                    tmpObj[key] = obj[key];\n                }\n            }\n\n            obj = tmpObj;\n        }\n\n        obj._ids.concat(source._ids);\n        obj._refs.register(source, Ref.toSibling);\n\n        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;\n        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);\n        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);\n\n        // Remove unique rules present in source\n\n        for (const name of source._singleRules.keys()) {\n            if (obj._singleRules.has(name)) {\n                obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);\n                obj._singleRules.delete(name);\n            }\n        }\n\n        // Rules\n\n        for (const test of source._rules) {\n            if (!source._definition.rules[test.method].multi) {\n                obj._singleRules.set(test.name, test);\n            }\n\n            obj._rules.push(test);\n        }\n\n        // Flags\n\n        if (obj._flags.empty &&\n            source._flags.empty) {\n\n            obj._flags.empty = obj._flags.empty.concat(source._flags.empty);\n            const flags = Object.assign({}, source._flags);\n            delete flags.empty;\n            Merge(obj._flags, flags);\n        }\n        else if (source._flags.empty) {\n            obj._flags.empty = source._flags.empty;\n            const flags = Object.assign({}, source._flags);\n            delete flags.empty;\n            Merge(obj._flags, flags);\n        }\n        else {\n            Merge(obj._flags, source._flags);\n        }\n\n        // Terms\n\n        for (const key in source.$_terms) {\n            const terms = source.$_terms[key];\n            if (!terms) {\n                if (!obj.$_terms[key]) {\n                    obj.$_terms[key] = terms;\n                }\n\n                continue;\n            }\n\n            if (!obj.$_terms[key]) {\n                obj.$_terms[key] = terms.slice();\n                continue;\n            }\n\n            obj.$_terms[key] = obj.$_terms[key].concat(terms);\n        }\n\n        // Tracing\n\n        if (this.$_root._tracer) {\n            this.$_root._tracer._combine(obj, [this, source]);\n        }\n\n        // Rebuild\n\n        return obj.$_mutateRebuild();\n    }\n\n    extend(options) {\n\n        Assert(!options.base, 'Cannot extend type with another base');\n\n        return Extend.type(this, options);\n    }\n\n    extract(path) {\n\n        path = Array.isArray(path) ? path : path.split('.');\n        return this._ids.reach(path);\n    }\n\n    fork(paths, adjuster) {\n\n        Assert(!this._inRuleset(), 'Cannot fork inside a ruleset');\n\n        let obj = this;                                             // eslint-disable-line consistent-this\n        for (let path of [].concat(paths)) {\n            path = Array.isArray(path) ? path : path.split('.');\n            obj = obj._ids.fork(path, adjuster, obj);\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    rule(options) {\n\n        const def = this._definition;\n        Common.assertOptions(options, Object.keys(def.modifiers));\n\n        Assert(this.$_temp.ruleset !== false, 'Cannot apply rules to empty ruleset or the last rule added does not support rule properties');\n        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;\n        Assert(start >= 0 && start < this._rules.length, 'Cannot apply rules to empty ruleset');\n\n        const obj = this.clone();\n\n        for (let i = start; i < obj._rules.length; ++i) {\n            const original = obj._rules[i];\n            const rule = Clone(original);\n\n            for (const name in options) {\n                def.modifiers[name](rule, options[name]);\n                Assert(rule.name === original.name, 'Cannot change rule name');\n            }\n\n            obj._rules[i] = rule;\n\n            if (obj._singleRules.get(rule.name) === original) {\n                obj._singleRules.set(rule.name, rule);\n            }\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj.$_mutateRebuild();\n    }\n\n    get ruleset() {\n\n        Assert(!this._inRuleset(), 'Cannot start a new ruleset without closing the previous one');\n\n        const obj = this.clone();\n        obj.$_temp.ruleset = obj._rules.length;\n        return obj;\n    }\n\n    get $() {\n\n        return this.ruleset;\n    }\n\n    tailor(targets) {\n\n        targets = [].concat(targets);\n\n        Assert(!this._inRuleset(), 'Cannot tailor inside a ruleset');\n\n        let obj = this;                                                     // eslint-disable-line consistent-this\n\n        if (this.$_terms.alterations) {\n            for (const { target, adjuster } of this.$_terms.alterations) {\n                if (targets.includes(target)) {\n                    obj = adjuster(obj);\n                    Assert(Common.isSchema(obj), 'Alteration adjuster for', target, 'failed to return a schema object');\n                }\n            }\n        }\n\n        obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });\n        obj.$_temp.ruleset = false;\n        return obj.$_mutateRebuild();\n    }\n\n    tracer() {\n\n        return Trace.location ? Trace.location(this) : this;                // $lab:coverage:ignore$\n    }\n\n    validate(value, options) {\n\n        return Validator.entry(value, this, options);\n    }\n\n    validateAsync(value, options) {\n\n        return Validator.entryAsync(value, this, options);\n    }\n\n    // Extensions\n\n    $_addRule(options) {\n\n        // Normalize rule\n\n        if (typeof options === 'string') {\n            options = { name: options };\n        }\n\n        Assert(options && typeof options === 'object', 'Invalid options');\n        Assert(options.name && typeof options.name === 'string', 'Invalid rule name');\n\n        for (const key in options) {\n            Assert(key[0] !== '_', 'Cannot set private rule properties');\n        }\n\n        const rule = Object.assign({}, options);        // Shallow cloned\n        rule._resolve = [];\n        rule.method = rule.method || rule.name;\n\n        const definition = this._definition.rules[rule.method];\n        const args = rule.args;\n\n        Assert(definition, 'Unknown rule', rule.method);\n\n        // Args\n\n        const obj = this.clone();\n\n        if (args) {\n            Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, 'Invalid rule definition for', this.type, rule.name);\n\n            for (const key in args) {\n                let arg = args[key];\n                if (arg === undefined) {\n                    delete args[key];\n                    continue;\n                }\n\n                if (definition.argsByName) {\n                    const resolver = definition.argsByName.get(key);\n\n                    if (resolver.ref &&\n                        Common.isResolvable(arg)) {\n\n                        rule._resolve.push(key);\n                        obj.$_mutateRegister(arg);\n                    }\n                    else {\n                        if (resolver.normalize) {\n                            arg = resolver.normalize(arg);\n                            args[key] = arg;\n                        }\n\n                        if (resolver.assert) {\n                            const error = Common.validateArg(arg, key, resolver);\n                            Assert(!error, error, 'or reference');\n                        }\n                    }\n                }\n\n                args[key] = arg;\n            }\n        }\n\n        // Unique rules\n\n        if (!definition.multi) {\n            obj._ruleRemove(rule.name, { clone: false });\n            obj._singleRules.set(rule.name, rule);\n        }\n\n        if (obj.$_temp.ruleset === false) {\n            obj.$_temp.ruleset = null;\n        }\n\n        if (definition.priority) {\n            obj._rules.unshift(rule);\n        }\n        else {\n            obj._rules.push(rule);\n        }\n\n        return obj;\n    }\n\n    $_compile(schema, options) {\n\n        return Compile.schema(this.$_root, schema, options);\n    }\n\n    $_createError(code, value, local, state, prefs, options = {}) {\n\n        const flags = options.flags !== false ? this._flags : {};\n        const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;\n        return new Errors.Report(code, value, local, flags, messages, state, prefs);\n    }\n\n    $_getFlag(name) {\n\n        return this._flags[name];\n    }\n\n    $_getRule(name) {\n\n        return this._singleRules.get(name);\n    }\n\n    $_mapLabels(path) {\n\n        path = Array.isArray(path) ? path : path.split('.');\n        return this._ids.labels(path);\n    }\n\n    $_match(value, state, prefs, overrides) {\n\n        prefs = Object.assign({}, prefs);       // Shallow cloned\n        prefs.abortEarly = true;\n        prefs._externals = false;\n\n        state.snapshot();\n        const result = !Validator.validate(value, this, state, prefs, overrides).errors;\n        state.restore();\n\n        return result;\n    }\n\n    $_modify(options) {\n\n        Common.assertOptions(options, ['each', 'once', 'ref', 'schema']);\n        return Modify.schema(this, options) || this;\n    }\n\n    $_mutateRebuild() {\n\n        Assert(!this._inRuleset(), 'Cannot add this rule inside a ruleset');\n\n        this._refs.reset();\n        this._ids.reset();\n\n        const each = (item, { source, name, path, key }) => {\n\n            const family = this._definition[source][name] && this._definition[source][name].register;\n            if (family !== false) {\n                this.$_mutateRegister(item, { family, key });\n            }\n        };\n\n        this.$_modify({ each });\n\n        if (this._definition.rebuild) {\n            this._definition.rebuild(this);\n        }\n\n        this.$_temp.ruleset = false;\n        return this;\n    }\n\n    $_mutateRegister(schema, { family, key } = {}) {\n\n        this._refs.register(schema, family);\n        this._ids.register(schema, { key });\n    }\n\n    $_property(name) {\n\n        return this._definition.properties[name];\n    }\n\n    $_reach(path) {\n\n        return this._ids.reach(path);\n    }\n\n    $_rootReferences() {\n\n        return this._refs.roots();\n    }\n\n    $_setFlag(name, value, options = {}) {\n\n        Assert(name[0] === '_' || !this._inRuleset(), 'Cannot set flag inside a ruleset');\n\n        const flag = this._definition.flags[name] || {};\n        if (DeepEqual(value, flag.default)) {\n            value = undefined;\n        }\n\n        if (DeepEqual(value, this._flags[name])) {\n            return this;\n        }\n\n        const obj = options.clone !== false ? this.clone() : this;\n\n        if (value !== undefined) {\n            obj._flags[name] = value;\n            obj.$_mutateRegister(value);\n        }\n        else {\n            delete obj._flags[name];\n        }\n\n        if (name[0] !== '_') {\n            obj.$_temp.ruleset = false;\n        }\n\n        return obj;\n    }\n\n    $_parent(method, ...args) {\n\n        return this[method][Common.symbols.parent].call(this, ...args);\n    }\n\n    $_validate(value, state, prefs) {\n\n        return Validator.validate(value, this, state, prefs);\n    }\n\n    // Internals\n\n    _assign(target) {\n\n        target.type = this.type;\n\n        target.$_root = this.$_root;\n\n        target.$_temp = Object.assign({}, this.$_temp);\n        target.$_temp.whens = {};\n\n        target._ids = this._ids.clone();\n        target._preferences = this._preferences;\n        target._valids = this._valids && this._valids.clone();\n        target._invalids = this._invalids && this._invalids.clone();\n        target._rules = this._rules.slice();\n        target._singleRules = Clone(this._singleRules, { shallow: true });\n        target._refs = this._refs.clone();\n        target._flags = Object.assign({}, this._flags);\n        target._cache = null;\n\n        target.$_terms = {};\n        for (const key in this.$_terms) {\n            target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;\n        }\n\n        // Backwards compatibility\n\n        target.$_super = {};\n        for (const override in this.$_super) {\n            target.$_super[override] = this._super[override].bind(target);\n        }\n\n        return target;\n    }\n\n    _bare() {\n\n        const obj = this.clone();\n        obj._reset();\n\n        const terms = obj._definition.terms;\n        for (const name in terms) {\n            const term = terms[name];\n            obj.$_terms[name] = term.init;\n        }\n\n        return obj.$_mutateRebuild();\n    }\n\n    _default(flag, value, options = {}) {\n\n        Common.assertOptions(options, 'literal');\n\n        Assert(value !== undefined, 'Missing', flag, 'value');\n        Assert(typeof value === 'function' || !options.literal, 'Only function value supports literal option');\n\n        if (typeof value === 'function' &&\n            options.literal) {\n\n            value = {\n                [Common.symbols.literal]: true,\n                literal: value\n            };\n        }\n\n        const obj = this.$_setFlag(flag, value);\n        return obj;\n    }\n\n    _generate(value, state, prefs) {\n\n        if (!this.$_terms.whens) {\n            return { schema: this };\n        }\n\n        // Collect matching whens\n\n        const whens = [];\n        const ids = [];\n        for (let i = 0; i < this.$_terms.whens.length; ++i) {\n            const when = this.$_terms.whens[i];\n\n            if (when.concat) {\n                whens.push(when.concat);\n                ids.push(`${i}.concat`);\n                continue;\n            }\n\n            const input = when.ref ? when.ref.resolve(value, state, prefs) : value;\n            const tests = when.is ? [when] : when.switch;\n            const before = ids.length;\n\n            for (let j = 0; j < tests.length; ++j) {\n                const { is, then, otherwise } = tests[j];\n\n                const baseId = `${i}${when.switch ? '.' + j : ''}`;\n                if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {\n                    if (then) {\n                        const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);\n                        const { schema: generated, id } = then._generate(value, localState, prefs);\n                        whens.push(generated);\n                        ids.push(`${baseId}.then${id ? `(${id})` : ''}`);\n                        break;\n                    }\n                }\n                else if (otherwise) {\n                    const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);\n                    const { schema: generated, id } = otherwise._generate(value, localState, prefs);\n                    whens.push(generated);\n                    ids.push(`${baseId}.otherwise${id ? `(${id})` : ''}`);\n                    break;\n                }\n            }\n\n            if (when.break &&\n                ids.length > before) {          // Something matched\n\n                break;\n            }\n        }\n\n        // Check cache\n\n        const id = ids.join(', ');\n        state.mainstay.tracer.debug(state, 'rule', 'when', id);\n\n        if (!id) {\n            return { schema: this };\n        }\n\n        if (!state.mainstay.tracer.active &&\n            this.$_temp.whens[id]) {\n\n            return { schema: this.$_temp.whens[id], id };\n        }\n\n        // Generate dynamic schema\n\n        let obj = this;                                             // eslint-disable-line consistent-this\n        if (this._definition.generate) {\n            obj = this._definition.generate(this, value, state, prefs);\n        }\n\n        // Apply whens\n\n        for (const when of whens) {\n            obj = obj.concat(when);\n        }\n\n        // Tracing\n\n        if (this.$_root._tracer) {\n            this.$_root._tracer._combine(obj, [this, ...whens]);\n        }\n\n        // Cache result\n\n        this.$_temp.whens[id] = obj;\n        return { schema: obj, id };\n    }\n\n    _inner(type, values, options = {}) {\n\n        Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);\n\n        const obj = this.clone();\n        if (!obj.$_terms[type] ||\n            options.override) {\n\n            obj.$_terms[type] = [];\n        }\n\n        if (options.single) {\n            obj.$_terms[type].push(values);\n        }\n        else {\n            obj.$_terms[type].push(...values);\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    _inRuleset() {\n\n        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;\n    }\n\n    _ruleRemove(name, options = {}) {\n\n        if (!this._singleRules.has(name)) {\n            return this;\n        }\n\n        const obj = options.clone !== false ? this.clone() : this;\n\n        obj._singleRules.delete(name);\n\n        const filtered = [];\n        for (let i = 0; i < obj._rules.length; ++i) {\n            const test = obj._rules[i];\n            if (test.name === name &&\n                !test.keep) {\n\n                if (obj._inRuleset() &&\n                    i < obj.$_temp.ruleset) {\n\n                    --obj.$_temp.ruleset;\n                }\n\n                continue;\n            }\n\n            filtered.push(test);\n        }\n\n        obj._rules = filtered;\n        return obj;\n    }\n\n    _values(values, key) {\n\n        Common.verifyFlat(values, key.slice(1, -1));\n\n        const obj = this.clone();\n\n        const override = values[0] === Common.symbols.override;\n        if (override) {\n            values = values.slice(1);\n        }\n\n        if (!obj[key] &&\n            values.length) {\n\n            obj[key] = new Values();\n        }\n        else if (override) {\n            obj[key] = values.length ? new Values() : null;\n            obj.$_mutateRebuild();\n        }\n\n        if (!obj[key]) {\n            return obj;\n        }\n\n        if (override) {\n            obj[key].override();\n        }\n\n        for (const value of values) {\n            Assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n            Assert(value !== Common.symbols.override, 'Override must be the first value');\n\n            const other = key === '_invalids' ? '_valids' : '_invalids';\n            if (obj[other]) {\n                obj[other].remove(value);\n                if (!obj[other].length) {\n                    Assert(key === '_valids' || !obj._flags.only, 'Setting invalid value', value, 'leaves schema rejecting all values due to previous valid rule');\n                    obj[other] = null;\n                }\n            }\n\n            obj[key].add(value, obj._refs);\n        }\n\n        return obj;\n    }\n};\n\n\ninternals.Base.prototype[Common.symbols.any] = {\n    version: Common.version,\n    compile: Compile.compile,\n    root: '$_root'\n};\n\n\ninternals.Base.prototype.isImmutable = true;                // Prevents Hoek from deep cloning schema objects (must be on prototype)\n\n\n// Aliases\n\ninternals.Base.prototype.deny = internals.Base.prototype.invalid;\ninternals.Base.prototype.disallow = internals.Base.prototype.invalid;\ninternals.Base.prototype.equal = internals.Base.prototype.valid;\ninternals.Base.prototype.exist = internals.Base.prototype.required;\ninternals.Base.prototype.not = internals.Base.prototype.invalid;\ninternals.Base.prototype.options = internals.Base.prototype.prefs;\ninternals.Base.prototype.preferences = internals.Base.prototype.prefs;\n\n\nmodule.exports = new internals.Base();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9iYXNlLmpzP2MyNGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLG9EQUF1QjtBQUM5QyxjQUFjLG1CQUFPLENBQUMsa0RBQXNCO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLDBEQUEwQjtBQUNwRCxjQUFjLG1CQUFPLENBQUMsa0RBQXNCOztBQUU1QyxjQUFjLG1CQUFPLENBQUMsZ0RBQVM7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLGtEQUFVO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLG9EQUFXO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyxrREFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsa0RBQVU7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsc0RBQVk7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsc0RBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLGtEQUFVO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTztBQUMzQixjQUFjLG1CQUFPLENBQUMsZ0RBQVM7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsd0RBQWE7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLGtEQUFVOzs7QUFHakM7OztBQUdBOztBQUVBOztBQUVBLDJEQUEyRDs7QUFFM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QywwQkFBMEI7O0FBRTFCLHVCQUF1QjtBQUN2QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw0Q0FBNEMsa0JBQWtCO0FBQzlEOztBQUVBLCtDQUErQyxlQUFlO0FBQzlEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7O0FBRUEsaURBQWlELDJDQUEyQztBQUM1Rjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLHNCQUFzQixHQUFHLGVBQWU7QUFDakY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxlQUFlO0FBQzFEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw4Q0FBOEMsZUFBZTtBQUM3RDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjs7QUFFQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEscUNBQXFDOztBQUVyQyxpREFBaUQsS0FBSzs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsNENBQTRDOzs7QUFHNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pvaS9saWIvYmFzZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5jb25zdCBEZWVwRXF1YWwgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9kZWVwRXF1YWwnKTtcbmNvbnN0IE1lcmdlID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvbWVyZ2UnKTtcblxuY29uc3QgQ2FjaGUgPSByZXF1aXJlKCcuL2NhY2hlJyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgQ29tcGlsZSA9IHJlcXVpcmUoJy4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IEV4dGVuZCA9IHJlcXVpcmUoJy4vZXh0ZW5kJyk7XG5jb25zdCBNYW5pZmVzdCA9IHJlcXVpcmUoJy4vbWFuaWZlc3QnKTtcbmNvbnN0IE1lc3NhZ2VzID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuY29uc3QgTW9kaWZ5ID0gcmVxdWlyZSgnLi9tb2RpZnknKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5jb25zdCBUcmFjZSA9IHJlcXVpcmUoJy4vdHJhY2UnKTtcbmNvbnN0IFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vdmFsaWRhdG9yJyk7XG5jb25zdCBWYWx1ZXMgPSByZXF1aXJlKCcuL3ZhbHVlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5CYXNlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuXG4gICAgICAgIC8vIE5hbWluZzogcHVibGljLCBfcHJpdmF0ZSwgJF9leHRlbnNpb24sICRfbXV0YXRle2FjdGlvbn1cblxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgICAgIHRoaXMuJF9yb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGVmaW5pdGlvbiA9IHt9O1xuICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgIH1cblxuICAgIF9yZXNldCgpIHtcblxuICAgICAgICB0aGlzLl9pZHMgPSBuZXcgTW9kaWZ5LklkcygpO1xuICAgICAgICB0aGlzLl9wcmVmZXJlbmNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JlZnMgPSBuZXcgUmVmLk1hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3ZhbGlkcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ludmFsaWRzID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9mbGFncyA9IHt9O1xuICAgICAgICB0aGlzLl9ydWxlcyA9IFtdO1xuICAgICAgICB0aGlzLl9zaW5nbGVSdWxlcyA9IG5ldyBNYXAoKTsgICAgICAgICAgICAgIC8vIFRoZSBydWxlIG9wdGlvbnMgcGFzc2VkIGZvciBub24tbXVsdGkgcnVsZXNcblxuICAgICAgICB0aGlzLiRfdGVybXMgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhc2ggb2YgYXJyYXlzIG9mIGltbXV0YWJsZSBvYmplY3RzIChleHRlbmRlZCBieSBvdGhlciB0eXBlcylcblxuICAgICAgICB0aGlzLiRfdGVtcCA9IHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJ1bnRpbWUgc3RhdGUgKG5vdCBjbG9uZWQpXG4gICAgICAgICAgICBydWxlc2V0OiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVsbDogdXNlIGxhc3QsIGZhbHNlOiBlcnJvciwgbnVtYmVyOiBzdGFydCBwb3NpdGlvblxuICAgICAgICAgICAgd2hlbnM6IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJ1bnRpbWUgY2FjaGUgb2YgZ2VuZXJhdGVkIHdoZW5zXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTWFuaWZlc3RcblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgTWFuaWZlc3QuZGVzY3JpYmUgPT09ICdmdW5jdGlvbicsICdNYW5pZmVzdCBmdW5jdGlvbmFsaXR5IGRpc2FibGVkJyk7XG4gICAgICAgIHJldHVybiBNYW5pZmVzdC5kZXNjcmliZSh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBSdWxlc1xuXG4gICAgYWxsb3coLi4udmFsdWVzKSB7XG5cbiAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQodmFsdWVzLCAnYWxsb3cnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcyh2YWx1ZXMsICdfdmFsaWRzJyk7XG4gICAgfVxuXG4gICAgYWx0ZXIodGFyZ2V0cykge1xuXG4gICAgICAgIEFzc2VydCh0YXJnZXRzICYmIHR5cGVvZiB0YXJnZXRzID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh0YXJnZXRzKSwgJ0ludmFsaWQgdGFyZ2V0cyBhcmd1bWVudCcpO1xuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHNldCBhbHRlcmF0aW9ucyBpbnNpZGUgYSBydWxlc2V0Jyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouJF90ZXJtcy5hbHRlcmF0aW9ucyA9IG9iai4kX3Rlcm1zLmFsdGVyYXRpb25zIHx8IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBpbiB0YXJnZXRzKSB7XG4gICAgICAgICAgICBjb25zdCBhZGp1c3RlciA9IHRhcmdldHNbdGFyZ2V0XTtcbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgYWRqdXN0ZXIgPT09ICdmdW5jdGlvbicsICdBbHRlcmF0aW9uIGFkanVzdGVyIGZvcicsIHRhcmdldCwgJ211c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgb2JqLiRfdGVybXMuYWx0ZXJhdGlvbnMucHVzaCh7IHRhcmdldCwgYWRqdXN0ZXIgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBhcnRpZmFjdChpZCkge1xuXG4gICAgICAgIEFzc2VydChpZCAhPT0gdW5kZWZpbmVkLCAnQXJ0aWZhY3QgY2Fubm90IGJlIHVuZGVmaW5lZCcpO1xuICAgICAgICBBc3NlcnQoIXRoaXMuX2NhY2hlLCAnQ2Fubm90IHNldCBhbiBhcnRpZmFjdCB3aXRoIGEgcnVsZSBjYWNoZScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnYXJ0aWZhY3QnLCBpZCk7XG4gICAgfVxuXG4gICAgY2FzdCh0bykge1xuXG4gICAgICAgIEFzc2VydCh0byA9PT0gZmFsc2UgfHwgdHlwZW9mIHRvID09PSAnc3RyaW5nJywgJ0ludmFsaWQgdG8gdmFsdWUnKTtcbiAgICAgICAgQXNzZXJ0KHRvID09PSBmYWxzZSB8fCB0aGlzLl9kZWZpbml0aW9uLmNhc3RbdG9dLCAnVHlwZScsIHRoaXMudHlwZSwgJ2RvZXMgbm90IHN1cHBvcnQgY2FzdGluZyB0bycsIHRvKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Nhc3QnLCB0byA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiB0byk7XG4gICAgfVxuXG4gICAgZGVmYXVsdCh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0KCdkZWZhdWx0JywgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGRlc2NyaXB0aW9uKGRlc2MpIHtcblxuICAgICAgICBBc3NlcnQoZGVzYyAmJiB0eXBlb2YgZGVzYyA9PT0gJ3N0cmluZycsICdEZXNjcmlwdGlvbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnZGVzY3JpcHRpb24nLCBkZXNjKTtcbiAgICB9XG5cbiAgICBlbXB0eShzY2hlbWEpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzY2hlbWEgPSBvYmouJF9jb21waWxlKHNjaGVtYSwgeyBvdmVycmlkZTogZmFsc2UgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqLiRfc2V0RmxhZygnZW1wdHknLCBzY2hlbWEsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIGVycm9yKGVycikge1xuXG4gICAgICAgIEFzc2VydChlcnIsICdNaXNzaW5nIGVycm9yJyk7XG4gICAgICAgIEFzc2VydChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgZXJyID09PSAnZnVuY3Rpb24nLCAnTXVzdCBwcm92aWRlIGEgdmFsaWQgRXJyb3Igb2JqZWN0IG9yIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG5cbiAgICBleGFtcGxlKGV4YW1wbGUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydChleGFtcGxlICE9PSB1bmRlZmluZWQsICdNaXNzaW5nIGV4YW1wbGUnKTtcbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydvdmVycmlkZSddKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ2V4YW1wbGVzJywgZXhhbXBsZSwgeyBzaW5nbGU6IHRydWUsIG92ZXJyaWRlOiBvcHRpb25zLm92ZXJyaWRlIH0pO1xuICAgIH1cblxuICAgIGV4dGVybmFsKG1ldGhvZCwgZGVzY3JpcHRpb24pIHtcblxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIEFzc2VydCghZGVzY3JpcHRpb24sICdDYW5ub3QgY29tYmluZSBvcHRpb25zIHdpdGggZGVzY3JpcHRpb24nKTtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gbWV0aG9kLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgbWV0aG9kID0gbWV0aG9kLm1ldGhvZDtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nLCAnTWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICBBc3NlcnQoZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCB8fCBkZXNjcmlwdGlvbiAmJiB0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdzdHJpbmcnLCAnRGVzY3JpcHRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ2V4dGVybmFscycsIHsgbWV0aG9kLCBkZXNjcmlwdGlvbiB9LCB7IHNpbmdsZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBmYWlsb3Zlcih2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0KCdmYWlsb3ZlcicsIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmb3JiaWRkZW4oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJlc2VuY2UoJ2ZvcmJpZGRlbicpO1xuICAgIH1cblxuICAgIGlkKGlkKSB7XG5cbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdpZCcsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQodHlwZW9mIGlkID09PSAnc3RyaW5nJywgJ2lkIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgIEFzc2VydCgvXlteXFwuXSskLy50ZXN0KGlkKSwgJ2lkIGNhbm5vdCBjb250YWluIHBlcmlvZCBjaGFyYWN0ZXInKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2lkJywgaWQpO1xuICAgIH1cblxuICAgIGludmFsaWQoLi4udmFsdWVzKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcyh2YWx1ZXMsICdfaW52YWxpZHMnKTtcbiAgICB9XG5cbiAgICBsYWJlbChuYW1lKSB7XG5cbiAgICAgICAgQXNzZXJ0KG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCAnTGFiZWwgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnbGFiZWwnLCBuYW1lKTtcbiAgICB9XG5cbiAgICBtZXRhKG1ldGEpIHtcblxuICAgICAgICBBc3NlcnQobWV0YSAhPT0gdW5kZWZpbmVkLCAnTWV0YSBjYW5ub3QgYmUgdW5kZWZpbmVkJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCdtZXRhcycsIG1ldGEsIHsgc2luZ2xlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIG5vdGUoLi4ubm90ZXMpIHtcblxuICAgICAgICBBc3NlcnQobm90ZXMubGVuZ3RoLCAnTWlzc2luZyBub3RlcycpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vdGUgb2Ygbm90ZXMpIHtcbiAgICAgICAgICAgIEFzc2VydChub3RlICYmIHR5cGVvZiBub3RlID09PSAnc3RyaW5nJywgJ05vdGVzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcignbm90ZXMnLCBub3Rlcyk7XG4gICAgfVxuXG4gICAgb25seShtb2RlID0gdHJ1ZSkge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbW9kZSA9PT0gJ2Jvb2xlYW4nLCAnSW52YWxpZCBtb2RlOicsIG1vZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnb25seScsIG1vZGUpO1xuICAgIH1cblxuICAgIG9wdGlvbmFsKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByZXNlbmNlKCdvcHRpb25hbCcpO1xuICAgIH1cblxuICAgIHByZWZzKHByZWZzKSB7XG5cbiAgICAgICAgQXNzZXJ0KHByZWZzLCAnTWlzc2luZyBwcmVmZXJlbmNlcycpO1xuICAgICAgICBBc3NlcnQocHJlZnMuY29udGV4dCA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIGNvbnRleHQnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLmV4dGVybmFscyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIGV4dGVybmFscycpO1xuICAgICAgICBBc3NlcnQocHJlZnMud2FybmluZ3MgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSB3YXJuaW5ncycpO1xuICAgICAgICBBc3NlcnQocHJlZnMuZGVidWcgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSBkZWJ1ZycpO1xuXG4gICAgICAgIENvbW1vbi5jaGVja1ByZWZlcmVuY2VzKHByZWZzKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fcHJlZmVyZW5jZXMgPSBDb21tb24ucHJlZmVyZW5jZXMob2JqLl9wcmVmZXJlbmNlcywgcHJlZnMpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHByZXNlbmNlKG1vZGUpIHtcblxuICAgICAgICBBc3NlcnQoWydvcHRpb25hbCcsICdyZXF1aXJlZCcsICdmb3JiaWRkZW4nXS5pbmNsdWRlcyhtb2RlKSwgJ1Vua25vd24gcHJlc2VuY2UgbW9kZScsIG1vZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncHJlc2VuY2UnLCBtb2RlKTtcbiAgICB9XG5cbiAgICByYXcoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Jlc3VsdCcsIGVuYWJsZWQgPyAncmF3JyA6IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmVzdWx0KG1vZGUpIHtcblxuICAgICAgICBBc3NlcnQoWydyYXcnLCAnc3RyaXAnXS5pbmNsdWRlcyhtb2RlKSwgJ1Vua25vd24gcmVzdWx0IG1vZGUnLCBtb2RlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Jlc3VsdCcsIG1vZGUpO1xuICAgIH1cblxuICAgIHJlcXVpcmVkKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByZXNlbmNlKCdyZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIHN0cmljdChlbmFibGVkKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGNvbnN0IGNvbnZlcnQgPSBlbmFibGVkID09PSB1bmRlZmluZWQgPyBmYWxzZSA6ICFlbmFibGVkO1xuICAgICAgICBvYmouX3ByZWZlcmVuY2VzID0gQ29tbW9uLnByZWZlcmVuY2VzKG9iai5fcHJlZmVyZW5jZXMsIHsgY29udmVydCB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdHJpcChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncmVzdWx0JywgZW5hYmxlZCA/ICdzdHJpcCcgOiB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHRhZyguLi50YWdzKSB7XG5cbiAgICAgICAgQXNzZXJ0KHRhZ3MubGVuZ3RoLCAnTWlzc2luZyB0YWdzJyk7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgIEFzc2VydCh0YWcgJiYgdHlwZW9mIHRhZyA9PT0gJ3N0cmluZycsICdUYWdzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcigndGFncycsIHRhZ3MpO1xuICAgIH1cblxuICAgIHVuaXQobmFtZSkge1xuXG4gICAgICAgIEFzc2VydChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgJ1VuaXQgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndW5pdCcsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhbGlkKC4uLnZhbHVlcykge1xuXG4gICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHZhbHVlcywgJ3ZhbGlkJyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5hbGxvdyguLi52YWx1ZXMpO1xuICAgICAgICBvYmouJF9zZXRGbGFnKCdvbmx5JywgISFvYmouX3ZhbGlkcywgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgd2hlbihjb25kaXRpb24sIG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKCFvYmouJF90ZXJtcy53aGVucykge1xuICAgICAgICAgICAgb2JqLiRfdGVybXMud2hlbnMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdoZW4gPSBDb21waWxlLndoZW4ob2JqLCBjb25kaXRpb24sIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIVsnYW55JywgJ2xpbmsnXS5pbmNsdWRlcyhvYmoudHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSB3aGVuLmlzID8gW3doZW5dIDogd2hlbi5zd2l0Y2g7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29uZGl0aW9ucykge1xuICAgICAgICAgICAgICAgIEFzc2VydCghaXRlbS50aGVuIHx8IGl0ZW0udGhlbi50eXBlID09PSAnYW55JyB8fCBpdGVtLnRoZW4udHlwZSA9PT0gb2JqLnR5cGUsICdDYW5ub3QgY29tYmluZScsIG9iai50eXBlLCAnd2l0aCcsIGl0ZW0udGhlbiAmJiBpdGVtLnRoZW4udHlwZSk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFpdGVtLm90aGVyd2lzZSB8fCBpdGVtLm90aGVyd2lzZS50eXBlID09PSAnYW55JyB8fCBpdGVtLm90aGVyd2lzZS50eXBlID09PSBvYmoudHlwZSwgJ0Nhbm5vdCBjb21iaW5lJywgb2JqLnR5cGUsICd3aXRoJywgaXRlbS5vdGhlcndpc2UgJiYgaXRlbS5vdGhlcndpc2UudHlwZSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3Rlcm1zLndoZW5zLnB1c2god2hlbik7XG4gICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgfVxuXG4gICAgLy8gSGVscGVyc1xuXG4gICAgY2FjaGUoY2FjaGUpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHNldCBjYWNoaW5nIGluc2lkZSBhIHJ1bGVzZXQnKTtcbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9jYWNoZSwgJ0Nhbm5vdCBvdmVycmlkZSBzY2hlbWEgY2FjaGUnKTtcbiAgICAgICAgQXNzZXJ0KHRoaXMuX2ZsYWdzLmFydGlmYWN0ID09PSB1bmRlZmluZWQsICdDYW5ub3QgY2FjaGUgYSBydWxlIHdpdGggYW4gYXJ0aWZhY3QnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fY2FjaGUgPSBjYWNoZSB8fCBDYWNoZS5wcm92aWRlci5wcm92aXNpb24oKTtcbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYXNzaWduKG9iaik7XG4gICAgfVxuXG4gICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc291cmNlKSwgJ0ludmFsaWQgc2NoZW1hIG9iamVjdCcpO1xuICAgICAgICBBc3NlcnQodGhpcy50eXBlID09PSAnYW55JyB8fCBzb3VyY2UudHlwZSA9PT0gJ2FueScgfHwgc291cmNlLnR5cGUgPT09IHRoaXMudHlwZSwgJ0Nhbm5vdCBtZXJnZSB0eXBlJywgdGhpcy50eXBlLCAnd2l0aCBhbm90aGVyIHR5cGU6Jywgc291cmNlLnR5cGUpO1xuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IGNvbmNhdGVuYXRlIG9udG8gYSBzY2hlbWEgd2l0aCBvcGVuIHJ1bGVzZXQnKTtcbiAgICAgICAgQXNzZXJ0KCFzb3VyY2UuX2luUnVsZXNldCgpLCAnQ2Fubm90IGNvbmNhdGVuYXRlIGEgc2NoZW1hIHdpdGggb3BlbiBydWxlc2V0Jyk7XG5cbiAgICAgICAgbGV0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnYW55JyAmJlxuICAgICAgICAgICAgc291cmNlLnR5cGUgIT09ICdhbnknKSB7XG5cbiAgICAgICAgICAgIC8vIENoYW5nZSBvYmogdG8gbWF0Y2ggc291cmNlIHR5cGVcblxuICAgICAgICAgICAgY29uc3QgdG1wT2JqID0gc291cmNlLmNsb25lKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3R5cGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcE9ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmogPSB0bXBPYmo7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouX2lkcy5jb25jYXQoc291cmNlLl9pZHMpO1xuICAgICAgICBvYmouX3JlZnMucmVnaXN0ZXIoc291cmNlLCBSZWYudG9TaWJsaW5nKTtcblxuICAgICAgICBvYmouX3ByZWZlcmVuY2VzID0gb2JqLl9wcmVmZXJlbmNlcyA/IENvbW1vbi5wcmVmZXJlbmNlcyhvYmouX3ByZWZlcmVuY2VzLCBzb3VyY2UuX3ByZWZlcmVuY2VzKSA6IHNvdXJjZS5fcHJlZmVyZW5jZXM7XG4gICAgICAgIG9iai5fdmFsaWRzID0gVmFsdWVzLm1lcmdlKG9iai5fdmFsaWRzLCBzb3VyY2UuX3ZhbGlkcywgc291cmNlLl9pbnZhbGlkcyk7XG4gICAgICAgIG9iai5faW52YWxpZHMgPSBWYWx1ZXMubWVyZ2Uob2JqLl9pbnZhbGlkcywgc291cmNlLl9pbnZhbGlkcywgc291cmNlLl92YWxpZHMpO1xuXG4gICAgICAgIC8vIFJlbW92ZSB1bmlxdWUgcnVsZXMgcHJlc2VudCBpbiBzb3VyY2VcblxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc291cmNlLl9zaW5nbGVSdWxlcy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGlmIChvYmouX3NpbmdsZVJ1bGVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIG9iai5fcnVsZXMgPSBvYmouX3J1bGVzLmZpbHRlcigodGFyZ2V0KSA9PiB0YXJnZXQua2VlcCB8fCB0YXJnZXQubmFtZSAhPT0gbmFtZSk7XG4gICAgICAgICAgICAgICAgb2JqLl9zaW5nbGVSdWxlcy5kZWxldGUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSdWxlc1xuXG4gICAgICAgIGZvciAoY29uc3QgdGVzdCBvZiBzb3VyY2UuX3J1bGVzKSB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZS5fZGVmaW5pdGlvbi5ydWxlc1t0ZXN0Lm1ldGhvZF0ubXVsdGkpIHtcbiAgICAgICAgICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLnNldCh0ZXN0Lm5hbWUsIHRlc3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouX3J1bGVzLnB1c2godGVzdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGbGFnc1xuXG4gICAgICAgIGlmIChvYmouX2ZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICBzb3VyY2UuX2ZsYWdzLmVtcHR5KSB7XG5cbiAgICAgICAgICAgIG9iai5fZmxhZ3MuZW1wdHkgPSBvYmouX2ZsYWdzLmVtcHR5LmNvbmNhdChzb3VyY2UuX2ZsYWdzLmVtcHR5KTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLl9mbGFncyk7XG4gICAgICAgICAgICBkZWxldGUgZmxhZ3MuZW1wdHk7XG4gICAgICAgICAgICBNZXJnZShvYmouX2ZsYWdzLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc291cmNlLl9mbGFncy5lbXB0eSkge1xuICAgICAgICAgICAgb2JqLl9mbGFncy5lbXB0eSA9IHNvdXJjZS5fZmxhZ3MuZW1wdHk7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5fZmxhZ3MpO1xuICAgICAgICAgICAgZGVsZXRlIGZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgTWVyZ2Uob2JqLl9mbGFncywgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgTWVyZ2Uob2JqLl9mbGFncywgc291cmNlLl9mbGFncyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXJtc1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZS4kX3Rlcm1zKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXJtcyA9IHNvdXJjZS4kX3Rlcm1zW2tleV07XG4gICAgICAgICAgICBpZiAoIXRlcm1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmouJF90ZXJtc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zW2tleV0gPSB0ZXJtcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvYmouJF90ZXJtc1trZXldKSB7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXNba2V5XSA9IHRlcm1zLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW2tleV0gPSBvYmouJF90ZXJtc1trZXldLmNvbmNhdCh0ZXJtcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjaW5nXG5cbiAgICAgICAgaWYgKHRoaXMuJF9yb290Ll90cmFjZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJF9yb290Ll90cmFjZXIuX2NvbWJpbmUob2JqLCBbdGhpcywgc291cmNlXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWJ1aWxkXG5cbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICBleHRlbmQob3B0aW9ucykge1xuXG4gICAgICAgIEFzc2VydCghb3B0aW9ucy5iYXNlLCAnQ2Fubm90IGV4dGVuZCB0eXBlIHdpdGggYW5vdGhlciBiYXNlJyk7XG5cbiAgICAgICAgcmV0dXJuIEV4dGVuZC50eXBlKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGV4dHJhY3QocGF0aCkge1xuXG4gICAgICAgIHBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkcy5yZWFjaChwYXRoKTtcbiAgICB9XG5cbiAgICBmb3JrKHBhdGhzLCBhZGp1c3Rlcikge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3QgZm9yayBpbnNpZGUgYSBydWxlc2V0Jyk7XG5cbiAgICAgICAgbGV0IG9iaiA9IHRoaXM7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXRoaXNcbiAgICAgICAgZm9yIChsZXQgcGF0aCBvZiBbXS5jb25jYXQocGF0aHMpKSB7XG4gICAgICAgICAgICBwYXRoID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBvYmogPSBvYmouX2lkcy5mb3JrKHBhdGgsIGFkanVzdGVyLCBvYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcnVsZShvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmaW5pdGlvbjtcbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgT2JqZWN0LmtleXMoZGVmLm1vZGlmaWVycykpO1xuXG4gICAgICAgIEFzc2VydCh0aGlzLiRfdGVtcC5ydWxlc2V0ICE9PSBmYWxzZSwgJ0Nhbm5vdCBhcHBseSBydWxlcyB0byBlbXB0eSBydWxlc2V0IG9yIHRoZSBsYXN0IHJ1bGUgYWRkZWQgZG9lcyBub3Qgc3VwcG9ydCBydWxlIHByb3BlcnRpZXMnKTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLiRfdGVtcC5ydWxlc2V0ID09PSBudWxsID8gdGhpcy5fcnVsZXMubGVuZ3RoIC0gMSA6IHRoaXMuJF90ZW1wLnJ1bGVzZXQ7XG4gICAgICAgIEFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5fcnVsZXMubGVuZ3RoLCAnQ2Fubm90IGFwcGx5IHJ1bGVzIHRvIGVtcHR5IHJ1bGVzZXQnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgb2JqLl9ydWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBvYmouX3J1bGVzW2ldO1xuICAgICAgICAgICAgY29uc3QgcnVsZSA9IENsb25lKG9yaWdpbmFsKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBkZWYubW9kaWZpZXJzW25hbWVdKHJ1bGUsIG9wdGlvbnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIEFzc2VydChydWxlLm5hbWUgPT09IG9yaWdpbmFsLm5hbWUsICdDYW5ub3QgY2hhbmdlIHJ1bGUgbmFtZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouX3J1bGVzW2ldID0gcnVsZTtcblxuICAgICAgICAgICAgaWYgKG9iai5fc2luZ2xlUnVsZXMuZ2V0KHJ1bGUubmFtZSkgPT09IG9yaWdpbmFsKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9zaW5nbGVSdWxlcy5zZXQocnVsZS5uYW1lLCBydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgIH1cblxuICAgIGdldCBydWxlc2V0KCkge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3Qgc3RhcnQgYSBuZXcgcnVsZXNldCB3aXRob3V0IGNsb3NpbmcgdGhlIHByZXZpb3VzIG9uZScpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gb2JqLl9ydWxlcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZ2V0ICQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZXNldDtcbiAgICB9XG5cbiAgICB0YWlsb3IodGFyZ2V0cykge1xuXG4gICAgICAgIHRhcmdldHMgPSBbXS5jb25jYXQodGFyZ2V0cyk7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCB0YWlsb3IgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIGxldCBvYmogPSB0aGlzOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXRoaXNcblxuICAgICAgICBpZiAodGhpcy4kX3Rlcm1zLmFsdGVyYXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFyZ2V0LCBhZGp1c3RlciB9IG9mIHRoaXMuJF90ZXJtcy5hbHRlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRzLmluY2x1ZGVzKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gYWRqdXN0ZXIob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KENvbW1vbi5pc1NjaGVtYShvYmopLCAnQWx0ZXJhdGlvbiBhZGp1c3RlciBmb3InLCB0YXJnZXQsICdmYWlsZWQgdG8gcmV0dXJuIGEgc2NoZW1hIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IG9iai4kX21vZGlmeSh7IGVhY2g6IChpdGVtKSA9PiBpdGVtLnRhaWxvcih0YXJnZXRzKSwgcmVmOiBmYWxzZSB9KTtcbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgfVxuXG4gICAgdHJhY2VyKCkge1xuXG4gICAgICAgIHJldHVybiBUcmFjZS5sb2NhdGlvbiA/IFRyYWNlLmxvY2F0aW9uKHRoaXMpIDogdGhpczsgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgfVxuXG4gICAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gVmFsaWRhdG9yLmVudHJ5KHZhbHVlLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZUFzeW5jKHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIFZhbGlkYXRvci5lbnRyeUFzeW5jKHZhbHVlLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBFeHRlbnNpb25zXG5cbiAgICAkX2FkZFJ1bGUob3B0aW9ucykge1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBydWxlXG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHsgbmFtZTogb3B0aW9ucyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCAnSW52YWxpZCBvcHRpb25zJyk7XG4gICAgICAgIEFzc2VydChvcHRpb25zLm5hbWUgJiYgdHlwZW9mIG9wdGlvbnMubmFtZSA9PT0gJ3N0cmluZycsICdJbnZhbGlkIHJ1bGUgbmFtZScpO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIEFzc2VydChrZXlbMF0gIT09ICdfJywgJ0Nhbm5vdCBzZXQgcHJpdmF0ZSBydWxlIHByb3BlcnRpZXMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJ1bGUgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTsgICAgICAgIC8vIFNoYWxsb3cgY2xvbmVkXG4gICAgICAgIHJ1bGUuX3Jlc29sdmUgPSBbXTtcbiAgICAgICAgcnVsZS5tZXRob2QgPSBydWxlLm1ldGhvZCB8fCBydWxlLm5hbWU7XG5cbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuX2RlZmluaXRpb24ucnVsZXNbcnVsZS5tZXRob2RdO1xuICAgICAgICBjb25zdCBhcmdzID0gcnVsZS5hcmdzO1xuXG4gICAgICAgIEFzc2VydChkZWZpbml0aW9uLCAnVW5rbm93biBydWxlJywgcnVsZS5tZXRob2QpO1xuXG4gICAgICAgIC8vIEFyZ3NcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICAgIEFzc2VydChPYmplY3Qua2V5cyhhcmdzKS5sZW5ndGggPT09IDEgfHwgT2JqZWN0LmtleXMoYXJncykubGVuZ3RoID09PSB0aGlzLl9kZWZpbml0aW9uLnJ1bGVzW3J1bGUubmFtZV0uYXJncy5sZW5ndGgsICdJbnZhbGlkIHJ1bGUgZGVmaW5pdGlvbiBmb3InLCB0aGlzLnR5cGUsIHJ1bGUubmFtZSk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXJnID0gYXJnc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXJnc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbi5hcmdzQnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZGVmaW5pdGlvbi5hcmdzQnlOYW1lLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlci5yZWYgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbW1vbi5pc1Jlc29sdmFibGUoYXJnKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLl9yZXNvbHZlLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gcmVzb2x2ZXIubm9ybWFsaXplKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1trZXldID0gYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIuYXNzZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBDb21tb24udmFsaWRhdGVBcmcoYXJnLCBrZXksIHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIWVycm9yLCBlcnJvciwgJ29yIHJlZmVyZW5jZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJnc1trZXldID0gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5pcXVlIHJ1bGVzXG5cbiAgICAgICAgaWYgKCFkZWZpbml0aW9uLm11bHRpKSB7XG4gICAgICAgICAgICBvYmouX3J1bGVSZW1vdmUocnVsZS5uYW1lLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHJ1bGUubmFtZSwgcnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqLiRfdGVtcC5ydWxlc2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLnByaW9yaXR5KSB7XG4gICAgICAgICAgICBvYmouX3J1bGVzLnVuc2hpZnQocnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouX3J1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgICRfY29tcGlsZShzY2hlbWEsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gQ29tcGlsZS5zY2hlbWEodGhpcy4kX3Jvb3QsIHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgJF9jcmVhdGVFcnJvcihjb2RlLCB2YWx1ZSwgbG9jYWwsIHN0YXRlLCBwcmVmcywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgZmxhZ3MgPSBvcHRpb25zLmZsYWdzICE9PSBmYWxzZSA/IHRoaXMuX2ZsYWdzIDoge307XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcyA/IE1lc3NhZ2VzLm1lcmdlKHRoaXMuX2RlZmluaXRpb24ubWVzc2FnZXMsIG9wdGlvbnMubWVzc2FnZXMpIDogdGhpcy5fZGVmaW5pdGlvbi5tZXNzYWdlcztcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcnMuUmVwb3J0KGNvZGUsIHZhbHVlLCBsb2NhbCwgZmxhZ3MsIG1lc3NhZ2VzLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgICRfZ2V0RmxhZyhuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsYWdzW25hbWVdO1xuICAgIH1cblxuICAgICRfZ2V0UnVsZShuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpbmdsZVJ1bGVzLmdldChuYW1lKTtcbiAgICB9XG5cbiAgICAkX21hcExhYmVscyhwYXRoKSB7XG5cbiAgICAgICAgcGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4gdGhpcy5faWRzLmxhYmVscyhwYXRoKTtcbiAgICB9XG5cbiAgICAkX21hdGNoKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG92ZXJyaWRlcykge1xuXG4gICAgICAgIHByZWZzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJlZnMpOyAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICBwcmVmcy5hYm9ydEVhcmx5ID0gdHJ1ZTtcbiAgICAgICAgcHJlZnMuX2V4dGVybmFscyA9IGZhbHNlO1xuXG4gICAgICAgIHN0YXRlLnNuYXBzaG90KCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICFWYWxpZGF0b3IudmFsaWRhdGUodmFsdWUsIHRoaXMsIHN0YXRlLCBwcmVmcywgb3ZlcnJpZGVzKS5lcnJvcnM7XG4gICAgICAgIHN0YXRlLnJlc3RvcmUoKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgICRfbW9kaWZ5KG9wdGlvbnMpIHtcblxuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2VhY2gnLCAnb25jZScsICdyZWYnLCAnc2NoZW1hJ10pO1xuICAgICAgICByZXR1cm4gTW9kaWZ5LnNjaGVtYSh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIH1cblxuICAgICRfbXV0YXRlUmVidWlsZCgpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IGFkZCB0aGlzIHJ1bGUgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIHRoaXMuX3JlZnMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5faWRzLnJlc2V0KCk7XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChpdGVtLCB7IHNvdXJjZSwgbmFtZSwgcGF0aCwga2V5IH0pID0+IHtcblxuICAgICAgICAgICAgY29uc3QgZmFtaWx5ID0gdGhpcy5fZGVmaW5pdGlvbltzb3VyY2VdW25hbWVdICYmIHRoaXMuX2RlZmluaXRpb25bc291cmNlXVtuYW1lXS5yZWdpc3RlcjtcbiAgICAgICAgICAgIGlmIChmYW1pbHkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kX211dGF0ZVJlZ2lzdGVyKGl0ZW0sIHsgZmFtaWx5LCBrZXkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy4kX21vZGlmeSh7IGVhY2ggfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2RlZmluaXRpb24ucmVidWlsZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVmaW5pdGlvbi5yZWJ1aWxkKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAkX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSwgeyBmYW1pbHksIGtleSB9ID0ge30pIHtcblxuICAgICAgICB0aGlzLl9yZWZzLnJlZ2lzdGVyKHNjaGVtYSwgZmFtaWx5KTtcbiAgICAgICAgdGhpcy5faWRzLnJlZ2lzdGVyKHNjaGVtYSwgeyBrZXkgfSk7XG4gICAgfVxuXG4gICAgJF9wcm9wZXJ0eShuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb24ucHJvcGVydGllc1tuYW1lXTtcbiAgICB9XG5cbiAgICAkX3JlYWNoKHBhdGgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5faWRzLnJlYWNoKHBhdGgpO1xuICAgIH1cblxuICAgICRfcm9vdFJlZmVyZW5jZXMoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZnMucm9vdHMoKTtcbiAgICB9XG5cbiAgICAkX3NldEZsYWcobmFtZSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydChuYW1lWzBdID09PSAnXycgfHwgIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHNldCBmbGFnIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBjb25zdCBmbGFnID0gdGhpcy5fZGVmaW5pdGlvbi5mbGFnc1tuYW1lXSB8fCB7fTtcbiAgICAgICAgaWYgKERlZXBFcXVhbCh2YWx1ZSwgZmxhZy5kZWZhdWx0KSkge1xuICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoRGVlcEVxdWFsKHZhbHVlLCB0aGlzLl9mbGFnc1tuYW1lXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gb3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgPyB0aGlzLmNsb25lKCkgOiB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmouX2ZsYWdzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3Rlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqLl9mbGFnc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lWzBdICE9PSAnXycpIHtcbiAgICAgICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAkX3BhcmVudChtZXRob2QsIC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2RdW0NvbW1vbi5zeW1ib2xzLnBhcmVudF0uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICB9XG5cbiAgICAkX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICByZXR1cm4gVmFsaWRhdG9yLnZhbGlkYXRlKHZhbHVlLCB0aGlzLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgIC8vIEludGVybmFsc1xuXG4gICAgX2Fzc2lnbih0YXJnZXQpIHtcblxuICAgICAgICB0YXJnZXQudHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgICB0YXJnZXQuJF9yb290ID0gdGhpcy4kX3Jvb3Q7XG5cbiAgICAgICAgdGFyZ2V0LiRfdGVtcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJF90ZW1wKTtcbiAgICAgICAgdGFyZ2V0LiRfdGVtcC53aGVucyA9IHt9O1xuXG4gICAgICAgIHRhcmdldC5faWRzID0gdGhpcy5faWRzLmNsb25lKCk7XG4gICAgICAgIHRhcmdldC5fcHJlZmVyZW5jZXMgPSB0aGlzLl9wcmVmZXJlbmNlcztcbiAgICAgICAgdGFyZ2V0Ll92YWxpZHMgPSB0aGlzLl92YWxpZHMgJiYgdGhpcy5fdmFsaWRzLmNsb25lKCk7XG4gICAgICAgIHRhcmdldC5faW52YWxpZHMgPSB0aGlzLl9pbnZhbGlkcyAmJiB0aGlzLl9pbnZhbGlkcy5jbG9uZSgpO1xuICAgICAgICB0YXJnZXQuX3J1bGVzID0gdGhpcy5fcnVsZXMuc2xpY2UoKTtcbiAgICAgICAgdGFyZ2V0Ll9zaW5nbGVSdWxlcyA9IENsb25lKHRoaXMuX3NpbmdsZVJ1bGVzLCB7IHNoYWxsb3c6IHRydWUgfSk7XG4gICAgICAgIHRhcmdldC5fcmVmcyA9IHRoaXMuX3JlZnMuY2xvbmUoKTtcbiAgICAgICAgdGFyZ2V0Ll9mbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2ZsYWdzKTtcbiAgICAgICAgdGFyZ2V0Ll9jYWNoZSA9IG51bGw7XG5cbiAgICAgICAgdGFyZ2V0LiRfdGVybXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy4kX3Rlcm1zKSB7XG4gICAgICAgICAgICB0YXJnZXQuJF90ZXJtc1trZXldID0gdGhpcy4kX3Rlcm1zW2tleV0gPyB0aGlzLiRfdGVybXNba2V5XS5zbGljZSgpIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbiAgICAgICAgdGFyZ2V0LiRfc3VwZXIgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBvdmVycmlkZSBpbiB0aGlzLiRfc3VwZXIpIHtcbiAgICAgICAgICAgIHRhcmdldC4kX3N1cGVyW292ZXJyaWRlXSA9IHRoaXMuX3N1cGVyW292ZXJyaWRlXS5iaW5kKHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIF9iYXJlKCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9yZXNldCgpO1xuXG4gICAgICAgIGNvbnN0IHRlcm1zID0gb2JqLl9kZWZpbml0aW9uLnRlcm1zO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGVybXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlcm0gPSB0ZXJtc1tuYW1lXTtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW25hbWVdID0gdGVybS5pbml0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICBfZGVmYXVsdChmbGFnLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgJ2xpdGVyYWwnKTtcblxuICAgICAgICBBc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ01pc3NpbmcnLCBmbGFnLCAndmFsdWUnKTtcbiAgICAgICAgQXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhb3B0aW9ucy5saXRlcmFsLCAnT25seSBmdW5jdGlvbiB2YWx1ZSBzdXBwb3J0cyBsaXRlcmFsIG9wdGlvbicpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIG9wdGlvbnMubGl0ZXJhbCkge1xuXG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBbQ29tbW9uLnN5bWJvbHMubGl0ZXJhbF06IHRydWUsXG4gICAgICAgICAgICAgICAgbGl0ZXJhbDogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfc2V0RmxhZyhmbGFnLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX2dlbmVyYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuJF90ZXJtcy53aGVucykge1xuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiB0aGlzIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2xsZWN0IG1hdGNoaW5nIHdoZW5zXG5cbiAgICAgICAgY29uc3Qgd2hlbnMgPSBbXTtcbiAgICAgICAgY29uc3QgaWRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4kX3Rlcm1zLndoZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB3aGVuID0gdGhpcy4kX3Rlcm1zLndoZW5zW2ldO1xuXG4gICAgICAgICAgICBpZiAod2hlbi5jb25jYXQpIHtcbiAgICAgICAgICAgICAgICB3aGVucy5wdXNoKHdoZW4uY29uY2F0KTtcbiAgICAgICAgICAgICAgICBpZHMucHVzaChgJHtpfS5jb25jYXRgKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB3aGVuLnJlZiA/IHdoZW4ucmVmLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcykgOiB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RzID0gd2hlbi5pcyA/IFt3aGVuXSA6IHdoZW4uc3dpdGNoO1xuICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gaWRzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXMsIHRoZW4sIG90aGVyd2lzZSB9ID0gdGVzdHNbal07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlSWQgPSBgJHtpfSR7d2hlbi5zd2l0Y2ggPyAnLicgKyBqIDogJyd9YDtcbiAgICAgICAgICAgICAgICBpZiAoaXMuJF9tYXRjaChpbnB1dCwgc3RhdGUubmVzdChpcywgYCR7YmFzZUlkfS5pc2ApLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgYCR7YmFzZUlkfS50aGVuYF0sIHN0YXRlLmFuY2VzdG9ycywgc3RhdGUuc2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYTogZ2VuZXJhdGVkLCBpZCB9ID0gdGhlbi5fZ2VuZXJhdGUodmFsdWUsIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5zLnB1c2goZ2VuZXJhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKGAke2Jhc2VJZH0udGhlbiR7aWQgPyBgKCR7aWR9KWAgOiAnJ31gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyd2lzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGAke2Jhc2VJZH0ub3RoZXJ3aXNlYF0sIHN0YXRlLmFuY2VzdG9ycywgc3RhdGUuc2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hOiBnZW5lcmF0ZWQsIGlkIH0gPSBvdGhlcndpc2UuX2dlbmVyYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIHdoZW5zLnB1c2goZ2VuZXJhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWRzLnB1c2goYCR7YmFzZUlkfS5vdGhlcndpc2Uke2lkID8gYCgke2lkfSlgIDogJyd9YCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdoZW4uYnJlYWsgJiZcbiAgICAgICAgICAgICAgICBpZHMubGVuZ3RoID4gYmVmb3JlKSB7ICAgICAgICAgIC8vIFNvbWV0aGluZyBtYXRjaGVkXG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGNhY2hlXG5cbiAgICAgICAgY29uc3QgaWQgPSBpZHMuam9pbignLCAnKTtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmRlYnVnKHN0YXRlLCAncnVsZScsICd3aGVuJywgaWQpO1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogdGhpcyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5tYWluc3RheS50cmFjZXIuYWN0aXZlICYmXG4gICAgICAgICAgICB0aGlzLiRfdGVtcC53aGVuc1tpZF0pIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiB0aGlzLiRfdGVtcC53aGVuc1tpZF0sIGlkIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBkeW5hbWljIHNjaGVtYVxuXG4gICAgICAgIGxldCBvYmogPSB0aGlzOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gICAgICAgIGlmICh0aGlzLl9kZWZpbml0aW9uLmdlbmVyYXRlKSB7XG4gICAgICAgICAgICBvYmogPSB0aGlzLl9kZWZpbml0aW9uLmdlbmVyYXRlKHRoaXMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgd2hlbnNcblxuICAgICAgICBmb3IgKGNvbnN0IHdoZW4gb2Ygd2hlbnMpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iai5jb25jYXQod2hlbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjaW5nXG5cbiAgICAgICAgaWYgKHRoaXMuJF9yb290Ll90cmFjZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJF9yb290Ll90cmFjZXIuX2NvbWJpbmUob2JqLCBbdGhpcywgLi4ud2hlbnNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhY2hlIHJlc3VsdFxuXG4gICAgICAgIHRoaXMuJF90ZW1wLndoZW5zW2lkXSA9IG9iajtcbiAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiBvYmosIGlkIH07XG4gICAgfVxuXG4gICAgX2lubmVyKHR5cGUsIHZhbHVlcywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgYENhbm5vdCBzZXQgJHt0eXBlfSBpbnNpZGUgYSBydWxlc2V0YCk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBpZiAoIW9iai4kX3Rlcm1zW3R5cGVdIHx8XG4gICAgICAgICAgICBvcHRpb25zLm92ZXJyaWRlKSB7XG5cbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zaW5nbGUpIHtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdLnB1c2godmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdLnB1c2goLi4udmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9pblJ1bGVzZXQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF90ZW1wLnJ1bGVzZXQgIT09IG51bGwgJiYgdGhpcy4kX3RlbXAucnVsZXNldCAhPT0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3J1bGVSZW1vdmUobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zaW5nbGVSdWxlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gb3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgPyB0aGlzLmNsb25lKCkgOiB0aGlzO1xuXG4gICAgICAgIG9iai5fc2luZ2xlUnVsZXMuZGVsZXRlKG5hbWUpO1xuXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLl9ydWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdGVzdCA9IG9iai5fcnVsZXNbaV07XG4gICAgICAgICAgICBpZiAodGVzdC5uYW1lID09PSBuYW1lICYmXG4gICAgICAgICAgICAgICAgIXRlc3Qua2VlcCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKG9iai5faW5SdWxlc2V0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaSA8IG9iai4kX3RlbXAucnVsZXNldCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC0tb2JqLiRfdGVtcC5ydWxlc2V0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKHRlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9ydWxlcyA9IGZpbHRlcmVkO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF92YWx1ZXModmFsdWVzLCBrZXkpIHtcblxuICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsIGtleS5zbGljZSgxLCAtMSkpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBjb25zdCBvdmVycmlkZSA9IHZhbHVlc1swXSA9PT0gQ29tbW9uLnN5bWJvbHMub3ZlcnJpZGU7XG4gICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLnNsaWNlKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvYmpba2V5XSAmJlxuICAgICAgICAgICAgdmFsdWVzLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBvYmpba2V5XSA9IG5ldyBWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZXMubGVuZ3RoID8gbmV3IFZhbHVlcygpIDogbnVsbDtcbiAgICAgICAgICAgIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2JqW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIG9ialtrZXldLm92ZXJyaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCBhbGxvdy92YWxpZC9pbnZhbGlkIHdpdGggdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICBBc3NlcnQodmFsdWUgIT09IENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlLCAnT3ZlcnJpZGUgbXVzdCBiZSB0aGUgZmlyc3QgdmFsdWUnKTtcblxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBrZXkgPT09ICdfaW52YWxpZHMnID8gJ192YWxpZHMnIDogJ19pbnZhbGlkcyc7XG4gICAgICAgICAgICBpZiAob2JqW290aGVyXSkge1xuICAgICAgICAgICAgICAgIG9ialtvdGhlcl0ucmVtb3ZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9ialtvdGhlcl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChrZXkgPT09ICdfdmFsaWRzJyB8fCAhb2JqLl9mbGFncy5vbmx5LCAnU2V0dGluZyBpbnZhbGlkIHZhbHVlJywgdmFsdWUsICdsZWF2ZXMgc2NoZW1hIHJlamVjdGluZyBhbGwgdmFsdWVzIGR1ZSB0byBwcmV2aW91cyB2YWxpZCBydWxlJyk7XG4gICAgICAgICAgICAgICAgICAgIG9ialtvdGhlcl0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqW2tleV0uYWRkKHZhbHVlLCBvYmouX3JlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5CYXNlLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy5hbnldID0ge1xuICAgIHZlcnNpb246IENvbW1vbi52ZXJzaW9uLFxuICAgIGNvbXBpbGU6IENvbXBpbGUuY29tcGlsZSxcbiAgICByb290OiAnJF9yb290J1xufTtcblxuXG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaXNJbW11dGFibGUgPSB0cnVlOyAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBIb2VrIGZyb20gZGVlcCBjbG9uaW5nIHNjaGVtYSBvYmplY3RzIChtdXN0IGJlIG9uIHByb3RvdHlwZSlcblxuXG4vLyBBbGlhc2VzXG5cbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5kZW55ID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmludmFsaWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuZGlzYWxsb3cgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaW52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5lcXVhbCA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5leGlzdCA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5yZXF1aXJlZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5ub3QgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaW52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5vcHRpb25zID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZzO1xuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZlcmVuY2VzID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZzO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IGludGVybmFscy5CYXNlKCk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/base.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/cache.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/cache.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"@hapi/hoek/lib/clone\");\n\nconst Common = __webpack_require__(/*! ./common */ \"./node_modules/joi/lib/common.js\");\n\n\nconst internals = {\n    max: 1000,\n    supported: new Set(['undefined', 'boolean', 'number', 'string'])\n};\n\n\nexports.provider = {\n\n    provision(options) {\n\n        return new internals.Cache(options);\n    }\n};\n\n\n// Least Recently Used (LRU) Cache\n\ninternals.Cache = class {\n\n    constructor(options = {}) {\n\n        Common.assertOptions(options, ['max']);\n        Assert(options.max === undefined || options.max && options.max > 0 && isFinite(options.max), 'Invalid max cache size');\n\n        this._max = options.max || internals.max;\n\n        this._map = new Map();                          // Map of nodes by key\n        this._list = new internals.List();              // List of nodes (most recently used in head)\n    }\n\n    get length() {\n\n        return this._map.size;\n    }\n\n    set(key, value) {\n\n        if (key !== null &&\n            !internals.supported.has(typeof key)) {\n\n            return;\n        }\n\n        let node = this._map.get(key);\n        if (node) {\n            node.value = value;\n            this._list.first(node);\n            return;\n        }\n\n        node = this._list.unshift({ key, value });\n        this._map.set(key, node);\n        this._compact();\n    }\n\n    get(key) {\n\n        const node = this._map.get(key);\n        if (node) {\n            this._list.first(node);\n            return Clone(node.value);\n        }\n    }\n\n    _compact() {\n\n        if (this._map.size > this._max) {\n            const node = this._list.pop();\n            this._map.delete(node.key);\n        }\n    }\n};\n\n\ninternals.List = class {\n\n    constructor() {\n\n        this.tail = null;\n        this.head = null;\n    }\n\n    unshift(node) {\n\n        node.next = null;\n        node.prev = this.head;\n\n        if (this.head) {\n            this.head.next = node;\n        }\n\n        this.head = node;\n\n        if (!this.tail) {\n            this.tail = node;\n        }\n\n        return node;\n    }\n\n    first(node) {\n\n        if (node === this.head) {\n            return;\n        }\n\n        this._remove(node);\n        this.unshift(node);\n    }\n\n    pop() {\n\n        return this._remove(this.tail);\n    }\n\n    _remove(node) {\n\n        const { next, prev } = node;\n\n        next.prev = prev;\n\n        if (prev) {\n            prev.next = next;\n        }\n\n        if (node === this.tail) {\n            this.tail = next;\n        }\n\n        node.prev = null;\n        node.next = null;\n\n        return node;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9jYWNoZS5qcz81MGJkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxvREFBdUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLGtEQUFzQjs7QUFFNUMsZUFBZSxtQkFBTyxDQUFDLGtEQUFVOzs7QUFHakM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBOztBQUVBLDhCQUE4QjtBQUM5QiwwQ0FBMEM7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsYUFBYTs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9qb2kvbGliL2NhY2hlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbWF4OiAxMDAwLFxuICAgIHN1cHBvcnRlZDogbmV3IFNldChbJ3VuZGVmaW5lZCcsICdib29sZWFuJywgJ251bWJlcicsICdzdHJpbmcnXSlcbn07XG5cblxuZXhwb3J0cy5wcm92aWRlciA9IHtcblxuICAgIHByb3Zpc2lvbihvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQ2FjaGUob3B0aW9ucyk7XG4gICAgfVxufTtcblxuXG4vLyBMZWFzdCBSZWNlbnRseSBVc2VkIChMUlUpIENhY2hlXG5cbmludGVybmFscy5DYWNoZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnbWF4J10pO1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5tYXggPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm1heCAmJiBvcHRpb25zLm1heCA+IDAgJiYgaXNGaW5pdGUob3B0aW9ucy5tYXgpLCAnSW52YWxpZCBtYXggY2FjaGUgc2l6ZScpO1xuXG4gICAgICAgIHRoaXMuX21heCA9IG9wdGlvbnMubWF4IHx8IGludGVybmFscy5tYXg7XG5cbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFwIG9mIG5vZGVzIGJ5IGtleVxuICAgICAgICB0aGlzLl9saXN0ID0gbmV3IGludGVybmFscy5MaXN0KCk7ICAgICAgICAgICAgICAvLyBMaXN0IG9mIG5vZGVzIChtb3N0IHJlY2VudGx5IHVzZWQgaW4gaGVhZClcbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuc2l6ZTtcbiAgICB9XG5cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChrZXkgIT09IG51bGwgJiZcbiAgICAgICAgICAgICFpbnRlcm5hbHMuc3VwcG9ydGVkLmhhcyh0eXBlb2Yga2V5KSkge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2xpc3QuZmlyc3Qobm9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gdGhpcy5fbGlzdC51bnNoaWZ0KHsga2V5LCB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIG5vZGUpO1xuICAgICAgICB0aGlzLl9jb21wYWN0KCk7XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0LmZpcnN0KG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIENsb25lKG5vZGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NvbXBhY3QoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX21hcC5zaXplID4gdGhpcy5fbWF4KSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fbGlzdC5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUobm9kZS5rZXkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuTGlzdCA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgfVxuXG4gICAgdW5zaGlmdChub2RlKSB7XG5cbiAgICAgICAgbm9kZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgbm9kZS5wcmV2ID0gdGhpcy5oZWFkO1xuXG4gICAgICAgIGlmICh0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZC5uZXh0ID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XG5cbiAgICAgICAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBmaXJzdChub2RlKSB7XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlKG5vZGUpO1xuICAgICAgICB0aGlzLnVuc2hpZnQobm9kZSk7XG4gICAgfVxuXG4gICAgcG9wKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmUodGhpcy50YWlsKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlKG5vZGUpIHtcblxuICAgICAgICBjb25zdCB7IG5leHQsIHByZXYgfSA9IG5vZGU7XG5cbiAgICAgICAgbmV4dC5wcmV2ID0gcHJldjtcblxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnByZXYgPSBudWxsO1xuICAgICAgICBub2RlLm5leHQgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/cache.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/common.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/common.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst AssertError = __webpack_require__(/*! @hapi/hoek/lib/error */ \"@hapi/hoek/lib/error\");\n\nconst Pkg = __webpack_require__(/*! ../package.json */ \"./node_modules/joi/package.json\");\n\nlet Messages;\nlet Schemas;\n\n\nconst internals = {\n    isoDate: /^(?:[-+]\\d{2})?(?:\\d{4}(?!\\d{2}\\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\\1(?:[12]\\d|0[1-9]|3[01]))?|W(?:[0-4]\\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\\d|[12]\\d{2}|3(?:[0-5]\\d|6[1-6])))(?![T]$|[T][\\d]+Z$)(?:[T\\s](?:(?:(?:[01]\\d|2[0-3])(?:(:?)[0-5]\\d)?|24\\:?00)(?:[.,]\\d+(?!:))?)(?:\\2[0-5]\\d(?:[.,]\\d+)?)?(?:[Z]|(?:[+-])(?:[01]\\d|2[0-3])(?::?[0-5]\\d)?)?)?)?$/\n};\n\n\nexports.version = Pkg.version;\n\n\nexports.defaults = {\n    abortEarly: true,\n    allowUnknown: false,\n    artifacts: false,\n    cache: true,\n    context: null,\n    convert: true,\n    dateFormat: 'iso',\n    errors: {\n        escapeHtml: false,\n        label: 'path',\n        language: null,\n        render: true,\n        stack: false,\n        wrap: {\n            label: '\"',\n            array: '[]'\n        }\n    },\n    externals: true,\n    messages: {},\n    nonEnumerables: false,\n    noDefaults: false,\n    presence: 'optional',\n    skipFunctions: false,\n    stripUnknown: false,\n    warnings: false\n};\n\n\nexports.symbols = {\n    any: Symbol.for('@hapi/joi/schema'),            // Used to internally identify any-based types (shared with other joi versions)\n    arraySingle: Symbol('arraySingle'),\n    deepDefault: Symbol('deepDefault'),\n    errors: Symbol('errors'),\n    literal: Symbol('literal'),\n    override: Symbol('override'),\n    parent: Symbol('parent'),\n    prefs: Symbol('prefs'),\n    ref: Symbol('ref'),\n    template: Symbol('template'),\n    values: Symbol('values')\n};\n\n\nexports.assertOptions = function (options, keys, name = 'Options') {\n\n    Assert(options && typeof options === 'object' && !Array.isArray(options), 'Options must be of type object');\n    const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));\n    Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);\n};\n\n\nexports.checkPreferences = function (prefs) {\n\n    Schemas = Schemas || __webpack_require__(/*! ./schemas */ \"./node_modules/joi/lib/schemas.js\");\n\n    const result = Schemas.preferences.validate(prefs);\n\n    if (result.error) {\n        throw new AssertError([result.error.details[0].message]);\n    }\n};\n\n\nexports.compare = function (a, b, operator) {\n\n    switch (operator) {\n        case '=': return a === b;\n        case '>': return a > b;\n        case '<': return a < b;\n        case '>=': return a >= b;\n        case '<=': return a <= b;\n    }\n};\n\n\nexports.default = function (value, defaultValue) {\n\n    return value === undefined ? defaultValue : value;\n};\n\n\nexports.isIsoDate = function (date) {\n\n    return internals.isoDate.test(date);\n};\n\n\nexports.isNumber = function (value) {\n\n    return typeof value === 'number' && !isNaN(value);\n};\n\n\nexports.isResolvable = function (obj) {\n\n    if (!obj) {\n        return false;\n    }\n\n    return obj[exports.symbols.ref] || obj[exports.symbols.template];\n};\n\n\nexports.isSchema = function (schema, options = {}) {\n\n    const any = schema && schema[exports.symbols.any];\n    if (!any) {\n        return false;\n    }\n\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\n    return true;\n};\n\n\nexports.isValues = function (obj) {\n\n    return obj[exports.symbols.values];\n};\n\n\nexports.limit = function (value) {\n\n    return Number.isSafeInteger(value) && value >= 0;\n};\n\n\nexports.preferences = function (target, source) {\n\n    Messages = Messages || __webpack_require__(/*! ./messages */ \"./node_modules/joi/lib/messages.js\");\n\n    target = target || {};\n    source = source || {};\n\n    const merged = Object.assign({}, target, source);\n    if (source.errors &&\n        target.errors) {\n\n        merged.errors = Object.assign({}, target.errors, source.errors);\n        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);\n    }\n\n    if (source.messages) {\n        merged.messages = Messages.compile(source.messages, target.messages);\n    }\n\n    delete merged[exports.symbols.prefs];\n    return merged;\n};\n\n\nexports.tryWithPath = function (fn, key, options = {}) {\n\n    try {\n        return fn();\n    }\n    catch (err) {\n        if (err.path !== undefined) {\n            err.path = key + '.' + err.path;\n        }\n        else {\n            err.path = key;\n        }\n\n        if (options.append) {\n            err.message = `${err.message} (${err.path})`;\n        }\n\n        throw err;\n    }\n};\n\n\nexports.validateArg = function (value, label, { assert, message }) {\n\n    if (exports.isSchema(assert)) {\n        const result = assert.validate(value);\n        if (!result.error) {\n            return;\n        }\n\n        return result.error.message;\n    }\n    else if (!assert(value)) {\n        return label ? `${label} ${message}` : message;\n    }\n};\n\n\nexports.verifyFlat = function (args, method) {\n\n    for (const arg of args) {\n        Assert(!Array.isArray(arg), 'Method no longer accepts array arguments:', method);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9jb21tb24uanM/N2EzZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0RBQXVCO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLGtEQUFzQjs7QUFFbEQsWUFBWSxtQkFBTyxDQUFDLHdEQUFpQjs7QUFFckM7QUFDQTs7O0FBR0E7QUFDQSx5QkFBeUIsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLHlIQUF5SCxFQUFFO0FBQ3hLOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxLQUFLLHlCQUF5QixZQUFZO0FBQ2xGOzs7QUFHQTs7QUFFQSx5QkFBeUIsbUJBQU8sQ0FBQyxvREFBVzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUEsMkJBQTJCLG1CQUFPLENBQUMsc0RBQVk7O0FBRS9DO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLFlBQVksSUFBSSxTQUFTO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsK0NBQStDLGtCQUFrQjs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTSxHQUFHLFFBQVE7QUFDM0M7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvam9pL2xpYi9jb21tb24uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQXNzZXJ0RXJyb3IgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9lcnJvcicpO1xuXG5jb25zdCBQa2cgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcblxubGV0IE1lc3NhZ2VzO1xubGV0IFNjaGVtYXM7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGlzb0RhdGU6IC9eKD86Wy0rXVxcZHsyfSk/KD86XFxkezR9KD8hXFxkezJ9XFxiKSkoPzooLT8pKD86KD86MFsxLTldfDFbMC0yXSkoPzpcXDEoPzpbMTJdXFxkfDBbMS05XXwzWzAxXSkpP3xXKD86WzAtNF1cXGR8NVswLTJdKSg/Oi0/WzEtN10pP3woPzowMFsxLTldfDBbMS05XVxcZHxbMTJdXFxkezJ9fDMoPzpbMC01XVxcZHw2WzEtNl0pKSkoPyFbVF0kfFtUXVtcXGRdK1okKSg/OltUXFxzXSg/Oig/Oig/OlswMV1cXGR8MlswLTNdKSg/Oig6PylbMC01XVxcZCk/fDI0XFw6PzAwKSg/OlsuLF1cXGQrKD8hOikpPykoPzpcXDJbMC01XVxcZCg/OlsuLF1cXGQrKT8pPyg/OltaXXwoPzpbKy1dKSg/OlswMV1cXGR8MlswLTNdKSg/Ojo/WzAtNV1cXGQpPyk/KT8pPyQvXG59O1xuXG5cbmV4cG9ydHMudmVyc2lvbiA9IFBrZy52ZXJzaW9uO1xuXG5cbmV4cG9ydHMuZGVmYXVsdHMgPSB7XG4gICAgYWJvcnRFYXJseTogdHJ1ZSxcbiAgICBhbGxvd1Vua25vd246IGZhbHNlLFxuICAgIGFydGlmYWN0czogZmFsc2UsXG4gICAgY2FjaGU6IHRydWUsXG4gICAgY29udGV4dDogbnVsbCxcbiAgICBjb252ZXJ0OiB0cnVlLFxuICAgIGRhdGVGb3JtYXQ6ICdpc28nLFxuICAgIGVycm9yczoge1xuICAgICAgICBlc2NhcGVIdG1sOiBmYWxzZSxcbiAgICAgICAgbGFiZWw6ICdwYXRoJyxcbiAgICAgICAgbGFuZ3VhZ2U6IG51bGwsXG4gICAgICAgIHJlbmRlcjogdHJ1ZSxcbiAgICAgICAgc3RhY2s6IGZhbHNlLFxuICAgICAgICB3cmFwOiB7XG4gICAgICAgICAgICBsYWJlbDogJ1wiJyxcbiAgICAgICAgICAgIGFycmF5OiAnW10nXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGV4dGVybmFsczogdHJ1ZSxcbiAgICBtZXNzYWdlczoge30sXG4gICAgbm9uRW51bWVyYWJsZXM6IGZhbHNlLFxuICAgIG5vRGVmYXVsdHM6IGZhbHNlLFxuICAgIHByZXNlbmNlOiAnb3B0aW9uYWwnLFxuICAgIHNraXBGdW5jdGlvbnM6IGZhbHNlLFxuICAgIHN0cmlwVW5rbm93bjogZmFsc2UsXG4gICAgd2FybmluZ3M6IGZhbHNlXG59O1xuXG5cbmV4cG9ydHMuc3ltYm9scyA9IHtcbiAgICBhbnk6IFN5bWJvbC5mb3IoJ0BoYXBpL2pvaS9zY2hlbWEnKSwgICAgICAgICAgICAvLyBVc2VkIHRvIGludGVybmFsbHkgaWRlbnRpZnkgYW55LWJhc2VkIHR5cGVzIChzaGFyZWQgd2l0aCBvdGhlciBqb2kgdmVyc2lvbnMpXG4gICAgYXJyYXlTaW5nbGU6IFN5bWJvbCgnYXJyYXlTaW5nbGUnKSxcbiAgICBkZWVwRGVmYXVsdDogU3ltYm9sKCdkZWVwRGVmYXVsdCcpLFxuICAgIGVycm9yczogU3ltYm9sKCdlcnJvcnMnKSxcbiAgICBsaXRlcmFsOiBTeW1ib2woJ2xpdGVyYWwnKSxcbiAgICBvdmVycmlkZTogU3ltYm9sKCdvdmVycmlkZScpLFxuICAgIHBhcmVudDogU3ltYm9sKCdwYXJlbnQnKSxcbiAgICBwcmVmczogU3ltYm9sKCdwcmVmcycpLFxuICAgIHJlZjogU3ltYm9sKCdyZWYnKSxcbiAgICB0ZW1wbGF0ZTogU3ltYm9sKCd0ZW1wbGF0ZScpLFxuICAgIHZhbHVlczogU3ltYm9sKCd2YWx1ZXMnKVxufTtcblxuXG5leHBvcnRzLmFzc2VydE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucywga2V5cywgbmFtZSA9ICdPcHRpb25zJykge1xuXG4gICAgQXNzZXJ0KG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9wdGlvbnMpLCAnT3B0aW9ucyBtdXN0IGJlIG9mIHR5cGUgb2JqZWN0Jyk7XG4gICAgY29uc3QgdW5rbm93bktleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoKGspID0+ICFrZXlzLmluY2x1ZGVzKGspKTtcbiAgICBBc3NlcnQodW5rbm93bktleXMubGVuZ3RoID09PSAwLCBgJHtuYW1lfSBjb250YWluIHVua25vd24ga2V5czogJHt1bmtub3duS2V5c31gKTtcbn07XG5cblxuZXhwb3J0cy5jaGVja1ByZWZlcmVuY2VzID0gZnVuY3Rpb24gKHByZWZzKSB7XG5cbiAgICBTY2hlbWFzID0gU2NoZW1hcyB8fCByZXF1aXJlKCcuL3NjaGVtYXMnKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IFNjaGVtYXMucHJlZmVyZW5jZXMudmFsaWRhdGUocHJlZnMpO1xuXG4gICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0RXJyb3IoW3Jlc3VsdC5lcnJvci5kZXRhaWxzWzBdLm1lc3NhZ2VdKTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiLCBvcGVyYXRvcikge1xuXG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlICc9JzogcmV0dXJuIGEgPT09IGI7XG4gICAgICAgIGNhc2UgJz4nOiByZXR1cm4gYSA+IGI7XG4gICAgICAgIGNhc2UgJzwnOiByZXR1cm4gYSA8IGI7XG4gICAgICAgIGNhc2UgJz49JzogcmV0dXJuIGEgPj0gYjtcbiAgICAgICAgY2FzZSAnPD0nOiByZXR1cm4gYSA8PSBiO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG59O1xuXG5cbmV4cG9ydHMuaXNJc29EYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcblxuICAgIHJldHVybiBpbnRlcm5hbHMuaXNvRGF0ZS50ZXN0KGRhdGUpO1xufTtcblxuXG5leHBvcnRzLmlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpO1xufTtcblxuXG5leHBvcnRzLmlzUmVzb2x2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqW2V4cG9ydHMuc3ltYm9scy5yZWZdIHx8IG9ialtleHBvcnRzLnN5bWJvbHMudGVtcGxhdGVdO1xufTtcblxuXG5leHBvcnRzLmlzU2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBjb25zdCBhbnkgPSBzY2hlbWEgJiYgc2NoZW1hW2V4cG9ydHMuc3ltYm9scy5hbnldO1xuICAgIGlmICghYW55KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBBc3NlcnQob3B0aW9ucy5sZWdhY3kgfHwgYW55LnZlcnNpb24gPT09IGV4cG9ydHMudmVyc2lvbiwgJ0Nhbm5vdCBtaXggZGlmZmVyZW50IHZlcnNpb25zIG9mIGpvaSBzY2hlbWFzJyk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmV4cG9ydHMuaXNWYWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICByZXR1cm4gb2JqW2V4cG9ydHMuc3ltYm9scy52YWx1ZXNdO1xufTtcblxuXG5leHBvcnRzLmxpbWl0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpICYmIHZhbHVlID49IDA7XG59O1xuXG5cbmV4cG9ydHMucHJlZmVyZW5jZXMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblxuICAgIE1lc3NhZ2VzID0gTWVzc2FnZXMgfHwgcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHt9O1xuICAgIHNvdXJjZSA9IHNvdXJjZSB8fCB7fTtcblxuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgc291cmNlKTtcbiAgICBpZiAoc291cmNlLmVycm9ycyAmJlxuICAgICAgICB0YXJnZXQuZXJyb3JzKSB7XG5cbiAgICAgICAgbWVyZ2VkLmVycm9ycyA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldC5lcnJvcnMsIHNvdXJjZS5lcnJvcnMpO1xuICAgICAgICBtZXJnZWQuZXJyb3JzLndyYXAgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQuZXJyb3JzLndyYXAsIHNvdXJjZS5lcnJvcnMud3JhcCk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5tZXNzYWdlcykge1xuICAgICAgICBtZXJnZWQubWVzc2FnZXMgPSBNZXNzYWdlcy5jb21waWxlKHNvdXJjZS5tZXNzYWdlcywgdGFyZ2V0Lm1lc3NhZ2VzKTtcbiAgICB9XG5cbiAgICBkZWxldGUgbWVyZ2VkW2V4cG9ydHMuc3ltYm9scy5wcmVmc107XG4gICAgcmV0dXJuIG1lcmdlZDtcbn07XG5cblxuZXhwb3J0cy50cnlXaXRoUGF0aCA9IGZ1bmN0aW9uIChmbiwga2V5LCBvcHRpb25zID0ge30pIHtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnIucGF0aCA9IGtleSArICcuJyArIGVyci5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyLnBhdGggPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hcHBlbmQpIHtcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYCR7ZXJyLm1lc3NhZ2V9ICgke2Vyci5wYXRofSlgO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy52YWxpZGF0ZUFyZyA9IGZ1bmN0aW9uICh2YWx1ZSwgbGFiZWwsIHsgYXNzZXJ0LCBtZXNzYWdlIH0pIHtcblxuICAgIGlmIChleHBvcnRzLmlzU2NoZW1hKGFzc2VydCkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXNzZXJ0LnZhbGlkYXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFzc2VydCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsID8gYCR7bGFiZWx9ICR7bWVzc2FnZX1gIDogbWVzc2FnZTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMudmVyaWZ5RmxhdCA9IGZ1bmN0aW9uIChhcmdzLCBtZXRob2QpIHtcblxuICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgQXNzZXJ0KCFBcnJheS5pc0FycmF5KGFyZyksICdNZXRob2Qgbm8gbG9uZ2VyIGFjY2VwdHMgYXJyYXkgYXJndW1lbnRzOicsIG1ldGhvZCk7XG4gICAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/common.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/compile.js":
/*!*****************************************!*\
  !*** ./node_modules/joi/lib/compile.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\n\nconst Common = __webpack_require__(/*! ./common */ \"./node_modules/joi/lib/common.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"./node_modules/joi/lib/ref.js\");\n\n\nconst internals = {};\n\n\nexports.schema = function (Joi, config, options = {}) {\n\n    Common.assertOptions(options, ['appendPath', 'override']);\n\n    try {\n        return internals.schema(Joi, config, options);\n    }\n    catch (err) {\n        if (options.appendPath &&\n            err.path !== undefined) {\n\n            err.message = `${err.message} (${err.path})`;\n        }\n\n        throw err;\n    }\n};\n\n\ninternals.schema = function (Joi, config, options) {\n\n    Assert(config !== undefined, 'Invalid undefined schema');\n\n    if (Array.isArray(config)) {\n        Assert(config.length, 'Invalid empty array schema');\n\n        if (config.length === 1) {\n            config = config[0];\n        }\n    }\n\n    const valid = (base, ...values) => {\n\n        if (options.override !== false) {\n            return base.valid(Joi.override, ...values);\n        }\n\n        return base.valid(...values);\n    };\n\n    if (internals.simple(config)) {\n        return valid(Joi, config);\n    }\n\n    if (typeof config === 'function') {\n        return Joi.custom(config);\n    }\n\n    Assert(typeof config === 'object', 'Invalid schema content:', typeof config);\n\n    if (Common.isResolvable(config)) {\n        return valid(Joi, config);\n    }\n\n    if (Common.isSchema(config)) {\n        return config;\n    }\n\n    if (Array.isArray(config)) {\n        for (const item of config) {\n            if (!internals.simple(item)) {\n                return Joi.alternatives().try(...config);\n            }\n        }\n\n        return valid(Joi, ...config);\n    }\n\n    if (config instanceof RegExp) {\n        return Joi.string().regex(config);\n    }\n\n    if (config instanceof Date) {\n        return valid(Joi.date(), config);\n    }\n\n    Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');\n\n    return Joi.object().keys(config);\n};\n\n\nexports.ref = function (id, options) {\n\n    return Ref.isRef(id) ? id : Ref.create(id, options);\n};\n\n\nexports.compile = function (root, schema, options = {}) {\n\n    Common.assertOptions(options, ['legacy']);\n\n    // Compiled by any supported version\n\n    const any = schema && schema[Common.symbols.any];\n    if (any) {\n        Assert(options.legacy || any.version === Common.version, 'Cannot mix different versions of joi schemas:', any.version, Common.version);\n        return schema;\n    }\n\n    // Uncompiled root\n\n    if (typeof schema !== 'object' ||\n        !options.legacy) {\n\n        return exports.schema(root, schema, { appendPath: true });          // Will error if schema contains other versions\n    }\n\n    // Scan schema for compiled parts\n\n    const compiler = internals.walk(schema);\n    if (!compiler) {\n        return exports.schema(root, schema, { appendPath: true });\n    }\n\n    return compiler.compile(compiler.root, schema);\n};\n\n\ninternals.walk = function (schema) {\n\n    if (typeof schema !== 'object') {\n        return null;\n    }\n\n    if (Array.isArray(schema)) {\n        for (const item of schema) {\n            const compiler = internals.walk(item);\n            if (compiler) {\n                return compiler;\n            }\n        }\n\n        return null;\n    }\n\n    const any = schema[Common.symbols.any];\n    if (any) {\n        return { root: schema[any.root], compile: any.compile };\n    }\n\n    Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');\n\n    for (const key in schema) {\n        const compiler = internals.walk(schema[key]);\n        if (compiler) {\n            return compiler;\n        }\n    }\n\n    return null;\n};\n\n\ninternals.simple = function (value) {\n\n    return value === null || ['boolean', 'string', 'number'].includes(typeof value);\n};\n\n\nexports.when = function (schema, condition, options) {\n\n    if (options === undefined) {\n        Assert(condition && typeof condition === 'object', 'Missing options');\n\n        options = condition;\n        condition = Ref.create('.');\n    }\n\n    if (Array.isArray(options)) {\n        options = { switch: options };\n    }\n\n    Common.assertOptions(options, ['is', 'not', 'then', 'otherwise', 'switch', 'break']);\n\n    // Schema condition\n\n    if (Common.isSchema(condition)) {\n        Assert(options.is === undefined, '\"is\" can not be used with a schema condition');\n        Assert(options.not === undefined, '\"not\" can not be used with a schema condition');\n        Assert(options.switch === undefined, '\"switch\" can not be used with a schema condition');\n\n        return internals.condition(schema, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });\n    }\n\n    // Single condition\n\n    Assert(Ref.isRef(condition) || typeof condition === 'string', 'Invalid condition:', condition);\n    Assert(options.not === undefined || options.is === undefined, 'Cannot combine \"is\" with \"not\"');\n\n    if (options.switch === undefined) {\n        let rule = options;\n        if (options.not !== undefined) {\n            rule = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };\n        }\n\n        let is = rule.is !== undefined ? schema.$_compile(rule.is) : schema.$_root.invalid(null, false, 0, '').required();\n        Assert(rule.then !== undefined || rule.otherwise !== undefined, 'options must have at least one of \"then\", \"otherwise\", or \"switch\"');\n        Assert(rule.break === undefined || rule.then === undefined || rule.otherwise === undefined, 'Cannot specify then, otherwise, and break all together');\n\n        if (options.is !== undefined &&\n            !Ref.isRef(options.is) &&\n            !Common.isSchema(options.is)) {\n\n            is = is.required();                     // Only apply required if this wasn't already a schema or a ref\n        }\n\n        return internals.condition(schema, { ref: exports.ref(condition), is, then: rule.then, otherwise: rule.otherwise, break: rule.break });\n    }\n\n    // Switch statement\n\n    Assert(Array.isArray(options.switch), '\"switch\" must be an array');\n    Assert(options.is === undefined, 'Cannot combine \"switch\" with \"is\"');\n    Assert(options.not === undefined, 'Cannot combine \"switch\" with \"not\"');\n    Assert(options.then === undefined, 'Cannot combine \"switch\" with \"then\"');\n\n    const rule = {\n        ref: exports.ref(condition),\n        switch: [],\n        break: options.break\n    };\n\n    for (let i = 0; i < options.switch.length; ++i) {\n        const test = options.switch[i];\n        const last = i === options.switch.length - 1;\n\n        Common.assertOptions(test, last ? ['is', 'then', 'otherwise'] : ['is', 'then']);\n\n        Assert(test.is !== undefined, 'Switch statement missing \"is\"');\n        Assert(test.then !== undefined, 'Switch statement missing \"then\"');\n\n        const item = {\n            is: schema.$_compile(test.is),\n            then: schema.$_compile(test.then)\n        };\n\n        if (!Ref.isRef(test.is) &&\n            !Common.isSchema(test.is)) {\n\n            item.is = item.is.required();           // Only apply required if this wasn't already a schema or a ref\n        }\n\n        if (last) {\n            Assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify \"otherwise\" inside and outside a \"switch\"');\n            const otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;\n            if (otherwise !== undefined) {\n                Assert(rule.break === undefined, 'Cannot specify both otherwise and break');\n                item.otherwise = schema.$_compile(otherwise);\n            }\n        }\n\n        rule.switch.push(item);\n    }\n\n    return rule;\n};\n\n\ninternals.condition = function (schema, condition) {\n\n    for (const key of ['then', 'otherwise']) {\n        if (condition[key] === undefined) {\n            delete condition[key];\n        }\n        else {\n            condition[key] = schema.$_compile(condition[key]);\n        }\n    }\n\n    return condition;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9jb21waWxlLmpzP2U0MWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLG9EQUF1Qjs7QUFFOUMsZUFBZSxtQkFBTyxDQUFDLGtEQUFVO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTzs7O0FBRzNCOzs7QUFHQSxvREFBb0Q7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsWUFBWSxJQUFJLFNBQVM7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7O0FBR0Esc0RBQXNEOztBQUV0RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLG1CQUFtQixFQUFFO0FBQ2xFOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsbUJBQW1CO0FBQ2hFOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLHdGQUF3RjtBQUNwSTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjs7QUFFQSw0Q0FBNEMsaUdBQWlHO0FBQzdJOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9qb2kvbGliL2NvbXBpbGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnNjaGVtYSA9IGZ1bmN0aW9uIChKb2ksIGNvbmZpZywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FwcGVuZFBhdGgnLCAnb3ZlcnJpZGUnXSk7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnNjaGVtYShKb2ksIGNvbmZpZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXBwZW5kUGF0aCAmJlxuICAgICAgICAgICAgZXJyLnBhdGggIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGAke2Vyci5tZXNzYWdlfSAoJHtlcnIucGF0aH0pYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zY2hlbWEgPSBmdW5jdGlvbiAoSm9pLCBjb25maWcsIG9wdGlvbnMpIHtcblxuICAgIEFzc2VydChjb25maWcgIT09IHVuZGVmaW5lZCwgJ0ludmFsaWQgdW5kZWZpbmVkIHNjaGVtYScpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgICAgICBBc3NlcnQoY29uZmlnLmxlbmd0aCwgJ0ludmFsaWQgZW1wdHkgYXJyYXkgc2NoZW1hJyk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZ1swXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkID0gKGJhc2UsIC4uLnZhbHVlcykgPT4ge1xuXG4gICAgICAgIGlmIChvcHRpb25zLm92ZXJyaWRlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2UudmFsaWQoSm9pLm92ZXJyaWRlLCAuLi52YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2UudmFsaWQoLi4udmFsdWVzKTtcbiAgICB9O1xuXG4gICAgaWYgKGludGVybmFscy5zaW1wbGUoY29uZmlnKSkge1xuICAgICAgICByZXR1cm4gdmFsaWQoSm9pLCBjb25maWcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBKb2kuY3VzdG9tKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgQXNzZXJ0KHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzY2hlbWEgY29udGVudDonLCB0eXBlb2YgY29uZmlnKTtcblxuICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkKEpvaSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb25maWcpIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLnNpbXBsZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKb2kuYWx0ZXJuYXRpdmVzKCkudHJ5KC4uLmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsaWQoSm9pLCAuLi5jb25maWcpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuIEpvaS5zdHJpbmcoKS5yZWdleChjb25maWcpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiB2YWxpZChKb2kuZGF0ZSgpLCBjb25maWcpO1xuICAgIH1cblxuICAgIEFzc2VydChPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29uZmlnKSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KSwgJ1NjaGVtYSBjYW4gb25seSBjb250YWluIHBsYWluIG9iamVjdHMnKTtcblxuICAgIHJldHVybiBKb2kub2JqZWN0KCkua2V5cyhjb25maWcpO1xufTtcblxuXG5leHBvcnRzLnJlZiA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuIFJlZi5pc1JlZihpZCkgPyBpZCA6IFJlZi5jcmVhdGUoaWQsIG9wdGlvbnMpO1xufTtcblxuXG5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbiAocm9vdCwgc2NoZW1hLCBvcHRpb25zID0ge30pIHtcblxuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnbGVnYWN5J10pO1xuXG4gICAgLy8gQ29tcGlsZWQgYnkgYW55IHN1cHBvcnRlZCB2ZXJzaW9uXG5cbiAgICBjb25zdCBhbnkgPSBzY2hlbWEgJiYgc2NoZW1hW0NvbW1vbi5zeW1ib2xzLmFueV07XG4gICAgaWYgKGFueSkge1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5sZWdhY3kgfHwgYW55LnZlcnNpb24gPT09IENvbW1vbi52ZXJzaW9uLCAnQ2Fubm90IG1peCBkaWZmZXJlbnQgdmVyc2lvbnMgb2Ygam9pIHNjaGVtYXM6JywgYW55LnZlcnNpb24sIENvbW1vbi52ZXJzaW9uKTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG5cbiAgICAvLyBVbmNvbXBpbGVkIHJvb3RcblxuICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAhb3B0aW9ucy5sZWdhY3kpIHtcblxuICAgICAgICByZXR1cm4gZXhwb3J0cy5zY2hlbWEocm9vdCwgc2NoZW1hLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7ICAgICAgICAgIC8vIFdpbGwgZXJyb3IgaWYgc2NoZW1hIGNvbnRhaW5zIG90aGVyIHZlcnNpb25zXG4gICAgfVxuXG4gICAgLy8gU2NhbiBzY2hlbWEgZm9yIGNvbXBpbGVkIHBhcnRzXG5cbiAgICBjb25zdCBjb21waWxlciA9IGludGVybmFscy53YWxrKHNjaGVtYSk7XG4gICAgaWYgKCFjb21waWxlcikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5zY2hlbWEocm9vdCwgc2NoZW1hLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGUoY29tcGlsZXIucm9vdCwgc2NoZW1hKTtcbn07XG5cblxuaW50ZXJuYWxzLndhbGsgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc2NoZW1hKSB7XG4gICAgICAgICAgICBjb25zdCBjb21waWxlciA9IGludGVybmFscy53YWxrKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgYW55ID0gc2NoZW1hW0NvbW1vbi5zeW1ib2xzLmFueV07XG4gICAgaWYgKGFueSkge1xuICAgICAgICByZXR1cm4geyByb290OiBzY2hlbWFbYW55LnJvb3RdLCBjb21waWxlOiBhbnkuY29tcGlsZSB9O1xuICAgIH1cblxuICAgIEFzc2VydChPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2NoZW1hKSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KSwgJ1NjaGVtYSBjYW4gb25seSBjb250YWluIHBsYWluIG9iamVjdHMnKTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBjb25zdCBjb21waWxlciA9IGludGVybmFscy53YWxrKHNjaGVtYVtrZXldKTtcbiAgICAgICAgaWYgKGNvbXBpbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGlsZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxuaW50ZXJuYWxzLnNpbXBsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IFsnYm9vbGVhbicsICdzdHJpbmcnLCAnbnVtYmVyJ10uaW5jbHVkZXModHlwZW9mIHZhbHVlKTtcbn07XG5cblxuZXhwb3J0cy53aGVuID0gZnVuY3Rpb24gKHNjaGVtYSwgY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIEFzc2VydChjb25kaXRpb24gJiYgdHlwZW9mIGNvbmRpdGlvbiA9PT0gJ29iamVjdCcsICdNaXNzaW5nIG9wdGlvbnMnKTtcblxuICAgICAgICBvcHRpb25zID0gY29uZGl0aW9uO1xuICAgICAgICBjb25kaXRpb24gPSBSZWYuY3JlYXRlKCcuJyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgc3dpdGNoOiBvcHRpb25zIH07XG4gICAgfVxuXG4gICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydpcycsICdub3QnLCAndGhlbicsICdvdGhlcndpc2UnLCAnc3dpdGNoJywgJ2JyZWFrJ10pO1xuXG4gICAgLy8gU2NoZW1hIGNvbmRpdGlvblxuXG4gICAgaWYgKENvbW1vbi5pc1NjaGVtYShjb25kaXRpb24pKSB7XG4gICAgICAgIEFzc2VydChvcHRpb25zLmlzID09PSB1bmRlZmluZWQsICdcImlzXCIgY2FuIG5vdCBiZSB1c2VkIHdpdGggYSBzY2hlbWEgY29uZGl0aW9uJyk7XG4gICAgICAgIEFzc2VydChvcHRpb25zLm5vdCA9PT0gdW5kZWZpbmVkLCAnXCJub3RcIiBjYW4gbm90IGJlIHVzZWQgd2l0aCBhIHNjaGVtYSBjb25kaXRpb24nKTtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMuc3dpdGNoID09PSB1bmRlZmluZWQsICdcInN3aXRjaFwiIGNhbiBub3QgYmUgdXNlZCB3aXRoIGEgc2NoZW1hIGNvbmRpdGlvbicpO1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY29uZGl0aW9uKHNjaGVtYSwgeyBpczogY29uZGl0aW9uLCB0aGVuOiBvcHRpb25zLnRoZW4sIG90aGVyd2lzZTogb3B0aW9ucy5vdGhlcndpc2UsIGJyZWFrOiBvcHRpb25zLmJyZWFrIH0pO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSBjb25kaXRpb25cblxuICAgIEFzc2VydChSZWYuaXNSZWYoY29uZGl0aW9uKSB8fCB0eXBlb2YgY29uZGl0aW9uID09PSAnc3RyaW5nJywgJ0ludmFsaWQgY29uZGl0aW9uOicsIGNvbmRpdGlvbik7XG4gICAgQXNzZXJ0KG9wdGlvbnMubm90ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pcyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJpc1wiIHdpdGggXCJub3RcIicpO1xuXG4gICAgaWYgKG9wdGlvbnMuc3dpdGNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJ1bGUgPSBvcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy5ub3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVsZSA9IHsgaXM6IG9wdGlvbnMubm90LCB0aGVuOiBvcHRpb25zLm90aGVyd2lzZSwgb3RoZXJ3aXNlOiBvcHRpb25zLnRoZW4sIGJyZWFrOiBvcHRpb25zLmJyZWFrIH07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXMgPSBydWxlLmlzICE9PSB1bmRlZmluZWQgPyBzY2hlbWEuJF9jb21waWxlKHJ1bGUuaXMpIDogc2NoZW1hLiRfcm9vdC5pbnZhbGlkKG51bGwsIGZhbHNlLCAwLCAnJykucmVxdWlyZWQoKTtcbiAgICAgICAgQXNzZXJ0KHJ1bGUudGhlbiAhPT0gdW5kZWZpbmVkIHx8IHJ1bGUub3RoZXJ3aXNlICE9PSB1bmRlZmluZWQsICdvcHRpb25zIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgXCJ0aGVuXCIsIFwib3RoZXJ3aXNlXCIsIG9yIFwic3dpdGNoXCInKTtcbiAgICAgICAgQXNzZXJ0KHJ1bGUuYnJlYWsgPT09IHVuZGVmaW5lZCB8fCBydWxlLnRoZW4gPT09IHVuZGVmaW5lZCB8fCBydWxlLm90aGVyd2lzZSA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHNwZWNpZnkgdGhlbiwgb3RoZXJ3aXNlLCBhbmQgYnJlYWsgYWxsIHRvZ2V0aGVyJyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIVJlZi5pc1JlZihvcHRpb25zLmlzKSAmJlxuICAgICAgICAgICAgIUNvbW1vbi5pc1NjaGVtYShvcHRpb25zLmlzKSkge1xuXG4gICAgICAgICAgICBpcyA9IGlzLnJlcXVpcmVkKCk7ICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBseSByZXF1aXJlZCBpZiB0aGlzIHdhc24ndCBhbHJlYWR5IGEgc2NoZW1hIG9yIGEgcmVmXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNvbmRpdGlvbihzY2hlbWEsIHsgcmVmOiBleHBvcnRzLnJlZihjb25kaXRpb24pLCBpcywgdGhlbjogcnVsZS50aGVuLCBvdGhlcndpc2U6IHJ1bGUub3RoZXJ3aXNlLCBicmVhazogcnVsZS5icmVhayB9KTtcbiAgICB9XG5cbiAgICAvLyBTd2l0Y2ggc3RhdGVtZW50XG5cbiAgICBBc3NlcnQoQXJyYXkuaXNBcnJheShvcHRpb25zLnN3aXRjaCksICdcInN3aXRjaFwiIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICBBc3NlcnQob3B0aW9ucy5pcyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJzd2l0Y2hcIiB3aXRoIFwiaXNcIicpO1xuICAgIEFzc2VydChvcHRpb25zLm5vdCA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJzd2l0Y2hcIiB3aXRoIFwibm90XCInKTtcbiAgICBBc3NlcnQob3B0aW9ucy50aGVuID09PSB1bmRlZmluZWQsICdDYW5ub3QgY29tYmluZSBcInN3aXRjaFwiIHdpdGggXCJ0aGVuXCInKTtcblxuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIHJlZjogZXhwb3J0cy5yZWYoY29uZGl0aW9uKSxcbiAgICAgICAgc3dpdGNoOiBbXSxcbiAgICAgICAgYnJlYWs6IG9wdGlvbnMuYnJlYWtcbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLnN3aXRjaC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB0ZXN0ID0gb3B0aW9ucy5zd2l0Y2hbaV07XG4gICAgICAgIGNvbnN0IGxhc3QgPSBpID09PSBvcHRpb25zLnN3aXRjaC5sZW5ndGggLSAxO1xuXG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKHRlc3QsIGxhc3QgPyBbJ2lzJywgJ3RoZW4nLCAnb3RoZXJ3aXNlJ10gOiBbJ2lzJywgJ3RoZW4nXSk7XG5cbiAgICAgICAgQXNzZXJ0KHRlc3QuaXMgIT09IHVuZGVmaW5lZCwgJ1N3aXRjaCBzdGF0ZW1lbnQgbWlzc2luZyBcImlzXCInKTtcbiAgICAgICAgQXNzZXJ0KHRlc3QudGhlbiAhPT0gdW5kZWZpbmVkLCAnU3dpdGNoIHN0YXRlbWVudCBtaXNzaW5nIFwidGhlblwiJyk7XG5cbiAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgIGlzOiBzY2hlbWEuJF9jb21waWxlKHRlc3QuaXMpLFxuICAgICAgICAgICAgdGhlbjogc2NoZW1hLiRfY29tcGlsZSh0ZXN0LnRoZW4pXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFSZWYuaXNSZWYodGVzdC5pcykgJiZcbiAgICAgICAgICAgICFDb21tb24uaXNTY2hlbWEodGVzdC5pcykpIHtcblxuICAgICAgICAgICAgaXRlbS5pcyA9IGl0ZW0uaXMucmVxdWlyZWQoKTsgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgcmVxdWlyZWQgaWYgdGhpcyB3YXNuJ3QgYWxyZWFkeSBhIHNjaGVtYSBvciBhIHJlZlxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIEFzc2VydChvcHRpb25zLm90aGVyd2lzZSA9PT0gdW5kZWZpbmVkIHx8IHRlc3Qub3RoZXJ3aXNlID09PSB1bmRlZmluZWQsICdDYW5ub3Qgc3BlY2lmeSBcIm90aGVyd2lzZVwiIGluc2lkZSBhbmQgb3V0c2lkZSBhIFwic3dpdGNoXCInKTtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyd2lzZSA9IG9wdGlvbnMub3RoZXJ3aXNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm90aGVyd2lzZSA6IHRlc3Qub3RoZXJ3aXNlO1xuICAgICAgICAgICAgaWYgKG90aGVyd2lzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJ1bGUuYnJlYWsgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBzcGVjaWZ5IGJvdGggb3RoZXJ3aXNlIGFuZCBicmVhaycpO1xuICAgICAgICAgICAgICAgIGl0ZW0ub3RoZXJ3aXNlID0gc2NoZW1hLiRfY29tcGlsZShvdGhlcndpc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnVsZS5zd2l0Y2gucHVzaChpdGVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZTtcbn07XG5cblxuaW50ZXJuYWxzLmNvbmRpdGlvbiA9IGZ1bmN0aW9uIChzY2hlbWEsIGNvbmRpdGlvbikge1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgWyd0aGVuJywgJ290aGVyd2lzZSddKSB7XG4gICAgICAgIGlmIChjb25kaXRpb25ba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZGl0aW9uW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25kaXRpb25ba2V5XSA9IHNjaGVtYS4kX2NvbXBpbGUoY29uZGl0aW9uW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmRpdGlvbjtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/compile.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/errors.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/errors.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Annotate = __webpack_require__(/*! ./annotate */ \"./node_modules/joi/lib/annotate.js\");\nconst Common = __webpack_require__(/*! ./common */ \"./node_modules/joi/lib/common.js\");\nconst Template = __webpack_require__(/*! ./template */ \"./node_modules/joi/lib/template.js\");\n\n\nconst internals = {};\n\n\nexports.Report = class {\n\n    constructor(code, value, local, flags, messages, state, prefs) {\n\n        this.code = code;\n        this.flags = flags;\n        this.messages = messages;\n        this.path = state.path;\n        this.prefs = prefs;\n        this.state = state;\n        this.value = value;\n\n        this.message = null;\n        this.template = null;\n\n        this.local = local || {};\n        this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);\n\n        if (this.value !== undefined &&\n            !this.local.hasOwnProperty('value')) {\n\n            this.local.value = this.value;\n        }\n\n        if (this.path.length) {\n            const key = this.path[this.path.length - 1];\n            if (typeof key !== 'object') {\n                this.local.key = key;\n            }\n        }\n    }\n\n    _setTemplate(template) {\n\n        this.template = template;\n\n        if (!this.flags.label &&\n            this.path.length === 0) {\n\n            const localized = this._template(this.template, 'root');\n            if (localized) {\n                this.local.label = localized;\n            }\n        }\n    }\n\n    toString() {\n\n        if (this.message) {\n            return this.message;\n        }\n\n        const code = this.code;\n\n        if (!this.prefs.errors.render) {\n            return this.code;\n        }\n\n        const template = this._template(this.template) ||\n            this._template(this.prefs.messages) ||\n            this._template(this.messages);\n\n        if (template === undefined) {\n            return `Error code \"${code}\" is not defined, your custom type is missing the correct messages definition`;\n        }\n\n        // Render and cache result\n\n        this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });\n        if (!this.prefs.errors.label) {\n            this.message = this.message.replace(/^\"\" /, '').trim();\n        }\n\n        return this.message;\n    }\n\n    _template(messages, code) {\n\n        return exports.template(this.value, messages, code || this.code, this.state, this.prefs);\n    }\n};\n\n\nexports.path = function (path) {\n\n    let label = '';\n    for (const segment of path) {\n        if (typeof segment === 'object') {          // Exclude array single path segment\n            continue;\n        }\n\n        if (typeof segment === 'string') {\n            if (label) {\n                label += '.';\n            }\n\n            label += segment;\n        }\n        else {\n            label += `[${segment}]`;\n        }\n    }\n\n    return label;\n};\n\n\nexports.template = function (value, messages, code, state, prefs) {\n\n    if (!messages) {\n        return;\n    }\n\n    if (Template.isTemplate(messages)) {\n        return code !== 'root' ? messages : null;\n    }\n\n    let lang = prefs.errors.language;\n    if (Common.isResolvable(lang)) {\n        lang = lang.resolve(value, state, prefs);\n    }\n\n    if (lang &&\n        messages[lang] &&\n        messages[lang][code] !== undefined) {\n\n        return messages[lang][code];\n    }\n\n    return messages[code];\n};\n\n\nexports.label = function (flags, state, prefs, messages) {\n\n    if (flags.label) {\n        return flags.label;\n    }\n\n    if (!prefs.errors.label) {\n        return '';\n    }\n\n    let path = state.path;\n    if (prefs.errors.label === 'key' &&\n        state.path.length > 1) {\n\n        path = state.path.slice(-1);\n    }\n\n    const normalized = exports.path(path);\n    if (normalized) {\n        return normalized;\n    }\n\n    return exports.template(null, prefs.messages, 'root', state, prefs) ||\n        messages && exports.template(null, messages, 'root', state, prefs) ||\n        'value';\n};\n\n\nexports.process = function (errors, original, prefs) {\n\n    if (!errors) {\n        return null;\n    }\n\n    const { override, message, details } = exports.details(errors);\n    if (override) {\n        return override;\n    }\n\n    if (prefs.errors.stack) {\n        return new exports.ValidationError(message, details, original);\n    }\n\n    const limit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n    const validationError = new exports.ValidationError(message, details, original);\n    Error.stackTraceLimit = limit;\n    return validationError;\n};\n\n\nexports.details = function (errors, options = {}) {\n\n    let messages = [];\n    const details = [];\n\n    for (const item of errors) {\n\n        // Override\n\n        if (item instanceof Error) {\n            if (options.override !== false) {\n                return { override: item };\n            }\n\n            const message = item.toString();\n            messages.push(message);\n\n            details.push({\n                message,\n                type: 'override',\n                context: { error: item }\n            });\n\n            continue;\n        }\n\n        // Report\n\n        const message = item.toString();\n        messages.push(message);\n\n        details.push({\n            message,\n            path: item.path.filter((v) => typeof v !== 'object'),\n            type: item.code,\n            context: item.local\n        });\n    }\n\n    if (messages.length > 1) {\n        messages = [...new Set(messages)];\n    }\n\n    return { message: messages.join('. '), details };\n};\n\n\nexports.ValidationError = class extends Error {\n\n    constructor(message, details, original) {\n\n        super(message);\n        this._original = original;\n        this.details = details;\n    }\n\n    static isError(err) {\n\n        return err instanceof exports.ValidationError;\n    }\n};\n\n\nexports.ValidationError.prototype.isJoi = true;\n\nexports.ValidationError.prototype.name = 'ValidationError';\n\nexports.ValidationError.prototype.annotate = Annotate.error;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9lcnJvcnMuanM/M2NlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQyxzREFBWTtBQUNyQyxlQUFlLG1CQUFPLENBQUMsa0RBQVU7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsc0RBQVk7OztBQUdyQzs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDOztBQUVBOztBQUVBLHdGQUF3Riw0RUFBNEU7QUFDcEs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDZCQUE2QjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsZ0RBQWdEOztBQUVoRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsYUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pvaS9saWIvZXJyb3JzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBbm5vdGF0ZSA9IHJlcXVpcmUoJy4vYW5ub3RhdGUnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLlJlcG9ydCA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvZGUsIHZhbHVlLCBsb2NhbCwgZmxhZ3MsIG1lc3NhZ2VzLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgdGhpcy5wYXRoID0gc3RhdGUucGF0aDtcbiAgICAgICAgdGhpcy5wcmVmcyA9IHByZWZzO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWwgfHwge307XG4gICAgICAgIHRoaXMubG9jYWwubGFiZWwgPSBleHBvcnRzLmxhYmVsKHRoaXMuZmxhZ3MsIHRoaXMuc3RhdGUsIHRoaXMucHJlZnMsIHRoaXMubWVzc2FnZXMpO1xuXG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICF0aGlzLmxvY2FsLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG5cbiAgICAgICAgICAgIHRoaXMubG9jYWwudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsLmtleSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZmxhZ3MubGFiZWwgJiZcbiAgICAgICAgICAgIHRoaXMucGF0aC5sZW5ndGggPT09IDApIHtcblxuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gdGhpcy5fdGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgJ3Jvb3QnKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsLmxhYmVsID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLmNvZGU7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByZWZzLmVycm9ycy5yZW5kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuX3RlbXBsYXRlKHRoaXMudGVtcGxhdGUpIHx8XG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSh0aGlzLnByZWZzLm1lc3NhZ2VzKSB8fFxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUodGhpcy5tZXNzYWdlcyk7XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgY29kZSBcIiR7Y29kZX1cIiBpcyBub3QgZGVmaW5lZCwgeW91ciBjdXN0b20gdHlwZSBpcyBtaXNzaW5nIHRoZSBjb3JyZWN0IG1lc3NhZ2VzIGRlZmluaXRpb25gO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVuZGVyIGFuZCBjYWNoZSByZXN1bHRcblxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0ZW1wbGF0ZS5yZW5kZXIodGhpcy52YWx1ZSwgdGhpcy5zdGF0ZSwgdGhpcy5wcmVmcywgdGhpcy5sb2NhbCwgeyBlcnJvcnM6IHRoaXMucHJlZnMuZXJyb3JzLCBtZXNzYWdlczogW3RoaXMucHJlZnMubWVzc2FnZXMsIHRoaXMubWVzc2FnZXNdIH0pO1xuICAgICAgICBpZiAoIXRoaXMucHJlZnMuZXJyb3JzLmxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2UucmVwbGFjZSgvXlwiXCIgLywgJycpLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgX3RlbXBsYXRlKG1lc3NhZ2VzLCBjb2RlKSB7XG5cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudGVtcGxhdGUodGhpcy52YWx1ZSwgbWVzc2FnZXMsIGNvZGUgfHwgdGhpcy5jb2RlLCB0aGlzLnN0YXRlLCB0aGlzLnByZWZzKTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMucGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cbiAgICBsZXQgbGFiZWwgPSAnJztcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdvYmplY3QnKSB7ICAgICAgICAgIC8vIEV4Y2x1ZGUgYXJyYXkgc2luZ2xlIHBhdGggc2VnbWVudFxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCArPSAnLic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhYmVsICs9IHNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYWJlbCArPSBgWyR7c2VnbWVudH1dYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbDtcbn07XG5cblxuZXhwb3J0cy50ZW1wbGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZXMsIGNvZGUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZXMpKSB7XG4gICAgICAgIHJldHVybiBjb2RlICE9PSAncm9vdCcgPyBtZXNzYWdlcyA6IG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGxhbmcgPSBwcmVmcy5lcnJvcnMubGFuZ3VhZ2U7XG4gICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUobGFuZykpIHtcbiAgICAgICAgbGFuZyA9IGxhbmcucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICBpZiAobGFuZyAmJlxuICAgICAgICBtZXNzYWdlc1tsYW5nXSAmJlxuICAgICAgICBtZXNzYWdlc1tsYW5nXVtjb2RlXSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzW2xhbmddW2NvZGVdO1xuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlc1tjb2RlXTtcbn07XG5cblxuZXhwb3J0cy5sYWJlbCA9IGZ1bmN0aW9uIChmbGFncywgc3RhdGUsIHByZWZzLCBtZXNzYWdlcykge1xuXG4gICAgaWYgKGZsYWdzLmxhYmVsKSB7XG4gICAgICAgIHJldHVybiBmbGFncy5sYWJlbDtcbiAgICB9XG5cbiAgICBpZiAoIXByZWZzLmVycm9ycy5sYWJlbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgbGV0IHBhdGggPSBzdGF0ZS5wYXRoO1xuICAgIGlmIChwcmVmcy5lcnJvcnMubGFiZWwgPT09ICdrZXknICYmXG4gICAgICAgIHN0YXRlLnBhdGgubGVuZ3RoID4gMSkge1xuXG4gICAgICAgIHBhdGggPSBzdGF0ZS5wYXRoLnNsaWNlKC0xKTtcbiAgICB9XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0gZXhwb3J0cy5wYXRoKHBhdGgpO1xuICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLnRlbXBsYXRlKG51bGwsIHByZWZzLm1lc3NhZ2VzLCAncm9vdCcsIHN0YXRlLCBwcmVmcykgfHxcbiAgICAgICAgbWVzc2FnZXMgJiYgZXhwb3J0cy50ZW1wbGF0ZShudWxsLCBtZXNzYWdlcywgJ3Jvb3QnLCBzdGF0ZSwgcHJlZnMpIHx8XG4gICAgICAgICd2YWx1ZSc7XG59O1xuXG5cbmV4cG9ydHMucHJvY2VzcyA9IGZ1bmN0aW9uIChlcnJvcnMsIG9yaWdpbmFsLCBwcmVmcykge1xuXG4gICAgaWYgKCFlcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgeyBvdmVycmlkZSwgbWVzc2FnZSwgZGV0YWlscyB9ID0gZXhwb3J0cy5kZXRhaWxzKGVycm9ycyk7XG4gICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICB9XG5cbiAgICBpZiAocHJlZnMuZXJyb3JzLnN0YWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IobWVzc2FnZSwgZGV0YWlscywgb3JpZ2luYWwpO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG4gICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKG1lc3NhZ2UsIGRldGFpbHMsIG9yaWdpbmFsKTtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBsaW1pdDtcbiAgICByZXR1cm4gdmFsaWRhdGlvbkVycm9yO1xufTtcblxuXG5leHBvcnRzLmRldGFpbHMgPSBmdW5jdGlvbiAoZXJyb3JzLCBvcHRpb25zID0ge30pIHtcblxuICAgIGxldCBtZXNzYWdlcyA9IFtdO1xuICAgIGNvbnN0IGRldGFpbHMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBlcnJvcnMpIHtcblxuICAgICAgICAvLyBPdmVycmlkZVxuXG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm92ZXJyaWRlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG92ZXJyaWRlOiBpdGVtIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBpdGVtLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuXG4gICAgICAgICAgICBkZXRhaWxzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgdHlwZTogJ292ZXJyaWRlJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7IGVycm9yOiBpdGVtIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlcG9ydFxuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBpdGVtLnRvU3RyaW5nKCk7XG4gICAgICAgIG1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG5cbiAgICAgICAgZGV0YWlscy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBwYXRoOiBpdGVtLnBhdGguZmlsdGVyKCh2KSA9PiB0eXBlb2YgdiAhPT0gJ29iamVjdCcpLFxuICAgICAgICAgICAgdHlwZTogaXRlbS5jb2RlLFxuICAgICAgICAgICAgY29udGV4dDogaXRlbS5sb2NhbFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBtZXNzYWdlcyA9IFsuLi5uZXcgU2V0KG1lc3NhZ2VzKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZXMuam9pbignLiAnKSwgZGV0YWlscyB9O1xufTtcblxuXG5leHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscywgb3JpZ2luYWwpIHtcblxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWwgPSBvcmlnaW5hbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNFcnJvcihlcnIpIHtcblxuICAgICAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3I7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLlZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUuaXNKb2kgPSB0cnVlO1xuXG5leHBvcnRzLlZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuXG5leHBvcnRzLlZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUuYW5ub3RhdGUgPSBBbm5vdGF0ZS5lcnJvcjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/errors.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/extend.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/extend.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"@hapi/hoek/lib/clone\");\n\nconst Common = __webpack_require__(/*! ./common */ \"./node_modules/joi/lib/common.js\");\nconst Messages = __webpack_require__(/*! ./messages */ \"./node_modules/joi/lib/messages.js\");\n\n\nconst internals = {};\n\n\nexports.type = function (from, options) {\n\n    const base = Object.getPrototypeOf(from);\n    const prototype = Clone(base);\n    const schema = from._assign(Object.create(prototype));\n    const def = Object.assign({}, options);                                 // Shallow cloned\n    delete def.base;\n\n    prototype._definition = def;\n\n    const parent = base._definition || {};\n    def.messages = Messages.merge(parent.messages, def.messages);\n    def.properties = Object.assign({}, parent.properties, def.properties);\n\n    // Type\n\n    schema.type = def.type;\n\n    // Flags\n\n    def.flags = Object.assign({}, parent.flags, def.flags);\n\n    // Terms\n\n    const terms = Object.assign({}, parent.terms);\n    if (def.terms) {\n        for (const name in def.terms) {                                     // Only apply own terms\n            const term = def.terms[name];\n            Assert(schema.$_terms[name] === undefined, 'Invalid term override for', def.type, name);\n            schema.$_terms[name] = term.init;\n            terms[name] = term;\n        }\n    }\n\n    def.terms = terms;\n\n    // Constructor arguments\n\n    if (!def.args) {\n        def.args = parent.args;\n    }\n\n    // Prepare\n\n    def.prepare = internals.prepare(def.prepare, parent.prepare);\n\n    // Coerce\n\n    if (def.coerce) {\n        if (typeof def.coerce === 'function') {\n            def.coerce = { method: def.coerce };\n        }\n\n        if (def.coerce.from &&\n            !Array.isArray(def.coerce.from)) {\n\n            def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };\n        }\n    }\n\n    def.coerce = internals.coerce(def.coerce, parent.coerce);\n\n    // Validate\n\n    def.validate = internals.validate(def.validate, parent.validate);\n\n    // Rules\n\n    const rules = Object.assign({}, parent.rules);\n    if (def.rules) {\n        for (const name in def.rules) {\n            const rule = def.rules[name];\n            Assert(typeof rule === 'object', 'Invalid rule definition for', def.type, name);\n\n            let method = rule.method;\n            if (method === undefined) {\n                method = function () {\n\n                    return this.$_addRule(name);\n                };\n            }\n\n            if (method) {\n                Assert(!prototype[name], 'Rule conflict in', def.type, name);\n                prototype[name] = method;\n            }\n\n            Assert(!rules[name], 'Rule conflict in', def.type, name);\n            rules[name] = rule;\n\n            if (rule.alias) {\n                const aliases = [].concat(rule.alias);\n                for (const alias of aliases) {\n                    prototype[alias] = rule.method;\n                }\n            }\n\n            if (rule.args) {\n                rule.argsByName = new Map();\n                rule.args = rule.args.map((arg) => {\n\n                    if (typeof arg === 'string') {\n                        arg = { name: arg };\n                    }\n\n                    Assert(!rule.argsByName.has(arg.name), 'Duplicated argument name', arg.name);\n\n                    if (Common.isSchema(arg.assert)) {\n                        arg.assert = arg.assert.strict().label(arg.name);\n                    }\n\n                    rule.argsByName.set(arg.name, arg);\n                    return arg;\n                });\n            }\n        }\n    }\n\n    def.rules = rules;\n\n    // Modifiers\n\n    const modifiers = Object.assign({}, parent.modifiers);\n    if (def.modifiers) {\n        for (const name in def.modifiers) {\n            Assert(!prototype[name], 'Rule conflict in', def.type, name);\n\n            const modifier = def.modifiers[name];\n            Assert(typeof modifier === 'function', 'Invalid modifier definition for', def.type, name);\n\n            const method = function (arg) {\n\n                return this.rule({ [name]: arg });\n            };\n\n            prototype[name] = method;\n            modifiers[name] = modifier;\n        }\n    }\n\n    def.modifiers = modifiers;\n\n    // Overrides\n\n    if (def.overrides) {\n        prototype._super = base;\n        schema.$_super = {};                                                            // Backwards compatibility\n        for (const override in def.overrides) {\n            Assert(base[override], 'Cannot override missing', override);\n            def.overrides[override][Common.symbols.parent] = base[override];\n            schema.$_super[override] = base[override].bind(schema);                     // Backwards compatibility\n        }\n\n        Object.assign(prototype, def.overrides);\n    }\n\n    // Casts\n\n    def.cast = Object.assign({}, parent.cast, def.cast);\n\n    // Manifest\n\n    const manifest = Object.assign({}, parent.manifest, def.manifest);\n    manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);\n    def.manifest = manifest;\n\n    // Rebuild\n\n    def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);\n\n    return schema;\n};\n\n\n// Helpers\n\ninternals.build = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return function (obj, desc) {\n\n        return parent(child(obj, desc), desc);\n    };\n};\n\n\ninternals.coerce = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return {\n        from: child.from && parent.from ? [...new Set([...child.from, ...parent.from])] : null,\n        method(value, helpers) {\n\n            let coerced;\n            if (!parent.from ||\n                parent.from.includes(typeof value)) {\n\n                coerced = parent.method(value, helpers);\n                if (coerced) {\n                    if (coerced.errors ||\n                        coerced.value === undefined) {\n\n                        return coerced;\n                    }\n\n                    value = coerced.value;\n                }\n            }\n\n            if (!child.from ||\n                child.from.includes(typeof value)) {\n\n                const own = child.method(value, helpers);\n                if (own) {\n                    return own;\n                }\n            }\n\n            return coerced;\n        }\n    };\n};\n\n\ninternals.prepare = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return function (value, helpers) {\n\n        const prepared = child(value, helpers);\n        if (prepared) {\n            if (prepared.errors ||\n                prepared.value === undefined) {\n\n                return prepared;\n            }\n\n            value = prepared.value;\n        }\n\n        return parent(value, helpers) || prepared;\n    };\n};\n\n\ninternals.rebuild = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return function (schema) {\n\n        parent(schema);\n        child(schema);\n    };\n};\n\n\ninternals.validate = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return function (value, helpers) {\n\n        const result = parent(value, helpers);\n        if (result) {\n            if (result.errors &&\n                (!Array.isArray(result.errors) || result.errors.length)) {\n\n                return result;\n            }\n\n            value = result.value;\n        }\n\n        return child(value, helpers) || result;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9leHRlbmQuanM/YTE4NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0RBQXVCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyxrREFBc0I7O0FBRTVDLGVBQWUsbUJBQU8sQ0FBQyxrREFBVTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxzREFBWTs7O0FBR3JDOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDOztBQUVBLGtDQUFrQztBQUNsQztBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0MsY0FBYztBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLCtCQUErQjs7QUFFL0I7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9qb2kvbGliL2V4dGVuZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBNZXNzYWdlcyA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoZnJvbSwgb3B0aW9ucykge1xuXG4gICAgY29uc3QgYmFzZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmcm9tKTtcbiAgICBjb25zdCBwcm90b3R5cGUgPSBDbG9uZShiYXNlKTtcbiAgICBjb25zdCBzY2hlbWEgPSBmcm9tLl9hc3NpZ24oT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpKTtcbiAgICBjb25zdCBkZWYgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgIGRlbGV0ZSBkZWYuYmFzZTtcblxuICAgIHByb3RvdHlwZS5fZGVmaW5pdGlvbiA9IGRlZjtcblxuICAgIGNvbnN0IHBhcmVudCA9IGJhc2UuX2RlZmluaXRpb24gfHwge307XG4gICAgZGVmLm1lc3NhZ2VzID0gTWVzc2FnZXMubWVyZ2UocGFyZW50Lm1lc3NhZ2VzLCBkZWYubWVzc2FnZXMpO1xuICAgIGRlZi5wcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LnByb3BlcnRpZXMsIGRlZi5wcm9wZXJ0aWVzKTtcblxuICAgIC8vIFR5cGVcblxuICAgIHNjaGVtYS50eXBlID0gZGVmLnR5cGU7XG5cbiAgICAvLyBGbGFnc1xuXG4gICAgZGVmLmZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LmZsYWdzLCBkZWYuZmxhZ3MpO1xuXG4gICAgLy8gVGVybXNcblxuICAgIGNvbnN0IHRlcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LnRlcm1zKTtcbiAgICBpZiAoZGVmLnRlcm1zKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZWYudGVybXMpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBseSBvd24gdGVybXNcbiAgICAgICAgICAgIGNvbnN0IHRlcm0gPSBkZWYudGVybXNbbmFtZV07XG4gICAgICAgICAgICBBc3NlcnQoc2NoZW1hLiRfdGVybXNbbmFtZV0gPT09IHVuZGVmaW5lZCwgJ0ludmFsaWQgdGVybSBvdmVycmlkZSBmb3InLCBkZWYudHlwZSwgbmFtZSk7XG4gICAgICAgICAgICBzY2hlbWEuJF90ZXJtc1tuYW1lXSA9IHRlcm0uaW5pdDtcbiAgICAgICAgICAgIHRlcm1zW25hbWVdID0gdGVybTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlZi50ZXJtcyA9IHRlcm1zO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgYXJndW1lbnRzXG5cbiAgICBpZiAoIWRlZi5hcmdzKSB7XG4gICAgICAgIGRlZi5hcmdzID0gcGFyZW50LmFyZ3M7XG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZVxuXG4gICAgZGVmLnByZXBhcmUgPSBpbnRlcm5hbHMucHJlcGFyZShkZWYucHJlcGFyZSwgcGFyZW50LnByZXBhcmUpO1xuXG4gICAgLy8gQ29lcmNlXG5cbiAgICBpZiAoZGVmLmNvZXJjZSkge1xuICAgICAgICBpZiAodHlwZW9mIGRlZi5jb2VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRlZi5jb2VyY2UgPSB7IG1ldGhvZDogZGVmLmNvZXJjZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZi5jb2VyY2UuZnJvbSAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoZGVmLmNvZXJjZS5mcm9tKSkge1xuXG4gICAgICAgICAgICBkZWYuY29lcmNlID0geyBtZXRob2Q6IGRlZi5jb2VyY2UubWV0aG9kLCBmcm9tOiBbXS5jb25jYXQoZGVmLmNvZXJjZS5mcm9tKSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVmLmNvZXJjZSA9IGludGVybmFscy5jb2VyY2UoZGVmLmNvZXJjZSwgcGFyZW50LmNvZXJjZSk7XG5cbiAgICAvLyBWYWxpZGF0ZVxuXG4gICAgZGVmLnZhbGlkYXRlID0gaW50ZXJuYWxzLnZhbGlkYXRlKGRlZi52YWxpZGF0ZSwgcGFyZW50LnZhbGlkYXRlKTtcblxuICAgIC8vIFJ1bGVzXG5cbiAgICBjb25zdCBydWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5ydWxlcyk7XG4gICAgaWYgKGRlZi5ydWxlcykge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVmLnJ1bGVzKSB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0gZGVmLnJ1bGVzW25hbWVdO1xuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBydWxlID09PSAnb2JqZWN0JywgJ0ludmFsaWQgcnVsZSBkZWZpbml0aW9uIGZvcicsIGRlZi50eXBlLCBuYW1lKTtcblxuICAgICAgICAgICAgbGV0IG1ldGhvZCA9IHJ1bGUubWV0aG9kO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFwcm90b3R5cGVbbmFtZV0sICdSdWxlIGNvbmZsaWN0IGluJywgZGVmLnR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgICAgIHByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXNzZXJ0KCFydWxlc1tuYW1lXSwgJ1J1bGUgY29uZmxpY3QgaW4nLCBkZWYudHlwZSwgbmFtZSk7XG4gICAgICAgICAgICBydWxlc1tuYW1lXSA9IHJ1bGU7XG5cbiAgICAgICAgICAgIGlmIChydWxlLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxpYXNlcyA9IFtdLmNvbmNhdChydWxlLmFsaWFzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGFsaWFzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlW2FsaWFzXSA9IHJ1bGUubWV0aG9kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJ1bGUuYXJncykge1xuICAgICAgICAgICAgICAgIHJ1bGUuYXJnc0J5TmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBydWxlLmFyZ3MgPSBydWxlLmFyZ3MubWFwKChhcmcpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IHsgbmFtZTogYXJnIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIXJ1bGUuYXJnc0J5TmFtZS5oYXMoYXJnLm5hbWUpLCAnRHVwbGljYXRlZCBhcmd1bWVudCBuYW1lJywgYXJnLm5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEoYXJnLmFzc2VydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZy5hc3NlcnQgPSBhcmcuYXNzZXJ0LnN0cmljdCgpLmxhYmVsKGFyZy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuYXJnc0J5TmFtZS5zZXQoYXJnLm5hbWUsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYucnVsZXMgPSBydWxlcztcblxuICAgIC8vIE1vZGlmaWVyc1xuXG4gICAgY29uc3QgbW9kaWZpZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50Lm1vZGlmaWVycyk7XG4gICAgaWYgKGRlZi5tb2RpZmllcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlZi5tb2RpZmllcnMpIHtcbiAgICAgICAgICAgIEFzc2VydCghcHJvdG90eXBlW25hbWVdLCAnUnVsZSBjb25mbGljdCBpbicsIGRlZi50eXBlLCBuYW1lKTtcblxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZXIgPSBkZWYubW9kaWZpZXJzW25hbWVdO1xuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBtb2RpZmllciA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgbW9kaWZpZXIgZGVmaW5pdGlvbiBmb3InLCBkZWYudHlwZSwgbmFtZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IGZ1bmN0aW9uIChhcmcpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGUoeyBbbmFtZV06IGFyZyB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZDtcbiAgICAgICAgICAgIG1vZGlmaWVyc1tuYW1lXSA9IG1vZGlmaWVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVmLm1vZGlmaWVycyA9IG1vZGlmaWVycztcblxuICAgIC8vIE92ZXJyaWRlc1xuXG4gICAgaWYgKGRlZi5vdmVycmlkZXMpIHtcbiAgICAgICAgcHJvdG90eXBlLl9zdXBlciA9IGJhc2U7XG4gICAgICAgIHNjaGVtYS4kX3N1cGVyID0ge307ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgZm9yIChjb25zdCBvdmVycmlkZSBpbiBkZWYub3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICBBc3NlcnQoYmFzZVtvdmVycmlkZV0sICdDYW5ub3Qgb3ZlcnJpZGUgbWlzc2luZycsIG92ZXJyaWRlKTtcbiAgICAgICAgICAgIGRlZi5vdmVycmlkZXNbb3ZlcnJpZGVdW0NvbW1vbi5zeW1ib2xzLnBhcmVudF0gPSBiYXNlW292ZXJyaWRlXTtcbiAgICAgICAgICAgIHNjaGVtYS4kX3N1cGVyW292ZXJyaWRlXSA9IGJhc2Vbb3ZlcnJpZGVdLmJpbmQoc2NoZW1hKTsgICAgICAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihwcm90b3R5cGUsIGRlZi5vdmVycmlkZXMpO1xuICAgIH1cblxuICAgIC8vIENhc3RzXG5cbiAgICBkZWYuY2FzdCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5jYXN0LCBkZWYuY2FzdCk7XG5cbiAgICAvLyBNYW5pZmVzdFxuXG4gICAgY29uc3QgbWFuaWZlc3QgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQubWFuaWZlc3QsIGRlZi5tYW5pZmVzdCk7XG4gICAgbWFuaWZlc3QuYnVpbGQgPSBpbnRlcm5hbHMuYnVpbGQoZGVmLm1hbmlmZXN0ICYmIGRlZi5tYW5pZmVzdC5idWlsZCwgcGFyZW50Lm1hbmlmZXN0ICYmIHBhcmVudC5tYW5pZmVzdC5idWlsZCk7XG4gICAgZGVmLm1hbmlmZXN0ID0gbWFuaWZlc3Q7XG5cbiAgICAvLyBSZWJ1aWxkXG5cbiAgICBkZWYucmVidWlsZCA9IGludGVybmFscy5yZWJ1aWxkKGRlZi5yZWJ1aWxkLCBwYXJlbnQucmVidWlsZCk7XG5cbiAgICByZXR1cm4gc2NoZW1hO1xufTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5idWlsZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudChjaGlsZChvYmosIGRlc2MpLCBkZXNjKTtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMuY29lcmNlID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogY2hpbGQuZnJvbSAmJiBwYXJlbnQuZnJvbSA/IFsuLi5uZXcgU2V0KFsuLi5jaGlsZC5mcm9tLCAuLi5wYXJlbnQuZnJvbV0pXSA6IG51bGwsXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICBsZXQgY29lcmNlZDtcbiAgICAgICAgICAgIGlmICghcGFyZW50LmZyb20gfHxcbiAgICAgICAgICAgICAgICBwYXJlbnQuZnJvbS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICBjb2VyY2VkID0gcGFyZW50Lm1ldGhvZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZXJjZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZXJjZWQuZXJyb3JzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VyY2VkLnZhbHVlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZXJjZWQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNoaWxkLmZyb20gfHxcbiAgICAgICAgICAgICAgICBjaGlsZC5mcm9tLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG93biA9IGNoaWxkLm1ldGhvZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgICAgICAgICAgaWYgKG93bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3duO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMucHJlcGFyZSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICBjb25zdCBwcmVwYXJlZCA9IGNoaWxkKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKHByZXBhcmVkKSB7XG4gICAgICAgICAgICBpZiAocHJlcGFyZWQuZXJyb3JzIHx8XG4gICAgICAgICAgICAgICAgcHJlcGFyZWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXBhcmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHByZXBhcmVkLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudCh2YWx1ZSwgaGVscGVycykgfHwgcHJlcGFyZWQ7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLnJlYnVpbGQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuXG4gICAgaWYgKCFjaGlsZCB8fFxuICAgICAgICAhcGFyZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IHBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgICAgIHBhcmVudChzY2hlbWEpO1xuICAgICAgICBjaGlsZChzY2hlbWEpO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJlbnQodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycyAmJlxuICAgICAgICAgICAgICAgICghQXJyYXkuaXNBcnJheShyZXN1bHQuZXJyb3JzKSB8fCByZXN1bHQuZXJyb3JzLmxlbmd0aCkpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkKHZhbHVlLCBoZWxwZXJzKSB8fCByZXN1bHQ7XG4gICAgfTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/extend.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/index.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"@hapi/hoek/lib/clone\");\n\nconst Cache = __webpack_require__(/*! ./cache */ \"./node_modules/joi/lib/cache.js\");\nconst Common = __webpack_require__(/*! ./common */ \"./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ./compile */ \"./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"./node_modules/joi/lib/errors.js\");\nconst Extend = __webpack_require__(/*! ./extend */ \"./node_modules/joi/lib/extend.js\");\nconst Manifest = __webpack_require__(/*! ./manifest */ \"./node_modules/joi/lib/manifest.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"./node_modules/joi/lib/ref.js\");\nconst Template = __webpack_require__(/*! ./template */ \"./node_modules/joi/lib/template.js\");\nconst Trace = __webpack_require__(/*! ./trace */ \"./node_modules/joi/lib/trace.js\");\n\nlet Schemas;\n\n\nconst internals = {\n    types: {\n        alternatives: __webpack_require__(/*! ./types/alternatives */ \"./node_modules/joi/lib/types/alternatives.js\"),\n        any: __webpack_require__(/*! ./types/any */ \"./node_modules/joi/lib/types/any.js\"),\n        array: __webpack_require__(/*! ./types/array */ \"./node_modules/joi/lib/types/array.js\"),\n        boolean: __webpack_require__(/*! ./types/boolean */ \"./node_modules/joi/lib/types/boolean.js\"),\n        date: __webpack_require__(/*! ./types/date */ \"./node_modules/joi/lib/types/date.js\"),\n        function: __webpack_require__(/*! ./types/function */ \"./node_modules/joi/lib/types/function.js\"),\n        link: __webpack_require__(/*! ./types/link */ \"./node_modules/joi/lib/types/link.js\"),\n        number: __webpack_require__(/*! ./types/number */ \"./node_modules/joi/lib/types/number.js\"),\n        object: __webpack_require__(/*! ./types/object */ \"./node_modules/joi/lib/types/object.js\"),\n        string: __webpack_require__(/*! ./types/string */ \"./node_modules/joi/lib/types/string.js\"),\n        symbol: __webpack_require__(/*! ./types/symbol */ \"./node_modules/joi/lib/types/symbol.js\")\n    },\n    aliases: {\n        alt: 'alternatives',\n        bool: 'boolean',\n        func: 'function'\n    }\n};\n\n\nif (Buffer) {                                                           // $lab:coverage:ignore$\n    internals.types.binary = __webpack_require__(/*! ./types/binary */ \"./node_modules/joi/lib/types/binary.js\");\n}\n\n\ninternals.root = function () {\n\n    const root = {\n        _types: new Set(Object.keys(internals.types))\n    };\n\n    // Types\n\n    for (const type of root._types) {\n        root[type] = function (...args) {\n\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\n            return internals.generate(this, internals.types[type], args);\n        };\n    }\n\n    // Shortcuts\n\n    for (const method of ['allow', 'custom', 'disallow', 'equal', 'exist', 'forbidden', 'invalid', 'not', 'only', 'optional', 'options', 'prefs', 'preferences', 'required', 'strip', 'valid', 'when']) {\n        root[method] = function (...args) {\n\n            return this.any()[method](...args);\n        };\n    }\n\n    // Methods\n\n    Object.assign(root, internals.methods);\n\n    // Aliases\n\n    for (const alias in internals.aliases) {\n        const target = internals.aliases[alias];\n        root[alias] = root[target];\n    }\n\n    root.x = root.expression;\n\n    // Trace\n\n    if (Trace.setup) {                                          // $lab:coverage:ignore$\n        Trace.setup(root);\n    }\n\n    return root;\n};\n\n\ninternals.methods = {\n\n    ValidationError: Errors.ValidationError,\n    version: Common.version,\n    cache: Cache.provider,\n\n    assert(value, schema, ...args /* [message], [options] */) {\n\n        internals.assert(value, schema, true, args);\n    },\n\n    attempt(value, schema, ...args /* [message], [options] */) {\n\n        return internals.assert(value, schema, false, args);\n    },\n\n    build(desc) {\n\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\n        return Manifest.build(this, desc);\n    },\n\n    checkPreferences(prefs) {\n\n        Common.checkPreferences(prefs);\n    },\n\n    compile(schema, options) {\n\n        return Compile.compile(this, schema, options);\n    },\n\n    defaults(modifier) {\n\n        Assert(typeof modifier === 'function', 'modifier must be a function');\n\n        const joi = Object.assign({}, this);\n        for (const type of joi._types) {\n            const schema = modifier(joi[type]());\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\n\n            joi[type] = function (...args) {\n\n                return internals.generate(this, schema, args);\n            };\n        }\n\n        return joi;\n    },\n\n    expression(...args) {\n\n        return new Template(...args);\n    },\n\n    extend(...extensions) {\n\n        Common.verifyFlat(extensions, 'extend');\n\n        Schemas = Schemas || __webpack_require__(/*! ./schemas */ \"./node_modules/joi/lib/schemas.js\");\n\n        Assert(extensions.length, 'You need to provide at least one extension');\n        this.assert(extensions, Schemas.extensions);\n\n        const joi = Object.assign({}, this);\n        joi._types = new Set(joi._types);\n\n        for (let extension of extensions) {\n            if (typeof extension === 'function') {\n                extension = extension(joi);\n            }\n\n            this.assert(extension, Schemas.extension);\n\n            const expanded = internals.expandExtension(extension, joi);\n            for (const item of expanded) {\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\n\n                const base = item.base || this.any();\n                const schema = Extend.type(base, item);\n\n                joi._types.add(item.type);\n                joi[item.type] = function (...args) {\n\n                    return internals.generate(this, schema, args);\n                };\n            }\n        }\n\n        return joi;\n    },\n\n    isError: Errors.ValidationError.isError,\n    isExpression: Template.isTemplate,\n    isRef: Ref.isRef,\n    isSchema: Common.isSchema,\n\n    in(...args) {\n\n        return Ref.in(...args);\n    },\n\n    override: Common.symbols.override,\n\n    ref(...args) {\n\n        return Ref.create(...args);\n    },\n\n    types() {\n\n        const types = {};\n        for (const type of this._types) {\n            types[type] = this[type]();\n        }\n\n        for (const target in internals.aliases) {\n            types[target] = this[target]();\n        }\n\n        return types;\n    }\n};\n\n\n// Helpers\n\ninternals.assert = function (value, schema, annotate, args /* [message], [options] */) {\n\n    const message = args[0] instanceof Error || typeof args[0] === 'string' ? args[0] : null;\n    const options = message ? args[1] : args[0];\n    const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));\n\n    let error = result.error;\n    if (!error) {\n        return result.value;\n    }\n\n    if (message instanceof Error) {\n        throw message;\n    }\n\n    const display = annotate && typeof error.annotate === 'function' ? error.annotate() : error.message;\n\n    if (error instanceof Errors.ValidationError === false) {\n        error = Clone(error);\n    }\n\n    error.message = message ? `${message} ${display}` : display;\n    throw error;\n};\n\n\ninternals.generate = function (root, schema, args) {\n\n    Assert(root, 'Must be invoked on a Joi instance.');\n\n    schema.$_root = root;\n\n    if (!schema._definition.args ||\n        !args.length) {\n\n        return schema;\n    }\n\n    return schema._definition.args(schema, ...args);\n};\n\n\ninternals.expandExtension = function (extension, joi) {\n\n    if (typeof extension.type === 'string') {\n        return [extension];\n    }\n\n    const extended = [];\n    for (const type of joi._types) {\n        if (extension.type.test(type)) {\n            const item = Object.assign({}, extension);\n            item.type = type;\n            item.base = joi[type]();\n            extended.push(item);\n        }\n    }\n\n    return extended;\n};\n\n\nmodule.exports = internals.root();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9pbmRleC5qcz9mMGIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxvREFBdUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLGtEQUFzQjs7QUFFNUMsY0FBYyxtQkFBTyxDQUFDLGdEQUFTO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxrREFBVTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxvREFBVztBQUNuQyxlQUFlLG1CQUFPLENBQUMsa0RBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLGtEQUFVO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHNEQUFZO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTztBQUMzQixpQkFBaUIsbUJBQU8sQ0FBQyxzREFBWTtBQUNyQyxjQUFjLG1CQUFPLENBQUMsZ0RBQVM7O0FBRS9COzs7QUFHQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsMEVBQXNCO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQyx3REFBYTtBQUNsQyxlQUFlLG1CQUFPLENBQUMsNERBQWU7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsZ0VBQWlCO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQywwREFBYztBQUNwQyxrQkFBa0IsbUJBQU8sQ0FBQyxrRUFBa0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLDBEQUFjO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLDhEQUFnQjtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLDhEQUFnQjtBQUN4QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxhQUFhO0FBQ2IsNkJBQTZCLG1CQUFPLENBQUMsOERBQWdCO0FBQ3JEOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsNkJBQTZCLG1CQUFPLENBQUMsb0RBQVc7O0FBRWhEO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhEQUE4RCxVQUFVLGNBQWMsRUFBRSxlQUFlOztBQUV2RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxRQUFRLEdBQUcsUUFBUTtBQUNwRDtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pvaS9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgRXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKTtcbmNvbnN0IE1hbmlmZXN0ID0gcmVxdWlyZSgnLi9tYW5pZmVzdCcpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuY29uc3QgVHJhY2UgPSByZXF1aXJlKCcuL3RyYWNlJyk7XG5cbmxldCBTY2hlbWFzO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICB0eXBlczoge1xuICAgICAgICBhbHRlcm5hdGl2ZXM6IHJlcXVpcmUoJy4vdHlwZXMvYWx0ZXJuYXRpdmVzJyksXG4gICAgICAgIGFueTogcmVxdWlyZSgnLi90eXBlcy9hbnknKSxcbiAgICAgICAgYXJyYXk6IHJlcXVpcmUoJy4vdHlwZXMvYXJyYXknKSxcbiAgICAgICAgYm9vbGVhbjogcmVxdWlyZSgnLi90eXBlcy9ib29sZWFuJyksXG4gICAgICAgIGRhdGU6IHJlcXVpcmUoJy4vdHlwZXMvZGF0ZScpLFxuICAgICAgICBmdW5jdGlvbjogcmVxdWlyZSgnLi90eXBlcy9mdW5jdGlvbicpLFxuICAgICAgICBsaW5rOiByZXF1aXJlKCcuL3R5cGVzL2xpbmsnKSxcbiAgICAgICAgbnVtYmVyOiByZXF1aXJlKCcuL3R5cGVzL251bWJlcicpLFxuICAgICAgICBvYmplY3Q6IHJlcXVpcmUoJy4vdHlwZXMvb2JqZWN0JyksXG4gICAgICAgIHN0cmluZzogcmVxdWlyZSgnLi90eXBlcy9zdHJpbmcnKSxcbiAgICAgICAgc3ltYm9sOiByZXF1aXJlKCcuL3R5cGVzL3N5bWJvbCcpXG4gICAgfSxcbiAgICBhbGlhc2VzOiB7XG4gICAgICAgIGFsdDogJ2FsdGVybmF0aXZlcycsXG4gICAgICAgIGJvb2w6ICdib29sZWFuJyxcbiAgICAgICAgZnVuYzogJ2Z1bmN0aW9uJ1xuICAgIH1cbn07XG5cblxuaWYgKEJ1ZmZlcikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgaW50ZXJuYWxzLnR5cGVzLmJpbmFyeSA9IHJlcXVpcmUoJy4vdHlwZXMvYmluYXJ5Jyk7XG59XG5cblxuaW50ZXJuYWxzLnJvb3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCByb290ID0ge1xuICAgICAgICBfdHlwZXM6IG5ldyBTZXQoT2JqZWN0LmtleXMoaW50ZXJuYWxzLnR5cGVzKSlcbiAgICB9O1xuXG4gICAgLy8gVHlwZXNcblxuICAgIGZvciAoY29uc3QgdHlwZSBvZiByb290Ll90eXBlcykge1xuICAgICAgICByb290W3R5cGVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICAgICAgQXNzZXJ0KCFhcmdzLmxlbmd0aCB8fCBbJ2FsdGVybmF0aXZlcycsICdsaW5rJywgJ29iamVjdCddLmluY2x1ZGVzKHR5cGUpLCAnVGhlJywgdHlwZSwgJ3R5cGUgZG9lcyBub3QgYWxsb3cgYXJndW1lbnRzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmdlbmVyYXRlKHRoaXMsIGludGVybmFscy50eXBlc1t0eXBlXSwgYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gU2hvcnRjdXRzXG5cbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBbJ2FsbG93JywgJ2N1c3RvbScsICdkaXNhbGxvdycsICdlcXVhbCcsICdleGlzdCcsICdmb3JiaWRkZW4nLCAnaW52YWxpZCcsICdub3QnLCAnb25seScsICdvcHRpb25hbCcsICdvcHRpb25zJywgJ3ByZWZzJywgJ3ByZWZlcmVuY2VzJywgJ3JlcXVpcmVkJywgJ3N0cmlwJywgJ3ZhbGlkJywgJ3doZW4nXSkge1xuICAgICAgICByb290W21ldGhvZF0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbnkoKVttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIE1ldGhvZHNcblxuICAgIE9iamVjdC5hc3NpZ24ocm9vdCwgaW50ZXJuYWxzLm1ldGhvZHMpO1xuXG4gICAgLy8gQWxpYXNlc1xuXG4gICAgZm9yIChjb25zdCBhbGlhcyBpbiBpbnRlcm5hbHMuYWxpYXNlcykge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBpbnRlcm5hbHMuYWxpYXNlc1thbGlhc107XG4gICAgICAgIHJvb3RbYWxpYXNdID0gcm9vdFt0YXJnZXRdO1xuICAgIH1cblxuICAgIHJvb3QueCA9IHJvb3QuZXhwcmVzc2lvbjtcblxuICAgIC8vIFRyYWNlXG5cbiAgICBpZiAoVHJhY2Uuc2V0dXApIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgVHJhY2Uuc2V0dXAocm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3Q7XG59O1xuXG5cbmludGVybmFscy5tZXRob2RzID0ge1xuXG4gICAgVmFsaWRhdGlvbkVycm9yOiBFcnJvcnMuVmFsaWRhdGlvbkVycm9yLFxuICAgIHZlcnNpb246IENvbW1vbi52ZXJzaW9uLFxuICAgIGNhY2hlOiBDYWNoZS5wcm92aWRlcixcblxuICAgIGFzc2VydCh2YWx1ZSwgc2NoZW1hLCAuLi5hcmdzIC8qIFttZXNzYWdlXSwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgaW50ZXJuYWxzLmFzc2VydCh2YWx1ZSwgc2NoZW1hLCB0cnVlLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgYXR0ZW1wdCh2YWx1ZSwgc2NoZW1hLCAuLi5hcmdzIC8qIFttZXNzYWdlXSwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5hc3NlcnQodmFsdWUsIHNjaGVtYSwgZmFsc2UsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICBidWlsZChkZXNjKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBNYW5pZmVzdC5idWlsZCA9PT0gJ2Z1bmN0aW9uJywgJ01hbmlmZXN0IGZ1bmN0aW9uYWxpdHkgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIE1hbmlmZXN0LmJ1aWxkKHRoaXMsIGRlc2MpO1xuICAgIH0sXG5cbiAgICBjaGVja1ByZWZlcmVuY2VzKHByZWZzKSB7XG5cbiAgICAgICAgQ29tbW9uLmNoZWNrUHJlZmVyZW5jZXMocHJlZnMpO1xuICAgIH0sXG5cbiAgICBjb21waWxlKHNjaGVtYSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBDb21waWxlLmNvbXBpbGUodGhpcywgc2NoZW1hLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgZGVmYXVsdHMobW9kaWZpZXIpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1vZGlmaWVyID09PSAnZnVuY3Rpb24nLCAnbW9kaWZpZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgY29uc3Qgam9pID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcyk7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBqb2kuX3R5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBtb2RpZmllcihqb2lbdHlwZV0oKSk7XG4gICAgICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSksICdtb2RpZmllciBtdXN0IHJldHVybiBhIHZhbGlkIHNjaGVtYSBvYmplY3QnKTtcblxuICAgICAgICAgICAgam9pW3R5cGVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZ2VuZXJhdGUodGhpcywgc2NoZW1hLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gam9pO1xuICAgIH0sXG5cbiAgICBleHByZXNzaW9uKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlKC4uLmFyZ3MpO1xuICAgIH0sXG5cbiAgICBleHRlbmQoLi4uZXh0ZW5zaW9ucykge1xuXG4gICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KGV4dGVuc2lvbnMsICdleHRlbmQnKTtcblxuICAgICAgICBTY2hlbWFzID0gU2NoZW1hcyB8fCByZXF1aXJlKCcuL3NjaGVtYXMnKTtcblxuICAgICAgICBBc3NlcnQoZXh0ZW5zaW9ucy5sZW5ndGgsICdZb3UgbmVlZCB0byBwcm92aWRlIGF0IGxlYXN0IG9uZSBleHRlbnNpb24nKTtcbiAgICAgICAgdGhpcy5hc3NlcnQoZXh0ZW5zaW9ucywgU2NoZW1hcy5leHRlbnNpb25zKTtcblxuICAgICAgICBjb25zdCBqb2kgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzKTtcbiAgICAgICAgam9pLl90eXBlcyA9IG5ldyBTZXQoam9pLl90eXBlcyk7XG5cbiAgICAgICAgZm9yIChsZXQgZXh0ZW5zaW9uIG9mIGV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uKGpvaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0KGV4dGVuc2lvbiwgU2NoZW1hcy5leHRlbnNpb24pO1xuXG4gICAgICAgICAgICBjb25zdCBleHBhbmRlZCA9IGludGVybmFscy5leHBhbmRFeHRlbnNpb24oZXh0ZW5zaW9uLCBqb2kpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KGpvaVtpdGVtLnR5cGVdID09PSB1bmRlZmluZWQgfHwgam9pLl90eXBlcy5oYXMoaXRlbS50eXBlKSwgJ0Nhbm5vdCBvdmVycmlkZSBuYW1lJywgaXRlbS50eXBlKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2UgPSBpdGVtLmJhc2UgfHwgdGhpcy5hbnkoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBFeHRlbmQudHlwZShiYXNlLCBpdGVtKTtcblxuICAgICAgICAgICAgICAgIGpvaS5fdHlwZXMuYWRkKGl0ZW0udHlwZSk7XG4gICAgICAgICAgICAgICAgam9pW2l0ZW0udHlwZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZ2VuZXJhdGUodGhpcywgc2NoZW1hLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpvaTtcbiAgICB9LFxuXG4gICAgaXNFcnJvcjogRXJyb3JzLlZhbGlkYXRpb25FcnJvci5pc0Vycm9yLFxuICAgIGlzRXhwcmVzc2lvbjogVGVtcGxhdGUuaXNUZW1wbGF0ZSxcbiAgICBpc1JlZjogUmVmLmlzUmVmLFxuICAgIGlzU2NoZW1hOiBDb21tb24uaXNTY2hlbWEsXG5cbiAgICBpbiguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIFJlZi5pbiguLi5hcmdzKTtcbiAgICB9LFxuXG4gICAgb3ZlcnJpZGU6IENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlLFxuXG4gICAgcmVmKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gUmVmLmNyZWF0ZSguLi5hcmdzKTtcbiAgICB9LFxuXG4gICAgdHlwZXMoKSB7XG5cbiAgICAgICAgY29uc3QgdHlwZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHRoaXMuX3R5cGVzKSB7XG4gICAgICAgICAgICB0eXBlc1t0eXBlXSA9IHRoaXNbdHlwZV0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IGluIGludGVybmFscy5hbGlhc2VzKSB7XG4gICAgICAgICAgICB0eXBlc1t0YXJnZXRdID0gdGhpc1t0YXJnZXRdKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxufTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5hc3NlcnQgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgYW5ub3RhdGUsIGFyZ3MgLyogW21lc3NhZ2VdLCBbb3B0aW9uc10gKi8pIHtcblxuICAgIGNvbnN0IG1lc3NhZ2UgPSBhcmdzWzBdIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnID8gYXJnc1swXSA6IG51bGw7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lc3NhZ2UgPyBhcmdzWzFdIDogYXJnc1swXTtcbiAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEudmFsaWRhdGUodmFsdWUsIENvbW1vbi5wcmVmZXJlbmNlcyh7IGVycm9yczogeyBzdGFjazogdHJ1ZSB9IH0sIG9wdGlvbnMgfHwge30pKTtcblxuICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc3BsYXkgPSBhbm5vdGF0ZSAmJiB0eXBlb2YgZXJyb3IuYW5ub3RhdGUgPT09ICdmdW5jdGlvbicgPyBlcnJvci5hbm5vdGF0ZSgpIDogZXJyb3IubWVzc2FnZTtcblxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9ycy5WYWxpZGF0aW9uRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAgIGVycm9yID0gQ2xvbmUoZXJyb3IpO1xuICAgIH1cblxuICAgIGVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlID8gYCR7bWVzc2FnZX0gJHtkaXNwbGF5fWAgOiBkaXNwbGF5O1xuICAgIHRocm93IGVycm9yO1xufTtcblxuXG5pbnRlcm5hbHMuZ2VuZXJhdGUgPSBmdW5jdGlvbiAocm9vdCwgc2NoZW1hLCBhcmdzKSB7XG5cbiAgICBBc3NlcnQocm9vdCwgJ011c3QgYmUgaW52b2tlZCBvbiBhIEpvaSBpbnN0YW5jZS4nKTtcblxuICAgIHNjaGVtYS4kX3Jvb3QgPSByb290O1xuXG4gICAgaWYgKCFzY2hlbWEuX2RlZmluaXRpb24uYXJncyB8fFxuICAgICAgICAhYXJncy5sZW5ndGgpIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWEuX2RlZmluaXRpb24uYXJncyhzY2hlbWEsIC4uLmFyZ3MpO1xufTtcblxuXG5pbnRlcm5hbHMuZXhwYW5kRXh0ZW5zaW9uID0gZnVuY3Rpb24gKGV4dGVuc2lvbiwgam9pKSB7XG5cbiAgICBpZiAodHlwZW9mIGV4dGVuc2lvbi50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gW2V4dGVuc2lvbl07XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ZW5kZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygam9pLl90eXBlcykge1xuICAgICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUudGVzdCh0eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV4dGVuc2lvbik7XG4gICAgICAgICAgICBpdGVtLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgaXRlbS5iYXNlID0gam9pW3R5cGVdKCk7XG4gICAgICAgICAgICBleHRlbmRlZC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dGVuZGVkO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5yb290KCk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/index.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/manifest.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/manifest.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"@hapi/hoek/lib/clone\");\n\nconst Common = __webpack_require__(/*! ./common */ \"./node_modules/joi/lib/common.js\");\nconst Messages = __webpack_require__(/*! ./messages */ \"./node_modules/joi/lib/messages.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"./node_modules/joi/lib/ref.js\");\nconst Template = __webpack_require__(/*! ./template */ \"./node_modules/joi/lib/template.js\");\n\nlet Schemas;\n\n\nconst internals = {};\n\n\nexports.describe = function (schema) {\n\n    const def = schema._definition;\n\n    // Type\n\n    const desc = {\n        type: schema.type,\n        flags: {},\n        rules: []\n    };\n\n    // Flags\n\n    for (const flag in schema._flags) {\n        if (flag[0] !== '_') {\n            desc.flags[flag] = internals.describe(schema._flags[flag]);\n        }\n    }\n\n    if (!Object.keys(desc.flags).length) {\n        delete desc.flags;\n    }\n\n    // Preferences\n\n    if (schema._preferences) {\n        desc.preferences = Clone(schema._preferences, { shallow: ['messages'] });\n        delete desc.preferences[Common.symbols.prefs];\n        if (desc.preferences.messages) {\n            desc.preferences.messages = Messages.decompile(desc.preferences.messages);\n        }\n    }\n\n    // Allow / Invalid\n\n    if (schema._valids) {\n        desc.allow = schema._valids.describe();\n    }\n\n    if (schema._invalids) {\n        desc.invalid = schema._invalids.describe();\n    }\n\n    // Rules\n\n    for (const rule of schema._rules) {\n        const ruleDef = def.rules[rule.name];\n        if (ruleDef.manifest === false) {                           // Defaults to true\n            continue;\n        }\n\n        const item = { name: rule.name };\n\n        for (const custom in def.modifiers) {\n            if (rule[custom] !== undefined) {\n                item[custom] = internals.describe(rule[custom]);\n            }\n        }\n\n        if (rule.args) {\n            item.args = {};\n            for (const key in rule.args) {\n                const arg = rule.args[key];\n                if (key === 'options' &&\n                    !Object.keys(arg).length) {\n\n                    continue;\n                }\n\n                item.args[key] = internals.describe(arg, { assign: key });\n            }\n\n            if (!Object.keys(item.args).length) {\n                delete item.args;\n            }\n        }\n\n        desc.rules.push(item);\n    }\n\n    if (!desc.rules.length) {\n        delete desc.rules;\n    }\n\n    // Terms (must be last to verify no name conflicts)\n\n    for (const term in schema.$_terms) {\n        if (term[0] === '_') {\n            continue;\n        }\n\n        Assert(!desc[term], 'Cannot describe schema due to internal name conflict with', term);\n\n        const items = schema.$_terms[term];\n        if (!items) {\n            continue;\n        }\n\n        if (items instanceof Map) {\n            if (items.size) {\n                desc[term] = [...items.entries()];\n            }\n\n            continue;\n        }\n\n        if (Common.isValues(items)) {\n            desc[term] = items.describe();\n            continue;\n        }\n\n        Assert(def.terms[term], 'Term', term, 'missing configuration');\n        const manifest = def.terms[term].manifest;\n        const mapped = typeof manifest === 'object';\n        if (!items.length &&\n            !mapped) {\n\n            continue;\n        }\n\n        const normalized = [];\n        for (const item of items) {\n            normalized.push(internals.describe(item));\n        }\n\n        // Mapped\n\n        if (mapped) {\n            const { from, to } = manifest.mapped;\n            desc[term] = {};\n            for (const item of normalized) {\n                desc[term][item[to]] = item[from];\n            }\n\n            continue;\n        }\n\n        // Single\n\n        if (manifest === 'single') {\n            Assert(normalized.length === 1, 'Term', term, 'contains more than one item');\n            desc[term] = normalized[0];\n            continue;\n        }\n\n        // Array\n\n        desc[term] = normalized;\n    }\n\n    internals.validate(schema.$_root, desc);\n    return desc;\n};\n\n\ninternals.describe = function (item, options = {}) {\n\n    if (Array.isArray(item)) {\n        return item.map(internals.describe);\n    }\n\n    if (item === Common.symbols.deepDefault) {\n        return { special: 'deep' };\n    }\n\n    if (typeof item !== 'object' ||\n        item === null) {\n\n        return item;\n    }\n\n    if (options.assign === 'options') {\n        return Clone(item);\n    }\n\n    if (Buffer && Buffer.isBuffer(item)) {                          // $lab:coverage:ignore$\n        return { buffer: item.toString('binary') };\n    }\n\n    if (item instanceof Date) {\n        return item.toISOString();\n    }\n\n    if (item instanceof Error) {\n        return item;\n    }\n\n    if (item instanceof RegExp) {\n        if (options.assign === 'regex') {\n            return item.toString();\n        }\n\n        return { regex: item.toString() };\n    }\n\n    if (item[Common.symbols.literal]) {\n        return { function: item.literal };\n    }\n\n    if (typeof item.describe === 'function') {\n        if (options.assign === 'ref') {\n            return item.describe().ref;\n        }\n\n        return item.describe();\n    }\n\n    const normalized = {};\n    for (const key in item) {\n        const value = item[key];\n        if (value === undefined) {\n            continue;\n        }\n\n        normalized[key] = internals.describe(value, { assign: key });\n    }\n\n    return normalized;\n};\n\n\nexports.build = function (joi, desc) {\n\n    const builder = new internals.Builder(joi);\n    return builder.parse(desc);\n};\n\n\ninternals.Builder = class {\n\n    constructor(joi) {\n\n        this.joi = joi;\n    }\n\n    parse(desc) {\n\n        internals.validate(this.joi, desc);\n\n        // Type\n\n        let schema = this.joi[desc.type]()._bare();\n        const def = schema._definition;\n\n        // Flags\n\n        if (desc.flags) {\n            for (const flag in desc.flags) {\n                const setter = def.flags[flag] && def.flags[flag].setter || flag;\n                Assert(typeof schema[setter] === 'function', 'Invalid flag', flag, 'for type', desc.type);\n                schema = schema[setter](this.build(desc.flags[flag]));\n            }\n        }\n\n        // Preferences\n\n        if (desc.preferences) {\n            schema = schema.preferences(this.build(desc.preferences));\n        }\n\n        // Allow / Invalid\n\n        if (desc.allow) {\n            schema = schema.allow(...this.build(desc.allow));\n        }\n\n        if (desc.invalid) {\n            schema = schema.invalid(...this.build(desc.invalid));\n        }\n\n        // Rules\n\n        if (desc.rules) {\n            for (const rule of desc.rules) {\n                Assert(typeof schema[rule.name] === 'function', 'Invalid rule', rule.name, 'for type', desc.type);\n\n                const args = [];\n                if (rule.args) {\n                    const built = {};\n                    for (const key in rule.args) {\n                        built[key] = this.build(rule.args[key], { assign: key });\n                    }\n\n                    const keys = Object.keys(built);\n                    const definition = def.rules[rule.name].args;\n                    if (definition) {\n                        Assert(keys.length <= definition.length, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to', definition.length, ', found', keys.length, ')');\n                        for (const { name } of definition) {\n                            args.push(built[name]);\n                        }\n                    }\n                    else {\n                        Assert(keys.length === 1, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to 1, found', keys.length, ')');\n                        args.push(built[keys[0]]);\n                    }\n                }\n\n                // Apply\n\n                schema = schema[rule.name](...args);\n\n                // Ruleset\n\n                const options = {};\n                for (const custom in def.modifiers) {\n                    if (rule[custom] !== undefined) {\n                        options[custom] = this.build(rule[custom]);\n                    }\n                }\n\n                if (Object.keys(options).length) {\n                    schema = schema.rule(options);\n                }\n            }\n        }\n\n        // Terms\n\n        const terms = {};\n        for (const key in desc) {\n            if (['allow', 'flags', 'invalid', 'whens', 'preferences', 'rules', 'type'].includes(key)) {\n                continue;\n            }\n\n            Assert(def.terms[key], 'Term', key, 'missing configuration');\n            const manifest = def.terms[key].manifest;\n\n            if (manifest === 'schema') {\n                terms[key] = desc[key].map((item) => this.parse(item));\n                continue;\n            }\n\n            if (manifest === 'values') {\n                terms[key] = desc[key].map((item) => this.build(item));\n                continue;\n            }\n\n            if (manifest === 'single') {\n                terms[key] = this.build(desc[key]);\n                continue;\n            }\n\n            if (typeof manifest === 'object') {\n                terms[key] = {};\n                for (const name in desc[key]) {\n                    const value = desc[key][name];\n                    terms[key][name] = this.parse(value);\n                }\n\n                continue;\n            }\n\n            terms[key] = this.build(desc[key]);\n        }\n\n        if (desc.whens) {\n            terms.whens = desc.whens.map((when) => this.build(when));\n        }\n\n        schema = def.manifest.build(schema, terms);\n        schema.$_temp.ruleset = false;\n        return schema;\n    }\n\n    build(desc, options = {}) {\n\n        if (desc === null) {\n            return null;\n        }\n\n        if (Array.isArray(desc)) {\n            return desc.map((item) => this.build(item));\n        }\n\n        if (desc instanceof Error) {\n            return desc;\n        }\n\n        if (options.assign === 'options') {\n            return Clone(desc);\n        }\n\n        if (options.assign === 'regex') {\n            return internals.regex(desc);\n        }\n\n        if (options.assign === 'ref') {\n            return Ref.build(desc);\n        }\n\n        if (typeof desc !== 'object') {\n            return desc;\n        }\n\n        if (Object.keys(desc).length === 1) {\n            if (desc.buffer) {\n                Assert(Buffer, 'Buffers are not supported');\n                return Buffer && Buffer.from(desc.buffer, 'binary');                    // $lab:coverage:ignore$\n            }\n\n            if (desc.function) {\n                return { [Common.symbols.literal]: true, literal: desc.function };\n            }\n\n            if (desc.override) {\n                return Common.symbols.override;\n            }\n\n            if (desc.ref) {\n                return Ref.build(desc.ref);\n            }\n\n            if (desc.regex) {\n                return internals.regex(desc.regex);\n            }\n\n            if (desc.special) {\n                Assert(['deep'].includes(desc.special), 'Unknown special value', desc.special);\n                return Common.symbols.deepDefault;\n            }\n\n            if (desc.value) {\n                return Clone(desc.value);\n            }\n        }\n\n        if (desc.type) {\n            return this.parse(desc);\n        }\n\n        if (desc.template) {\n            return Template.build(desc);\n        }\n\n        const normalized = {};\n        for (const key in desc) {\n            normalized[key] = this.build(desc[key], { assign: key });\n        }\n\n        return normalized;\n    }\n};\n\n\ninternals.regex = function (string) {\n\n    const end = string.lastIndexOf('/');\n    const exp = string.slice(1, end);\n    const flags = string.slice(end + 1);\n    return new RegExp(exp, flags);\n};\n\n\ninternals.validate = function (joi, desc) {\n\n    Schemas = Schemas || __webpack_require__(/*! ./schemas */ \"./node_modules/joi/lib/schemas.js\");\n\n    joi.assert(desc, Schemas.description);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9tYW5pZmVzdC5qcz9iM2NiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxvREFBdUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLGtEQUFzQjs7QUFFNUMsZUFBZSxtQkFBTyxDQUFDLGtEQUFVO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHNEQUFZO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTztBQUMzQixpQkFBaUIsbUJBQU8sQ0FBQyxzREFBWTs7QUFFckM7OztBQUdBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1REFBdUQsd0JBQXdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBEQUEwRCxjQUFjO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQyxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFELGNBQWM7QUFDbkU7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGNBQWM7QUFDL0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSx5QkFBeUIsbUJBQU8sQ0FBQyxvREFBVzs7QUFFNUM7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9qb2kvbGliL21hbmlmZXN0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IE1lc3NhZ2VzID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuXG5sZXQgU2NoZW1hcztcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmRlc2NyaWJlID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl9kZWZpbml0aW9uO1xuXG4gICAgLy8gVHlwZVxuXG4gICAgY29uc3QgZGVzYyA9IHtcbiAgICAgICAgdHlwZTogc2NoZW1hLnR5cGUsXG4gICAgICAgIGZsYWdzOiB7fSxcbiAgICAgICAgcnVsZXM6IFtdXG4gICAgfTtcblxuICAgIC8vIEZsYWdzXG5cbiAgICBmb3IgKGNvbnN0IGZsYWcgaW4gc2NoZW1hLl9mbGFncykge1xuICAgICAgICBpZiAoZmxhZ1swXSAhPT0gJ18nKSB7XG4gICAgICAgICAgICBkZXNjLmZsYWdzW2ZsYWddID0gaW50ZXJuYWxzLmRlc2NyaWJlKHNjaGVtYS5fZmxhZ3NbZmxhZ10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFPYmplY3Qua2V5cyhkZXNjLmZsYWdzKS5sZW5ndGgpIHtcbiAgICAgICAgZGVsZXRlIGRlc2MuZmxhZ3M7XG4gICAgfVxuXG4gICAgLy8gUHJlZmVyZW5jZXNcblxuICAgIGlmIChzY2hlbWEuX3ByZWZlcmVuY2VzKSB7XG4gICAgICAgIGRlc2MucHJlZmVyZW5jZXMgPSBDbG9uZShzY2hlbWEuX3ByZWZlcmVuY2VzLCB7IHNoYWxsb3c6IFsnbWVzc2FnZXMnXSB9KTtcbiAgICAgICAgZGVsZXRlIGRlc2MucHJlZmVyZW5jZXNbQ29tbW9uLnN5bWJvbHMucHJlZnNdO1xuICAgICAgICBpZiAoZGVzYy5wcmVmZXJlbmNlcy5tZXNzYWdlcykge1xuICAgICAgICAgICAgZGVzYy5wcmVmZXJlbmNlcy5tZXNzYWdlcyA9IE1lc3NhZ2VzLmRlY29tcGlsZShkZXNjLnByZWZlcmVuY2VzLm1lc3NhZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbG93IC8gSW52YWxpZFxuXG4gICAgaWYgKHNjaGVtYS5fdmFsaWRzKSB7XG4gICAgICAgIGRlc2MuYWxsb3cgPSBzY2hlbWEuX3ZhbGlkcy5kZXNjcmliZSgpO1xuICAgIH1cblxuICAgIGlmIChzY2hlbWEuX2ludmFsaWRzKSB7XG4gICAgICAgIGRlc2MuaW52YWxpZCA9IHNjaGVtYS5faW52YWxpZHMuZGVzY3JpYmUoKTtcbiAgICB9XG5cbiAgICAvLyBSdWxlc1xuXG4gICAgZm9yIChjb25zdCBydWxlIG9mIHNjaGVtYS5fcnVsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZURlZiA9IGRlZi5ydWxlc1tydWxlLm5hbWVdO1xuICAgICAgICBpZiAocnVsZURlZi5tYW5pZmVzdCA9PT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGl0ZW0gPSB7IG5hbWU6IHJ1bGUubmFtZSB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgY3VzdG9tIGluIGRlZi5tb2RpZmllcnMpIHtcbiAgICAgICAgICAgIGlmIChydWxlW2N1c3RvbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZW1bY3VzdG9tXSA9IGludGVybmFscy5kZXNjcmliZShydWxlW2N1c3RvbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJ1bGUuYXJncykge1xuICAgICAgICAgICAgaXRlbS5hcmdzID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBydWxlLmFyZ3Nba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnb3B0aW9ucycgJiZcbiAgICAgICAgICAgICAgICAgICAgIU9iamVjdC5rZXlzKGFyZykubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbS5hcmdzW2tleV0gPSBpbnRlcm5hbHMuZGVzY3JpYmUoYXJnLCB7IGFzc2lnbjoga2V5IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGl0ZW0uYXJncykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW0uYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlc2MucnVsZXMucHVzaChpdGVtKTtcbiAgICB9XG5cbiAgICBpZiAoIWRlc2MucnVsZXMubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSBkZXNjLnJ1bGVzO1xuICAgIH1cblxuICAgIC8vIFRlcm1zIChtdXN0IGJlIGxhc3QgdG8gdmVyaWZ5IG5vIG5hbWUgY29uZmxpY3RzKVxuXG4gICAgZm9yIChjb25zdCB0ZXJtIGluIHNjaGVtYS4kX3Rlcm1zKSB7XG4gICAgICAgIGlmICh0ZXJtWzBdID09PSAnXycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KCFkZXNjW3Rlcm1dLCAnQ2Fubm90IGRlc2NyaWJlIHNjaGVtYSBkdWUgdG8gaW50ZXJuYWwgbmFtZSBjb25mbGljdCB3aXRoJywgdGVybSk7XG5cbiAgICAgICAgY29uc3QgaXRlbXMgPSBzY2hlbWEuJF90ZXJtc1t0ZXJtXTtcbiAgICAgICAgaWYgKCFpdGVtcykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbXMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGlmIChpdGVtcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgZGVzY1t0ZXJtXSA9IFsuLi5pdGVtcy5lbnRyaWVzKCldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChDb21tb24uaXNWYWx1ZXMoaXRlbXMpKSB7XG4gICAgICAgICAgICBkZXNjW3Rlcm1dID0gaXRlbXMuZGVzY3JpYmUoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KGRlZi50ZXJtc1t0ZXJtXSwgJ1Rlcm0nLCB0ZXJtLCAnbWlzc2luZyBjb25maWd1cmF0aW9uJyk7XG4gICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gZGVmLnRlcm1zW3Rlcm1dLm1hbmlmZXN0O1xuICAgICAgICBjb25zdCBtYXBwZWQgPSB0eXBlb2YgbWFuaWZlc3QgPT09ICdvYmplY3QnO1xuICAgICAgICBpZiAoIWl0ZW1zLmxlbmd0aCAmJlxuICAgICAgICAgICAgIW1hcHBlZCkge1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnB1c2goaW50ZXJuYWxzLmRlc2NyaWJlKGl0ZW0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hcHBlZFxuXG4gICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IG1hbmlmZXN0Lm1hcHBlZDtcbiAgICAgICAgICAgIGRlc2NbdGVybV0gPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgZGVzY1t0ZXJtXVtpdGVtW3RvXV0gPSBpdGVtW2Zyb21dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmdsZVxuXG4gICAgICAgIGlmIChtYW5pZmVzdCA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIEFzc2VydChub3JtYWxpemVkLmxlbmd0aCA9PT0gMSwgJ1Rlcm0nLCB0ZXJtLCAnY29udGFpbnMgbW9yZSB0aGFuIG9uZSBpdGVtJyk7XG4gICAgICAgICAgICBkZXNjW3Rlcm1dID0gbm9ybWFsaXplZFswXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXJyYXlcblxuICAgICAgICBkZXNjW3Rlcm1dID0gbm9ybWFsaXplZDtcbiAgICB9XG5cbiAgICBpbnRlcm5hbHMudmFsaWRhdGUoc2NoZW1hLiRfcm9vdCwgZGVzYyk7XG4gICAgcmV0dXJuIGRlc2M7XG59O1xuXG5cbmludGVybmFscy5kZXNjcmliZSA9IGZ1bmN0aW9uIChpdGVtLCBvcHRpb25zID0ge30pIHtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBpdGVtLm1hcChpbnRlcm5hbHMuZGVzY3JpYmUpO1xuICAgIH1cblxuICAgIGlmIChpdGVtID09PSBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4geyBzcGVjaWFsOiAnZGVlcCcgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnIHx8XG4gICAgICAgIGl0ZW0gPT09IG51bGwpIHtcblxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdvcHRpb25zJykge1xuICAgICAgICByZXR1cm4gQ2xvbmUoaXRlbSk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIoaXRlbSkpIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICByZXR1cm4geyBidWZmZXI6IGl0ZW0udG9TdHJpbmcoJ2JpbmFyeScpIH07XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdyZWdleCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyByZWdleDogaXRlbS50b1N0cmluZygpIH07XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1bQ29tbW9uLnN5bWJvbHMubGl0ZXJhbF0pIHtcbiAgICAgICAgcmV0dXJuIHsgZnVuY3Rpb246IGl0ZW0ubGl0ZXJhbCB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaXRlbS5kZXNjcmliZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdyZWYnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5kZXNjcmliZSgpLnJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtLmRlc2NyaWJlKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGl0ZW0pIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpdGVtW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGludGVybmFscy5kZXNjcmliZSh2YWx1ZSwgeyBhc3NpZ246IGtleSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn07XG5cblxuZXhwb3J0cy5idWlsZCA9IGZ1bmN0aW9uIChqb2ksIGRlc2MpIHtcblxuICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgaW50ZXJuYWxzLkJ1aWxkZXIoam9pKTtcbiAgICByZXR1cm4gYnVpbGRlci5wYXJzZShkZXNjKTtcbn07XG5cblxuaW50ZXJuYWxzLkJ1aWxkZXIgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihqb2kpIHtcblxuICAgICAgICB0aGlzLmpvaSA9IGpvaTtcbiAgICB9XG5cbiAgICBwYXJzZShkZXNjKSB7XG5cbiAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlKHRoaXMuam9pLCBkZXNjKTtcblxuICAgICAgICAvLyBUeXBlXG5cbiAgICAgICAgbGV0IHNjaGVtYSA9IHRoaXMuam9pW2Rlc2MudHlwZV0oKS5fYmFyZSgpO1xuICAgICAgICBjb25zdCBkZWYgPSBzY2hlbWEuX2RlZmluaXRpb247XG5cbiAgICAgICAgLy8gRmxhZ3NcblxuICAgICAgICBpZiAoZGVzYy5mbGFncykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmbGFnIGluIGRlc2MuZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0ZXIgPSBkZWYuZmxhZ3NbZmxhZ10gJiYgZGVmLmZsYWdzW2ZsYWddLnNldHRlciB8fCBmbGFnO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygc2NoZW1hW3NldHRlcl0gPT09ICdmdW5jdGlvbicsICdJbnZhbGlkIGZsYWcnLCBmbGFnLCAnZm9yIHR5cGUnLCBkZXNjLnR5cGUpO1xuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYVtzZXR0ZXJdKHRoaXMuYnVpbGQoZGVzYy5mbGFnc1tmbGFnXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJlZmVyZW5jZXNcblxuICAgICAgICBpZiAoZGVzYy5wcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hLnByZWZlcmVuY2VzKHRoaXMuYnVpbGQoZGVzYy5wcmVmZXJlbmNlcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxsb3cgLyBJbnZhbGlkXG5cbiAgICAgICAgaWYgKGRlc2MuYWxsb3cpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5hbGxvdyguLi50aGlzLmJ1aWxkKGRlc2MuYWxsb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjLmludmFsaWQpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5pbnZhbGlkKC4uLnRoaXMuYnVpbGQoZGVzYy5pbnZhbGlkKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSdWxlc1xuXG4gICAgICAgIGlmIChkZXNjLnJ1bGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZGVzYy5ydWxlcykge1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygc2NoZW1hW3J1bGUubmFtZV0gPT09ICdmdW5jdGlvbicsICdJbnZhbGlkIHJ1bGUnLCBydWxlLm5hbWUsICdmb3IgdHlwZScsIGRlc2MudHlwZSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuYXJncykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWlsdCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWx0W2tleV0gPSB0aGlzLmJ1aWxkKHJ1bGUuYXJnc1trZXldLCB7IGFzc2lnbjoga2V5IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGJ1aWx0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGRlZi5ydWxlc1tydWxlLm5hbWVdLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQoa2V5cy5sZW5ndGggPD0gZGVmaW5pdGlvbi5sZW5ndGgsICdJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgZm9yJywgZGVzYy50eXBlLCBydWxlLm5hbWUsICcoZXhwZWN0ZWQgdXAgdG8nLCBkZWZpbml0aW9uLmxlbmd0aCwgJywgZm91bmQnLCBrZXlzLmxlbmd0aCwgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBuYW1lIH0gb2YgZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChidWlsdFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQoa2V5cy5sZW5ndGggPT09IDEsICdJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgZm9yJywgZGVzYy50eXBlLCBydWxlLm5hbWUsICcoZXhwZWN0ZWQgdXAgdG8gMSwgZm91bmQnLCBrZXlzLmxlbmd0aCwgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChidWlsdFtrZXlzWzBdXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBcHBseVxuXG4gICAgICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hW3J1bGUubmFtZV0oLi4uYXJncyk7XG5cbiAgICAgICAgICAgICAgICAvLyBSdWxlc2V0XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjdXN0b20gaW4gZGVmLm1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZVtjdXN0b21dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbY3VzdG9tXSA9IHRoaXMuYnVpbGQocnVsZVtjdXN0b21dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hLnJ1bGUob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVybXNcblxuICAgICAgICBjb25zdCB0ZXJtcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkZXNjKSB7XG4gICAgICAgICAgICBpZiAoWydhbGxvdycsICdmbGFncycsICdpbnZhbGlkJywgJ3doZW5zJywgJ3ByZWZlcmVuY2VzJywgJ3J1bGVzJywgJ3R5cGUnXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFzc2VydChkZWYudGVybXNba2V5XSwgJ1Rlcm0nLCBrZXksICdtaXNzaW5nIGNvbmZpZ3VyYXRpb24nKTtcbiAgICAgICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gZGVmLnRlcm1zW2tleV0ubWFuaWZlc3Q7XG5cbiAgICAgICAgICAgIGlmIChtYW5pZmVzdCA9PT0gJ3NjaGVtYScpIHtcbiAgICAgICAgICAgICAgICB0ZXJtc1trZXldID0gZGVzY1trZXldLm1hcCgoaXRlbSkgPT4gdGhpcy5wYXJzZShpdGVtKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYW5pZmVzdCA9PT0gJ3ZhbHVlcycpIHtcbiAgICAgICAgICAgICAgICB0ZXJtc1trZXldID0gZGVzY1trZXldLm1hcCgoaXRlbSkgPT4gdGhpcy5idWlsZChpdGVtKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYW5pZmVzdCA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgICAgICB0ZXJtc1trZXldID0gdGhpcy5idWlsZChkZXNjW2tleV0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1hbmlmZXN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRlcm1zW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVzY1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGVzY1trZXldW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB0ZXJtc1trZXldW25hbWVdID0gdGhpcy5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRlcm1zW2tleV0gPSB0aGlzLmJ1aWxkKGRlc2Nba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy53aGVucykge1xuICAgICAgICAgICAgdGVybXMud2hlbnMgPSBkZXNjLndoZW5zLm1hcCgod2hlbikgPT4gdGhpcy5idWlsZCh3aGVuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlbWEgPSBkZWYubWFuaWZlc3QuYnVpbGQoc2NoZW1hLCB0ZXJtcyk7XG4gICAgICAgIHNjaGVtYS4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cblxuICAgIGJ1aWxkKGRlc2MsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmIChkZXNjID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlc2MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYy5tYXAoKGl0ZW0pID0+IHRoaXMuYnVpbGQoaXRlbSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdvcHRpb25zJykge1xuICAgICAgICAgICAgcmV0dXJuIENsb25lKGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAncmVnZXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnJlZ2V4KGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAncmVmJykge1xuICAgICAgICAgICAgcmV0dXJuIFJlZi5idWlsZChkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVzYyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRlc2MpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGRlc2MuYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KEJ1ZmZlciwgJ0J1ZmZlcnMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyICYmIEJ1ZmZlci5mcm9tKGRlc2MuYnVmZmVyLCAnYmluYXJ5Jyk7ICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MuZnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBbQ29tbW9uLnN5bWJvbHMubGl0ZXJhbF06IHRydWUsIGxpdGVyYWw6IGRlc2MuZnVuY3Rpb24gfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2Mub3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tbW9uLnN5bWJvbHMub3ZlcnJpZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnJlZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWYuYnVpbGQoZGVzYy5yZWYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5yZWdleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMucmVnZXgoZGVzYy5yZWdleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnNwZWNpYWwpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoWydkZWVwJ10uaW5jbHVkZXMoZGVzYy5zcGVjaWFsKSwgJ1Vua25vd24gc3BlY2lhbCB2YWx1ZScsIGRlc2Muc3BlY2lhbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbW1vbi5zeW1ib2xzLmRlZXBEZWZhdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDbG9uZShkZXNjLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZS5idWlsZChkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVzYykge1xuICAgICAgICAgICAgbm9ybWFsaXplZFtrZXldID0gdGhpcy5idWlsZChkZXNjW2tleV0sIHsgYXNzaWduOiBrZXkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5yZWdleCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIGNvbnN0IGVuZCA9IHN0cmluZy5sYXN0SW5kZXhPZignLycpO1xuICAgIGNvbnN0IGV4cCA9IHN0cmluZy5zbGljZSgxLCBlbmQpO1xuICAgIGNvbnN0IGZsYWdzID0gc3RyaW5nLnNsaWNlKGVuZCArIDEpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGV4cCwgZmxhZ3MpO1xufTtcblxuXG5pbnRlcm5hbHMudmFsaWRhdGUgPSBmdW5jdGlvbiAoam9pLCBkZXNjKSB7XG5cbiAgICBTY2hlbWFzID0gU2NoZW1hcyB8fCByZXF1aXJlKCcuL3NjaGVtYXMnKTtcblxuICAgIGpvaS5hc3NlcnQoZGVzYywgU2NoZW1hcy5kZXNjcmlwdGlvbik7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/manifest.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/messages.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/messages.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"@hapi/hoek/lib/clone\");\n\nconst Template = __webpack_require__(/*! ./template */ \"./node_modules/joi/lib/template.js\");\n\n\nconst internals = {};\n\n\nexports.compile = function (messages, target) {\n\n    // Single value string ('plain error message', 'template {error} message')\n\n    if (typeof messages === 'string') {\n        Assert(!target, 'Cannot set single message string');\n        return new Template(messages);\n    }\n\n    // Single value template\n\n    if (Template.isTemplate(messages)) {\n        Assert(!target, 'Cannot set single message template');\n        return messages;\n    }\n\n    // By error code { 'number.min': <string | template> }\n\n    Assert(typeof messages === 'object' && !Array.isArray(messages), 'Invalid message options');\n\n    target = target ? Clone(target) : {};\n\n    for (let code in messages) {\n        const message = messages[code];\n\n        if (code === 'root' ||\n            Template.isTemplate(message)) {\n\n            target[code] = message;\n            continue;\n        }\n\n        if (typeof message === 'string') {\n            target[code] = new Template(message);\n            continue;\n        }\n\n        // By language { english: { 'number.min': <string | template> } }\n\n        Assert(typeof message === 'object' && !Array.isArray(message), 'Invalid message for', code);\n\n        const language = code;\n        target[language] = target[language] || {};\n\n        for (code in message) {\n            const localized = message[code];\n\n            if (code === 'root' ||\n                Template.isTemplate(localized)) {\n\n                target[language][code] = localized;\n                continue;\n            }\n\n            Assert(typeof localized === 'string', 'Invalid message for', code, 'in', language);\n            target[language][code] = new Template(localized);\n        }\n    }\n\n    return target;\n};\n\n\nexports.decompile = function (messages) {\n\n    // By error code { 'number.min': <string | template> }\n\n    const target = {};\n    for (let code in messages) {\n        const message = messages[code];\n\n        if (code === 'root') {\n            target[code] = message;\n            continue;\n        }\n\n        if (Template.isTemplate(message)) {\n            target[code] = message.describe({ compact: true });\n            continue;\n        }\n\n        // By language { english: { 'number.min': <string | template> } }\n\n        const language = code;\n        target[language] = {};\n\n        for (code in message) {\n            const localized = message[code];\n\n            if (code === 'root') {\n                target[language][code] = localized;\n                continue;\n            }\n\n            target[language][code] = localized.describe({ compact: true });\n        }\n    }\n\n    return target;\n};\n\n\nexports.merge = function (base, extended) {\n\n    if (!base) {\n        return exports.compile(extended);\n    }\n\n    if (!extended) {\n        return base;\n    }\n\n    // Single value string\n\n    if (typeof extended === 'string') {\n        return new Template(extended);\n    }\n\n    // Single value template\n\n    if (Template.isTemplate(extended)) {\n        return extended;\n    }\n\n    // By error code { 'number.min': <string | template> }\n\n    const target = Clone(base);\n\n    for (let code in extended) {\n        const message = extended[code];\n\n        if (code === 'root' ||\n            Template.isTemplate(message)) {\n\n            target[code] = message;\n            continue;\n        }\n\n        if (typeof message === 'string') {\n            target[code] = new Template(message);\n            continue;\n        }\n\n        // By language { english: { 'number.min': <string | template> } }\n\n        Assert(typeof message === 'object' && !Array.isArray(message), 'Invalid message for', code);\n\n        const language = code;\n        target[language] = target[language] || {};\n\n        for (code in message) {\n            const localized = message[code];\n\n            if (code === 'root' ||\n                Template.isTemplate(localized)) {\n\n                target[language][code] = localized;\n                continue;\n            }\n\n            Assert(typeof localized === 'string', 'Invalid message for', code, 'in', language);\n            target[language][code] = new Template(localized);\n        }\n    }\n\n    return target;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9tZXNzYWdlcy5qcz8xM2U4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxvREFBdUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLGtEQUFzQjs7QUFFNUMsaUJBQWlCLG1CQUFPLENBQUMsc0RBQVk7OztBQUdyQzs7O0FBR0E7O0FBRUEsOERBQThELE1BQU07O0FBRXBFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsV0FBVyxvQ0FBb0M7O0FBRXZFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxnQkFBZ0I7QUFDN0Q7QUFDQTs7QUFFQSx3QkFBd0IsV0FBVyxvQ0FBb0M7O0FBRXZFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsV0FBVyxvQ0FBb0M7O0FBRXZFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pvaS9saWIvbWVzc2FnZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbiAobWVzc2FnZXMsIHRhcmdldCkge1xuXG4gICAgLy8gU2luZ2xlIHZhbHVlIHN0cmluZyAoJ3BsYWluIGVycm9yIG1lc3NhZ2UnLCAndGVtcGxhdGUge2Vycm9yfSBtZXNzYWdlJylcblxuICAgIGlmICh0eXBlb2YgbWVzc2FnZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIEFzc2VydCghdGFyZ2V0LCAnQ2Fubm90IHNldCBzaW5nbGUgbWVzc2FnZSBzdHJpbmcnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZShtZXNzYWdlcyk7XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIHZhbHVlIHRlbXBsYXRlXG5cbiAgICBpZiAoVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlcykpIHtcbiAgICAgICAgQXNzZXJ0KCF0YXJnZXQsICdDYW5ub3Qgc2V0IHNpbmdsZSBtZXNzYWdlIHRlbXBsYXRlJyk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICB9XG5cbiAgICAvLyBCeSBlcnJvciBjb2RlIHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH1cblxuICAgIEFzc2VydCh0eXBlb2YgbWVzc2FnZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG1lc3NhZ2VzKSwgJ0ludmFsaWQgbWVzc2FnZSBvcHRpb25zJyk7XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQgPyBDbG9uZSh0YXJnZXQpIDoge307XG5cbiAgICBmb3IgKGxldCBjb2RlIGluIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcblxuICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnIHx8XG4gICAgICAgICAgICBUZW1wbGF0ZS5pc1RlbXBsYXRlKG1lc3NhZ2UpKSB7XG5cbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG5ldyBUZW1wbGF0ZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnkgbGFuZ3VhZ2UgeyBlbmdsaXNoOiB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9IH1cblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG1lc3NhZ2UpLCAnSW52YWxpZCBtZXNzYWdlIGZvcicsIGNvZGUpO1xuXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlID0gY29kZTtcbiAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXSA9IHRhcmdldFtsYW5ndWFnZV0gfHwge307XG5cbiAgICAgICAgZm9yIChjb2RlIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsaXplZCA9IG1lc3NhZ2VbY29kZV07XG5cbiAgICAgICAgICAgIGlmIChjb2RlID09PSAncm9vdCcgfHxcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZS5pc1RlbXBsYXRlKGxvY2FsaXplZCkpIHtcblxuICAgICAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV1bY29kZV0gPSBsb2NhbGl6ZWQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgbG9jYWxpemVkID09PSAnc3RyaW5nJywgJ0ludmFsaWQgbWVzc2FnZSBmb3InLCBjb2RlLCAnaW4nLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbmV3IFRlbXBsYXRlKGxvY2FsaXplZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5leHBvcnRzLmRlY29tcGlsZSA9IGZ1bmN0aW9uIChtZXNzYWdlcykge1xuXG4gICAgLy8gQnkgZXJyb3IgY29kZSB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKGxldCBjb2RlIGluIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcblxuICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbWVzc2FnZS5kZXNjcmliZSh7IGNvbXBhY3Q6IHRydWUgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ5IGxhbmd1YWdlIHsgZW5nbGlzaDogeyAnbnVtYmVyLm1pbic6IDxzdHJpbmcgfCB0ZW1wbGF0ZT4gfSB9XG5cbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBjb2RlO1xuICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdID0ge307XG5cbiAgICAgICAgZm9yIChjb2RlIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsaXplZCA9IG1lc3NhZ2VbY29kZV07XG5cbiAgICAgICAgICAgIGlmIChjb2RlID09PSAncm9vdCcpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbG9jYWxpemVkLmRlc2NyaWJlKHsgY29tcGFjdDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiAoYmFzZSwgZXh0ZW5kZWQpIHtcblxuICAgIGlmICghYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb21waWxlKGV4dGVuZGVkKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4dGVuZGVkKSB7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSB2YWx1ZSBzdHJpbmdcblxuICAgIGlmICh0eXBlb2YgZXh0ZW5kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGUoZXh0ZW5kZWQpO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSB2YWx1ZSB0ZW1wbGF0ZVxuXG4gICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUoZXh0ZW5kZWQpKSB7XG4gICAgICAgIHJldHVybiBleHRlbmRlZDtcbiAgICB9XG5cbiAgICAvLyBCeSBlcnJvciBjb2RlIHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH1cblxuICAgIGNvbnN0IHRhcmdldCA9IENsb25lKGJhc2UpO1xuXG4gICAgZm9yIChsZXQgY29kZSBpbiBleHRlbmRlZCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXh0ZW5kZWRbY29kZV07XG5cbiAgICAgICAgaWYgKGNvZGUgPT09ICdyb290JyB8fFxuICAgICAgICAgICAgVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlKSkge1xuXG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBuZXcgVGVtcGxhdGUobWVzc2FnZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ5IGxhbmd1YWdlIHsgZW5nbGlzaDogeyAnbnVtYmVyLm1pbic6IDxzdHJpbmcgfCB0ZW1wbGF0ZT4gfSB9XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShtZXNzYWdlKSwgJ0ludmFsaWQgbWVzc2FnZSBmb3InLCBjb2RlKTtcblxuICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGNvZGU7XG4gICAgICAgIHRhcmdldFtsYW5ndWFnZV0gPSB0YXJnZXRbbGFuZ3VhZ2VdIHx8IHt9O1xuXG4gICAgICAgIGZvciAoY29kZSBpbiBtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGl6ZWQgPSBtZXNzYWdlW2NvZGVdO1xuXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnIHx8XG4gICAgICAgICAgICAgICAgVGVtcGxhdGUuaXNUZW1wbGF0ZShsb2NhbGl6ZWQpKSB7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIGxvY2FsaXplZCA9PT0gJ3N0cmluZycsICdJbnZhbGlkIG1lc3NhZ2UgZm9yJywgY29kZSwgJ2luJywgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IG5ldyBUZW1wbGF0ZShsb2NhbGl6ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/messages.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/modify.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/modify.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\n\nconst Common = __webpack_require__(/*! ./common */ \"./node_modules/joi/lib/common.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"./node_modules/joi/lib/ref.js\");\n\n\nconst internals = {};\n\n\n\nexports.Ids = internals.Ids = class {\n\n    constructor() {\n\n        this._byId = new Map();\n        this._byKey = new Map();\n        this._schemaChain = false;\n    }\n\n    clone() {\n\n        const clone = new internals.Ids();\n        clone._byId = new Map(this._byId);\n        clone._byKey = new Map(this._byKey);\n        clone._schemaChain = this._schemaChain;\n        return clone;\n    }\n\n    concat(source) {\n\n        if (source._schemaChain) {\n            this._schemaChain = true;\n        }\n\n        for (const [id, value] of source._byId.entries()) {\n            Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);\n            this._byId.set(id, value);\n        }\n\n        for (const [key, value] of source._byKey.entries()) {\n            Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);\n            this._byKey.set(key, value);\n        }\n    }\n\n    fork(path, adjuster, root) {\n\n        const chain = this._collect(path);\n        chain.push({ schema: root });\n        const tail = chain.shift();\n        let adjusted = { id: tail.id, schema: adjuster(tail.schema) };\n\n        Assert(Common.isSchema(adjusted.schema), 'adjuster function failed to return a joi schema type');\n\n        for (const node of chain) {\n            adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };\n        }\n\n        return adjusted.schema;\n    }\n\n    labels(path, behind = []) {\n\n        const current = path[0];\n        const node = this._get(current);\n        if (!node) {\n            return [...behind, ...path].join('.');\n        }\n\n        const forward = path.slice(1);\n        behind = [...behind, node.schema._flags.label || current];\n        if (!forward.length) {\n            return behind.join('.');\n        }\n\n        return node.schema._ids.labels(forward, behind);\n    }\n\n    reach(path, behind = []) {\n\n        const current = path[0];\n        const node = this._get(current);\n        Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));\n\n        const forward = path.slice(1);\n        if (!forward.length) {\n            return node.schema;\n        }\n\n        return node.schema._ids.reach(forward, [...behind, current]);\n    }\n\n    register(schema, { key } = {}) {\n\n        if (!schema ||\n            !Common.isSchema(schema)) {\n\n            return;\n        }\n\n        if (schema.$_property('schemaChain') ||\n            schema._ids._schemaChain) {\n\n            this._schemaChain = true;\n        }\n\n        const id = schema._flags.id;\n        if (id) {\n            const existing = this._byId.get(id);\n            Assert(!existing || existing.schema === schema, 'Cannot add different schemas with the same id:', id);\n            Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);\n\n            this._byId.set(id, { schema, id });\n        }\n\n        if (key) {\n            Assert(!this._byKey.has(key), 'Schema already contains key:', key);\n            Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);\n\n            this._byKey.set(key, { schema, id: key });\n        }\n    }\n\n    reset() {\n\n        this._byId = new Map();\n        this._byKey = new Map();\n        this._schemaChain = false;\n    }\n\n    _collect(path, behind = [], nodes = []) {\n\n        const current = path[0];\n        const node = this._get(current);\n        Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));\n\n        nodes = [node, ...nodes];\n\n        const forward = path.slice(1);\n        if (!forward.length) {\n            return nodes;\n        }\n\n        return node.schema._ids._collect(forward, [...behind, current], nodes);\n    }\n\n    _get(id) {\n\n        return this._byId.get(id) || this._byKey.get(id);\n    }\n};\n\n\ninternals.fork = function (schema, id, replacement) {\n\n    const each = (item, { key }) => {\n\n        if (id === (item._flags.id || key)) {\n            return replacement;\n        }\n    };\n\n    const obj = exports.schema(schema, { each, ref: false });\n    return obj ? obj.$_mutateRebuild() : schema;\n};\n\n\nexports.schema = function (schema, options) {\n\n    let obj;\n\n    for (const name in schema._flags) {\n        if (name[0] === '_') {\n            continue;\n        }\n\n        const result = internals.scan(schema._flags[name], { source: 'flags', name }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            obj._flags[name] = result;\n        }\n    }\n\n    for (let i = 0; i < schema._rules.length; ++i) {\n        const rule = schema._rules[i];\n        const result = internals.scan(rule.args, { source: 'rules', name: rule.name }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            const clone = Object.assign({}, rule);\n            clone.args = result;\n            obj._rules[i] = clone;\n\n            const existingUnique = obj._singleRules.get(rule.name);\n            if (existingUnique === rule) {\n                obj._singleRules.set(rule.name, clone);\n            }\n        }\n    }\n\n    for (const name in schema.$_terms) {\n        if (name[0] === '_') {\n            continue;\n        }\n\n        const result = internals.scan(schema.$_terms[name], { source: 'terms', name }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            obj.$_terms[name] = result;\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.scan = function (item, source, options, _path, _key) {\n\n    const path = _path || [];\n\n    if (item === null ||\n        typeof item !== 'object') {\n\n        return;\n    }\n\n    let clone;\n\n    if (Array.isArray(item)) {\n        for (let i = 0; i < item.length; ++i) {\n            const key = source.source === 'terms' && source.name === 'keys' && item[i].key;\n            const result = internals.scan(item[i], source, options, [i, ...path], key);\n            if (result !== undefined) {\n                clone = clone || item.slice();\n                clone[i] = result;\n            }\n        }\n\n        return clone;\n    }\n\n    if (options.schema !== false && Common.isSchema(item) ||\n        options.ref !== false && Ref.isRef(item)) {\n\n        const result = options.each(item, { ...source, path, key: _key });\n        if (result === item) {\n            return;\n        }\n\n        return result;\n    }\n\n    for (const key in item) {\n        if (key[0] === '_') {\n            continue;\n        }\n\n        const result = internals.scan(item[key], source, options, [key, ...path], _key);\n        if (result !== undefined) {\n            clone = clone || Object.assign({}, item);\n            clone[key] = result;\n        }\n    }\n\n    return clone;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9tb2RpZnkuanM/MDA0YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0RBQXVCOztBQUU5QyxlQUFlLG1CQUFPLENBQUMsa0RBQVU7QUFDakMsWUFBWSxtQkFBTyxDQUFDLDRDQUFPOzs7QUFHM0I7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBLHdCQUF3Qjs7QUFFeEI7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsTUFBTSxLQUFLOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLGFBQWE7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLHlCQUF5QixNQUFNOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsbUJBQW1CO0FBQzNEO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDREQUE0RCx3QkFBd0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0Esa0RBQWtELG1DQUFtQztBQUNyRjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZEQUE2RCx3QkFBd0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsNkJBQTZCO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvam9pL2xpYi9tb2RpZnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5cbmV4cG9ydHMuSWRzID0gaW50ZXJuYWxzLklkcyA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMuX2J5SWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2J5S2V5ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zY2hlbWFDaGFpbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IGludGVybmFscy5JZHMoKTtcbiAgICAgICAgY2xvbmUuX2J5SWQgPSBuZXcgTWFwKHRoaXMuX2J5SWQpO1xuICAgICAgICBjbG9uZS5fYnlLZXkgPSBuZXcgTWFwKHRoaXMuX2J5S2V5KTtcbiAgICAgICAgY2xvbmUuX3NjaGVtYUNoYWluID0gdGhpcy5fc2NoZW1hQ2hhaW47XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgaWYgKHNvdXJjZS5fc2NoZW1hQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYUNoYWluID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW2lkLCB2YWx1ZV0gb2Ygc291cmNlLl9ieUlkLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUtleS5oYXMoaWQpLCAnU2NoZW1hIGlkIGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIGtleTonLCBpZCk7XG4gICAgICAgICAgICB0aGlzLl9ieUlkLnNldChpZCwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc291cmNlLl9ieUtleS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlJZC5oYXMoa2V5KSwgJ1NjaGVtYSBrZXkgY29uZmxpY3RzIHdpdGggZXhpc3RpbmcgaWQ6Jywga2V5KTtcbiAgICAgICAgICAgIHRoaXMuX2J5S2V5LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvcmsocGF0aCwgYWRqdXN0ZXIsIHJvb3QpIHtcblxuICAgICAgICBjb25zdCBjaGFpbiA9IHRoaXMuX2NvbGxlY3QocGF0aCk7XG4gICAgICAgIGNoYWluLnB1c2goeyBzY2hlbWE6IHJvb3QgfSk7XG4gICAgICAgIGNvbnN0IHRhaWwgPSBjaGFpbi5zaGlmdCgpO1xuICAgICAgICBsZXQgYWRqdXN0ZWQgPSB7IGlkOiB0YWlsLmlkLCBzY2hlbWE6IGFkanVzdGVyKHRhaWwuc2NoZW1hKSB9O1xuXG4gICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoYWRqdXN0ZWQuc2NoZW1hKSwgJ2FkanVzdGVyIGZ1bmN0aW9uIGZhaWxlZCB0byByZXR1cm4gYSBqb2kgc2NoZW1hIHR5cGUnKTtcblxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY2hhaW4pIHtcbiAgICAgICAgICAgIGFkanVzdGVkID0geyBpZDogbm9kZS5pZCwgc2NoZW1hOiBpbnRlcm5hbHMuZm9yayhub2RlLnNjaGVtYSwgYWRqdXN0ZWQuaWQsIGFkanVzdGVkLnNjaGVtYSkgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhZGp1c3RlZC5zY2hlbWE7XG4gICAgfVxuXG4gICAgbGFiZWxzKHBhdGgsIGJlaGluZCA9IFtdKSB7XG5cbiAgICAgICAgY29uc3QgY3VycmVudCA9IHBhdGhbMF07XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9nZXQoY3VycmVudCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5iZWhpbmQsIC4uLnBhdGhdLmpvaW4oJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZvcndhcmQgPSBwYXRoLnNsaWNlKDEpO1xuICAgICAgICBiZWhpbmQgPSBbLi4uYmVoaW5kLCBub2RlLnNjaGVtYS5fZmxhZ3MubGFiZWwgfHwgY3VycmVudF07XG4gICAgICAgIGlmICghZm9yd2FyZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBiZWhpbmQuam9pbignLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuc2NoZW1hLl9pZHMubGFiZWxzKGZvcndhcmQsIGJlaGluZCk7XG4gICAgfVxuXG4gICAgcmVhY2gocGF0aCwgYmVoaW5kID0gW10pIHtcblxuICAgICAgICBjb25zdCBjdXJyZW50ID0gcGF0aFswXTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldChjdXJyZW50KTtcbiAgICAgICAgQXNzZXJ0KG5vZGUsICdTY2hlbWEgZG9lcyBub3QgY29udGFpbiBwYXRoJywgWy4uLmJlaGluZCwgLi4ucGF0aF0uam9pbignLicpKTtcblxuICAgICAgICBjb25zdCBmb3J3YXJkID0gcGF0aC5zbGljZSgxKTtcbiAgICAgICAgaWYgKCFmb3J3YXJkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuc2NoZW1hO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuc2NoZW1hLl9pZHMucmVhY2goZm9yd2FyZCwgWy4uLmJlaGluZCwgY3VycmVudF0pO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyKHNjaGVtYSwgeyBrZXkgfSA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCFzY2hlbWEgfHxcbiAgICAgICAgICAgICFDb21tb24uaXNTY2hlbWEoc2NoZW1hKSkge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NoZW1hLiRfcHJvcGVydHkoJ3NjaGVtYUNoYWluJykgfHxcbiAgICAgICAgICAgIHNjaGVtYS5faWRzLl9zY2hlbWFDaGFpbikge1xuXG4gICAgICAgICAgICB0aGlzLl9zY2hlbWFDaGFpbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZCA9IHNjaGVtYS5fZmxhZ3MuaWQ7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLl9ieUlkLmdldChpZCk7XG4gICAgICAgICAgICBBc3NlcnQoIWV4aXN0aW5nIHx8IGV4aXN0aW5nLnNjaGVtYSA9PT0gc2NoZW1hLCAnQ2Fubm90IGFkZCBkaWZmZXJlbnQgc2NoZW1hcyB3aXRoIHRoZSBzYW1lIGlkOicsIGlkKTtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlLZXkuaGFzKGlkKSwgJ1NjaGVtYSBpZCBjb25mbGljdHMgd2l0aCBleGlzdGluZyBrZXk6JywgaWQpO1xuXG4gICAgICAgICAgICB0aGlzLl9ieUlkLnNldChpZCwgeyBzY2hlbWEsIGlkIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUtleS5oYXMoa2V5KSwgJ1NjaGVtYSBhbHJlYWR5IGNvbnRhaW5zIGtleTonLCBrZXkpO1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUlkLmhhcyhrZXkpLCAnU2NoZW1hIGtleSBjb25mbGljdHMgd2l0aCBleGlzdGluZyBpZDonLCBrZXkpO1xuXG4gICAgICAgICAgICB0aGlzLl9ieUtleS5zZXQoa2V5LCB7IHNjaGVtYSwgaWQ6IGtleSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuXG4gICAgICAgIHRoaXMuX2J5SWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2J5S2V5ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zY2hlbWFDaGFpbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIF9jb2xsZWN0KHBhdGgsIGJlaGluZCA9IFtdLCBub2RlcyA9IFtdKSB7XG5cbiAgICAgICAgY29uc3QgY3VycmVudCA9IHBhdGhbMF07XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9nZXQoY3VycmVudCk7XG4gICAgICAgIEFzc2VydChub2RlLCAnU2NoZW1hIGRvZXMgbm90IGNvbnRhaW4gcGF0aCcsIFsuLi5iZWhpbmQsIC4uLnBhdGhdLmpvaW4oJy4nKSk7XG5cbiAgICAgICAgbm9kZXMgPSBbbm9kZSwgLi4ubm9kZXNdO1xuXG4gICAgICAgIGNvbnN0IGZvcndhcmQgPSBwYXRoLnNsaWNlKDEpO1xuICAgICAgICBpZiAoIWZvcndhcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5zY2hlbWEuX2lkcy5fY29sbGVjdChmb3J3YXJkLCBbLi4uYmVoaW5kLCBjdXJyZW50XSwgbm9kZXMpO1xuICAgIH1cblxuICAgIF9nZXQoaWQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fYnlJZC5nZXQoaWQpIHx8IHRoaXMuX2J5S2V5LmdldChpZCk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuZm9yayA9IGZ1bmN0aW9uIChzY2hlbWEsIGlkLCByZXBsYWNlbWVudCkge1xuXG4gICAgY29uc3QgZWFjaCA9IChpdGVtLCB7IGtleSB9KSA9PiB7XG5cbiAgICAgICAgaWYgKGlkID09PSAoaXRlbS5fZmxhZ3MuaWQgfHwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9iaiA9IGV4cG9ydHMuc2NoZW1hKHNjaGVtYSwgeyBlYWNoLCByZWY6IGZhbHNlIH0pO1xuICAgIHJldHVybiBvYmogPyBvYmouJF9tdXRhdGVSZWJ1aWxkKCkgOiBzY2hlbWE7XG59O1xuXG5cbmV4cG9ydHMuc2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0aW9ucykge1xuXG4gICAgbGV0IG9iajtcblxuICAgIGZvciAoY29uc3QgbmFtZSBpbiBzY2hlbWEuX2ZsYWdzKSB7XG4gICAgICAgIGlmIChuYW1lWzBdID09PSAnXycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4oc2NoZW1hLl9mbGFnc1tuYW1lXSwgeyBzb3VyY2U6ICdmbGFncycsIG5hbWUgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqID0gb2JqIHx8IHNjaGVtYS5jbG9uZSgpO1xuICAgICAgICAgICAgb2JqLl9mbGFnc1tuYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hLl9ydWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBydWxlID0gc2NoZW1hLl9ydWxlc1tpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4ocnVsZS5hcmdzLCB7IHNvdXJjZTogJ3J1bGVzJywgbmFtZTogcnVsZS5uYW1lIH0sIG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iaiB8fCBzY2hlbWEuY2xvbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmFzc2lnbih7fSwgcnVsZSk7XG4gICAgICAgICAgICBjbG9uZS5hcmdzID0gcmVzdWx0O1xuICAgICAgICAgICAgb2JqLl9ydWxlc1tpXSA9IGNsb25lO1xuXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1VuaXF1ZSA9IG9iai5fc2luZ2xlUnVsZXMuZ2V0KHJ1bGUubmFtZSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdVbmlxdWUgPT09IHJ1bGUpIHtcbiAgICAgICAgICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLnNldChydWxlLm5hbWUsIGNsb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgbmFtZSBpbiBzY2hlbWEuJF90ZXJtcykge1xuICAgICAgICBpZiAobmFtZVswXSA9PT0gJ18nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKHNjaGVtYS4kX3Rlcm1zW25hbWVdLCB7IHNvdXJjZTogJ3Rlcm1zJywgbmFtZSB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmogPSBvYmogfHwgc2NoZW1hLmNsb25lKCk7XG4gICAgICAgICAgICBvYmouJF90ZXJtc1tuYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5cbmludGVybmFscy5zY2FuID0gZnVuY3Rpb24gKGl0ZW0sIHNvdXJjZSwgb3B0aW9ucywgX3BhdGgsIF9rZXkpIHtcblxuICAgIGNvbnN0IHBhdGggPSBfcGF0aCB8fCBbXTtcblxuICAgIGlmIChpdGVtID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY2xvbmU7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW0ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHNvdXJjZS5zb3VyY2UgPT09ICd0ZXJtcycgJiYgc291cmNlLm5hbWUgPT09ICdrZXlzJyAmJiBpdGVtW2ldLmtleTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKGl0ZW1baV0sIHNvdXJjZSwgb3B0aW9ucywgW2ksIC4uLnBhdGhdLCBrZXkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUgPSBjbG9uZSB8fCBpdGVtLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY2xvbmVbaV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2NoZW1hICE9PSBmYWxzZSAmJiBDb21tb24uaXNTY2hlbWEoaXRlbSkgfHxcbiAgICAgICAgb3B0aW9ucy5yZWYgIT09IGZhbHNlICYmIFJlZi5pc1JlZihpdGVtKSkge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbnMuZWFjaChpdGVtLCB7IC4uLnNvdXJjZSwgcGF0aCwga2V5OiBfa2V5IH0pO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IGluIGl0ZW0pIHtcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJ18nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKGl0ZW1ba2V5XSwgc291cmNlLCBvcHRpb25zLCBba2V5LCAuLi5wYXRoXSwgX2tleSk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xvbmUgPSBjbG9uZSB8fCBPYmplY3QuYXNzaWduKHt9LCBpdGVtKTtcbiAgICAgICAgICAgIGNsb25lW2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/modify.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/ref.js":
/*!*************************************!*\
  !*** ./node_modules/joi/lib/ref.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"@hapi/hoek/lib/clone\");\nconst Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ \"@hapi/hoek/lib/reach\");\n\nconst Common = __webpack_require__(/*! ./common */ \"./node_modules/joi/lib/common.js\");\n\nlet Template;\n\n\nconst internals = {\n    symbol: Symbol('ref'),      // Used to internally identify references (shared with other joi versions)\n    defaults: {\n        adjust: null,\n        in: false,\n        iterables: null,\n        map: null,\n        separator: '.',\n        type: 'value'\n    }\n};\n\n\nexports.create = function (key, options = {}) {\n\n    Assert(typeof key === 'string', 'Invalid reference key:', key);\n    Common.assertOptions(options, ['adjust', 'ancestor', 'in', 'iterables', 'map', 'prefix', 'render', 'separator']);\n    Assert(!options.prefix || typeof options.prefix === 'object', 'options.prefix must be of type object');\n\n    const ref = Object.assign({}, internals.defaults, options);\n    delete ref.prefix;\n\n    const separator = ref.separator;\n    const context = internals.context(key, separator, options.prefix);\n    ref.type = context.type;\n    key = context.key;\n\n    if (ref.type === 'value') {\n        if (context.root) {\n            Assert(!separator || key[0] !== separator, 'Cannot specify relative path with root prefix');\n            ref.ancestor = 'root';\n            if (!key) {\n                key = null;\n            }\n        }\n\n        if (separator &&\n            separator === key) {\n\n            key = null;\n            ref.ancestor = 0;\n        }\n        else {\n            if (ref.ancestor !== undefined) {\n                Assert(!separator || !key || key[0] !== separator, 'Cannot combine prefix with ancestor option');\n            }\n            else {\n                const [ancestor, slice] = internals.ancestor(key, separator);\n                if (slice) {\n                    key = key.slice(slice);\n                    if (key === '') {\n                        key = null;\n                    }\n                }\n\n                ref.ancestor = ancestor;\n            }\n        }\n    }\n\n    ref.path = separator ? (key === null ? [] : key.split(separator)) : [key];\n\n    return new internals.Ref(ref);\n};\n\n\nexports.in = function (key, options = {}) {\n\n    return exports.create(key, { ...options, in: true });\n};\n\n\nexports.isRef = function (ref) {\n\n    return ref ? !!ref[Common.symbols.ref] : false;\n};\n\n\ninternals.Ref = class {\n\n    constructor(options) {\n\n        Assert(typeof options === 'object', 'Invalid reference construction');\n        Common.assertOptions(options, [\n            'adjust', 'ancestor', 'in', 'iterables', 'map', 'path', 'render', 'separator', 'type',  // Copied\n            'depth', 'key', 'root', 'display'                                                       // Overridden\n        ]);\n\n        Assert([false, undefined].includes(options.separator) || typeof options.separator === 'string' && options.separator.length === 1, 'Invalid separator');\n        Assert(!options.adjust || typeof options.adjust === 'function', 'options.adjust must be a function');\n        Assert(!options.map || Array.isArray(options.map), 'options.map must be an array');\n        Assert(!options.map || !options.adjust, 'Cannot set both map and adjust options');\n\n        Object.assign(this, internals.defaults, options);\n\n        Assert(this.type === 'value' || this.ancestor === undefined, 'Non-value references cannot reference ancestors');\n\n        if (Array.isArray(this.map)) {\n            this.map = new Map(this.map);\n        }\n\n        this.depth = this.path.length;\n        this.key = this.path.length ? this.path.join(this.separator) : null;\n        this.root = this.path[0];\n\n        this.updateDisplay();\n    }\n\n    resolve(value, state, prefs, local, options = {}) {\n\n        Assert(!this.in || options.in, 'Invalid in() reference usage');\n\n        if (this.type === 'global') {\n            return this._resolve(prefs.context, state, options);\n        }\n\n        if (this.type === 'local') {\n            return this._resolve(local, state, options);\n        }\n\n        if (!this.ancestor) {\n            return this._resolve(value, state, options);\n        }\n\n        if (this.ancestor === 'root') {\n            return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);\n        }\n\n        Assert(this.ancestor <= state.ancestors.length, 'Invalid reference exceeds the schema root:', this.display);\n        return this._resolve(state.ancestors[this.ancestor - 1], state, options);\n    }\n\n    _resolve(target, state, options) {\n\n        let resolved;\n\n        if (this.type === 'value' &&\n            state.mainstay.shadow &&\n            options.shadow !== false) {\n\n            resolved = state.mainstay.shadow.get(this.absolute(state));\n        }\n\n        if (resolved === undefined) {\n            resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });\n        }\n\n        if (this.adjust) {\n            resolved = this.adjust(resolved);\n        }\n\n        if (this.map) {\n            const mapped = this.map.get(resolved);\n            if (mapped !== undefined) {\n                resolved = mapped;\n            }\n        }\n\n        if (state.mainstay) {\n            state.mainstay.tracer.resolve(state, this, resolved);\n        }\n\n        return resolved;\n    }\n\n    toString() {\n\n        return this.display;\n    }\n\n    absolute(state) {\n\n        return [...state.path.slice(0, -this.ancestor), ...this.path];\n    }\n\n    clone() {\n\n        return new internals.Ref(this);\n    }\n\n    describe() {\n\n        const ref = { path: this.path };\n\n        if (this.type !== 'value') {\n            ref.type = this.type;\n        }\n\n        if (this.separator !== '.') {\n            ref.separator = this.separator;\n        }\n\n        if (this.type === 'value' &&\n            this.ancestor !== 1) {\n\n            ref.ancestor = this.ancestor;\n        }\n\n        if (this.map) {\n            ref.map = [...this.map];\n        }\n\n        for (const key of ['adjust', 'iterables', 'render']) {\n            if (this[key] !== null &&\n                this[key] !== undefined) {\n\n                ref[key] = this[key];\n            }\n        }\n\n        if (this.in !== false) {\n            ref.in = true;\n        }\n\n        return { ref };\n    }\n\n    updateDisplay() {\n\n        const key = this.key !== null ? this.key : '';\n        if (this.type !== 'value') {\n            this.display = `ref:${this.type}:${key}`;\n            return;\n        }\n\n        if (!this.separator) {\n            this.display = `ref:${key}`;\n            return;\n        }\n\n        if (!this.ancestor) {\n            this.display = `ref:${this.separator}${key}`;\n            return;\n        }\n\n        if (this.ancestor === 'root') {\n            this.display = `ref:root:${key}`;\n            return;\n        }\n\n        if (this.ancestor === 1) {\n            this.display = `ref:${key || '..'}`;\n            return;\n        }\n\n        const lead = new Array(this.ancestor + 1).fill(this.separator).join('');\n        this.display = `ref:${lead}${key || ''}`;\n    }\n};\n\n\ninternals.Ref.prototype[Common.symbols.ref] = true;\n\n\nexports.build = function (desc) {\n\n    desc = Object.assign({}, internals.defaults, desc);\n    if (desc.type === 'value' &&\n        desc.ancestor === undefined) {\n\n        desc.ancestor = 1;\n    }\n\n    return new internals.Ref(desc);\n};\n\n\ninternals.context = function (key, separator, prefix = {}) {\n\n    key = key.trim();\n\n    if (prefix) {\n        const globalp = prefix.global === undefined ? '$' : prefix.global;\n        if (globalp !== separator &&\n            key.startsWith(globalp)) {\n\n            return { key: key.slice(globalp.length), type: 'global' };\n        }\n\n        const local = prefix.local === undefined ? '#' : prefix.local;\n        if (local !== separator &&\n            key.startsWith(local)) {\n\n            return { key: key.slice(local.length), type: 'local' };\n        }\n\n        const root = prefix.root === undefined ? '/' : prefix.root;\n        if (root !== separator &&\n            key.startsWith(root)) {\n\n            return { key: key.slice(root.length), type: 'value', root: true };\n        }\n    }\n\n    return { key, type: 'value' };\n};\n\n\ninternals.ancestor = function (key, separator) {\n\n    if (!separator) {\n        return [1, 0];              // 'a_b' -> 1 (parent)\n    }\n\n    if (key[0] !== separator) {     // 'a.b' -> 1 (parent)\n        return [1, 0];\n    }\n\n    if (key[1] !== separator) {     // '.a.b' -> 0 (self)\n        return [0, 1];\n    }\n\n    let i = 2;\n    while (key[i] === separator) {\n        ++i;\n    }\n\n    return [i - 1, i];              // '...a.b.' -> 2 (grandparent)\n};\n\n\nexports.toSibling = 0;\n\nexports.toParent = 1;\n\n\nexports.Manager = class {\n\n    constructor() {\n\n        this.refs = [];                     // 0: [self refs], 1: [parent refs], 2: [grandparent refs], ...\n    }\n\n    register(source, target) {\n\n        if (!source) {\n            return;\n        }\n\n        target = target === undefined ? exports.toParent : target;\n\n        // Array\n\n        if (Array.isArray(source)) {\n            for (const ref of source) {\n                this.register(ref, target);\n            }\n\n            return;\n        }\n\n        // Schema\n\n        if (Common.isSchema(source)) {\n            for (const item of source._refs.refs) {\n                if (item.ancestor - target >= 0) {\n                    this.refs.push({ ancestor: item.ancestor - target, root: item.root });\n                }\n            }\n\n            return;\n        }\n\n        // Reference\n\n        if (exports.isRef(source) &&\n            source.type === 'value' &&\n            source.ancestor - target >= 0) {\n\n            this.refs.push({ ancestor: source.ancestor - target, root: source.root });\n        }\n\n        // Template\n\n        Template = Template || __webpack_require__(/*! ./template */ \"./node_modules/joi/lib/template.js\");\n\n        if (Template.isTemplate(source)) {\n            this.register(source.refs(), target);\n        }\n    }\n\n    get length() {\n\n        return this.refs.length;\n    }\n\n    clone() {\n\n        const copy = new exports.Manager();\n        copy.refs = Clone(this.refs);\n        return copy;\n    }\n\n    reset() {\n\n        this.refs = [];\n    }\n\n    roots() {\n\n        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9yZWYuanM/MGUzNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0RBQXVCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyxrREFBc0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLGtEQUFzQjs7QUFFNUMsZUFBZSxtQkFBTyxDQUFDLGtEQUFVOztBQUVqQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0Esd0NBQXdDOztBQUV4QyxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEOzs7QUFHQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvREFBb0Q7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsNkNBQTZDO0FBQzlGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVSxHQUFHLElBQUk7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsZUFBZSxFQUFFLElBQUk7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBOztBQUVBO0FBQ0EsOEJBQThCLEtBQUssRUFBRSxVQUFVO0FBQy9DO0FBQ0E7OztBQUdBOzs7QUFHQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLHlEQUF5RDs7QUFFekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBLFlBQVk7QUFDWjs7O0FBR0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCOzs7QUFHQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUEsdUJBQXVCO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvREFBb0Q7QUFDeEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsd0RBQXdEO0FBQ3BGOztBQUVBOztBQUVBLCtCQUErQixtQkFBTyxDQUFDLHNEQUFZOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pvaS9saWIvcmVmLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvcmVhY2gnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxubGV0IFRlbXBsYXRlO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBzeW1ib2w6IFN5bWJvbCgncmVmJyksICAgICAgLy8gVXNlZCB0byBpbnRlcm5hbGx5IGlkZW50aWZ5IHJlZmVyZW5jZXMgKHNoYXJlZCB3aXRoIG90aGVyIGpvaSB2ZXJzaW9ucylcbiAgICBkZWZhdWx0czoge1xuICAgICAgICBhZGp1c3Q6IG51bGwsXG4gICAgICAgIGluOiBmYWxzZSxcbiAgICAgICAgaXRlcmFibGVzOiBudWxsLFxuICAgICAgICBtYXA6IG51bGwsXG4gICAgICAgIHNlcGFyYXRvcjogJy4nLFxuICAgICAgICB0eXBlOiAndmFsdWUnXG4gICAgfVxufTtcblxuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgQXNzZXJ0KHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnLCAnSW52YWxpZCByZWZlcmVuY2Uga2V5OicsIGtleSk7XG4gICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhZGp1c3QnLCAnYW5jZXN0b3InLCAnaW4nLCAnaXRlcmFibGVzJywgJ21hcCcsICdwcmVmaXgnLCAncmVuZGVyJywgJ3NlcGFyYXRvciddKTtcbiAgICBBc3NlcnQoIW9wdGlvbnMucHJlZml4IHx8IHR5cGVvZiBvcHRpb25zLnByZWZpeCA9PT0gJ29iamVjdCcsICdvcHRpb25zLnByZWZpeCBtdXN0IGJlIG9mIHR5cGUgb2JqZWN0Jyk7XG5cbiAgICBjb25zdCByZWYgPSBPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIGRlbGV0ZSByZWYucHJlZml4O1xuXG4gICAgY29uc3Qgc2VwYXJhdG9yID0gcmVmLnNlcGFyYXRvcjtcbiAgICBjb25zdCBjb250ZXh0ID0gaW50ZXJuYWxzLmNvbnRleHQoa2V5LCBzZXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICByZWYudHlwZSA9IGNvbnRleHQudHlwZTtcbiAgICBrZXkgPSBjb250ZXh0LmtleTtcblxuICAgIGlmIChyZWYudHlwZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICBpZiAoY29udGV4dC5yb290KSB7XG4gICAgICAgICAgICBBc3NlcnQoIXNlcGFyYXRvciB8fCBrZXlbMF0gIT09IHNlcGFyYXRvciwgJ0Nhbm5vdCBzcGVjaWZ5IHJlbGF0aXZlIHBhdGggd2l0aCByb290IHByZWZpeCcpO1xuICAgICAgICAgICAgcmVmLmFuY2VzdG9yID0gJ3Jvb3QnO1xuICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlcGFyYXRvciAmJlxuICAgICAgICAgICAgc2VwYXJhdG9yID09PSBrZXkpIHtcblxuICAgICAgICAgICAga2V5ID0gbnVsbDtcbiAgICAgICAgICAgIHJlZi5hbmNlc3RvciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVmLmFuY2VzdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIXNlcGFyYXRvciB8fCAha2V5IHx8IGtleVswXSAhPT0gc2VwYXJhdG9yLCAnQ2Fubm90IGNvbWJpbmUgcHJlZml4IHdpdGggYW5jZXN0b3Igb3B0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbYW5jZXN0b3IsIHNsaWNlXSA9IGludGVybmFscy5hbmNlc3RvcihrZXksIHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleS5zbGljZShzbGljZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVmLmFuY2VzdG9yID0gYW5jZXN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWYucGF0aCA9IHNlcGFyYXRvciA/IChrZXkgPT09IG51bGwgPyBbXSA6IGtleS5zcGxpdChzZXBhcmF0b3IpKSA6IFtrZXldO1xuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKHJlZik7XG59O1xuXG5cbmV4cG9ydHMuaW4gPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zID0ge30pIHtcblxuICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZShrZXksIHsgLi4ub3B0aW9ucywgaW46IHRydWUgfSk7XG59O1xuXG5cbmV4cG9ydHMuaXNSZWYgPSBmdW5jdGlvbiAocmVmKSB7XG5cbiAgICByZXR1cm4gcmVmID8gISFyZWZbQ29tbW9uLnN5bWJvbHMucmVmXSA6IGZhbHNlO1xufTtcblxuXG5pbnRlcm5hbHMuUmVmID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHJlZmVyZW5jZSBjb25zdHJ1Y3Rpb24nKTtcbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgW1xuICAgICAgICAgICAgJ2FkanVzdCcsICdhbmNlc3RvcicsICdpbicsICdpdGVyYWJsZXMnLCAnbWFwJywgJ3BhdGgnLCAncmVuZGVyJywgJ3NlcGFyYXRvcicsICd0eXBlJywgIC8vIENvcGllZFxuICAgICAgICAgICAgJ2RlcHRoJywgJ2tleScsICdyb290JywgJ2Rpc3BsYXknICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRkZW5cbiAgICAgICAgXSk7XG5cbiAgICAgICAgQXNzZXJ0KFtmYWxzZSwgdW5kZWZpbmVkXS5pbmNsdWRlcyhvcHRpb25zLnNlcGFyYXRvcikgfHwgdHlwZW9mIG9wdGlvbnMuc2VwYXJhdG9yID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLnNlcGFyYXRvci5sZW5ndGggPT09IDEsICdJbnZhbGlkIHNlcGFyYXRvcicpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMuYWRqdXN0IHx8IHR5cGVvZiBvcHRpb25zLmFkanVzdCA9PT0gJ2Z1bmN0aW9uJywgJ29wdGlvbnMuYWRqdXN0IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMubWFwIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy5tYXApLCAnb3B0aW9ucy5tYXAgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMubWFwIHx8ICFvcHRpb25zLmFkanVzdCwgJ0Nhbm5vdCBzZXQgYm90aCBtYXAgYW5kIGFkanVzdCBvcHRpb25zJyk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIEFzc2VydCh0aGlzLnR5cGUgPT09ICd2YWx1ZScgfHwgdGhpcy5hbmNlc3RvciA9PT0gdW5kZWZpbmVkLCAnTm9uLXZhbHVlIHJlZmVyZW5jZXMgY2Fubm90IHJlZmVyZW5jZSBhbmNlc3RvcnMnKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hcCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCh0aGlzLm1hcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlcHRoID0gdGhpcy5wYXRoLmxlbmd0aDtcbiAgICAgICAgdGhpcy5rZXkgPSB0aGlzLnBhdGgubGVuZ3RoID8gdGhpcy5wYXRoLmpvaW4odGhpcy5zZXBhcmF0b3IpIDogbnVsbDtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5wYXRoWzBdO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5pbiB8fCBvcHRpb25zLmluLCAnSW52YWxpZCBpbigpIHJlZmVyZW5jZSB1c2FnZScpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShwcmVmcy5jb250ZXh0LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShsb2NhbCwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmFuY2VzdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5jZXN0b3IgPT09ICdyb290Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUoc3RhdGUuYW5jZXN0b3JzW3N0YXRlLmFuY2VzdG9ycy5sZW5ndGggLSAxXSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KHRoaXMuYW5jZXN0b3IgPD0gc3RhdGUuYW5jZXN0b3JzLmxlbmd0aCwgJ0ludmFsaWQgcmVmZXJlbmNlIGV4Y2VlZHMgdGhlIHNjaGVtYSByb290OicsIHRoaXMuZGlzcGxheSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHN0YXRlLmFuY2VzdG9yc1t0aGlzLmFuY2VzdG9yIC0gMV0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfcmVzb2x2ZSh0YXJnZXQsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgbGV0IHJlc29sdmVkO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnNoYWRvdyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5zaGFkb3cgIT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgIHJlc29sdmVkID0gc3RhdGUubWFpbnN0YXkuc2hhZG93LmdldCh0aGlzLmFic29sdXRlKHN0YXRlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzb2x2ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSBSZWFjaCh0YXJnZXQsIHRoaXMucGF0aCwgeyBpdGVyYWJsZXM6IHRoaXMuaXRlcmFibGVzLCBmdW5jdGlvbnM6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hZGp1c3QpIHtcbiAgICAgICAgICAgIHJlc29sdmVkID0gdGhpcy5hZGp1c3QocmVzb2x2ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICBjb25zdCBtYXBwZWQgPSB0aGlzLm1hcC5nZXQocmVzb2x2ZWQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBtYXBwZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUubWFpbnN0YXkpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5yZXNvbHZlKHN0YXRlLCB0aGlzLCByZXNvbHZlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheTtcbiAgICB9XG5cbiAgICBhYnNvbHV0ZShzdGF0ZSkge1xuXG4gICAgICAgIHJldHVybiBbLi4uc3RhdGUucGF0aC5zbGljZSgwLCAtdGhpcy5hbmNlc3RvciksIC4uLnRoaXMucGF0aF07XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKHRoaXMpO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIGNvbnN0IHJlZiA9IHsgcGF0aDogdGhpcy5wYXRoIH07XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgcmVmLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXBhcmF0b3IgIT09ICcuJykge1xuICAgICAgICAgICAgcmVmLnNlcGFyYXRvciA9IHRoaXMuc2VwYXJhdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICAgICAgdGhpcy5hbmNlc3RvciAhPT0gMSkge1xuXG4gICAgICAgICAgICByZWYuYW5jZXN0b3IgPSB0aGlzLmFuY2VzdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICByZWYubWFwID0gWy4uLnRoaXMubWFwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsnYWRqdXN0JywgJ2l0ZXJhYmxlcycsICdyZW5kZXInXSkge1xuICAgICAgICAgICAgaWYgKHRoaXNba2V5XSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICByZWZba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmluICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVmLmluID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHJlZiB9O1xuICAgIH1cblxuICAgIHVwZGF0ZURpc3BsYXkoKSB7XG5cbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXkgIT09IG51bGwgPyB0aGlzLmtleSA6ICcnO1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7dGhpcy50eXBlfToke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnNlcGFyYXRvcikge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjoke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmFuY2VzdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7dGhpcy5zZXBhcmF0b3J9JHtrZXl9YDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFuY2VzdG9yID09PSAncm9vdCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6cm9vdDoke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5jZXN0b3IgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHtrZXkgfHwgJy4uJ31gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGVhZCA9IG5ldyBBcnJheSh0aGlzLmFuY2VzdG9yICsgMSkuZmlsbCh0aGlzLnNlcGFyYXRvcikuam9pbignJyk7XG4gICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHtsZWFkfSR7a2V5IHx8ICcnfWA7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuUmVmLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy5yZWZdID0gdHJ1ZTtcblxuXG5leHBvcnRzLmJ1aWxkID0gZnVuY3Rpb24gKGRlc2MpIHtcblxuICAgIGRlc2MgPSBPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbHMuZGVmYXVsdHMsIGRlc2MpO1xuICAgIGlmIChkZXNjLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgZGVzYy5hbmNlc3RvciA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgZGVzYy5hbmNlc3RvciA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKGRlc2MpO1xufTtcblxuXG5pbnRlcm5hbHMuY29udGV4dCA9IGZ1bmN0aW9uIChrZXksIHNlcGFyYXRvciwgcHJlZml4ID0ge30pIHtcblxuICAgIGtleSA9IGtleS50cmltKCk7XG5cbiAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIGNvbnN0IGdsb2JhbHAgPSBwcmVmaXguZ2xvYmFsID09PSB1bmRlZmluZWQgPyAnJCcgOiBwcmVmaXguZ2xvYmFsO1xuICAgICAgICBpZiAoZ2xvYmFscCAhPT0gc2VwYXJhdG9yICYmXG4gICAgICAgICAgICBrZXkuc3RhcnRzV2l0aChnbG9iYWxwKSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGtleS5zbGljZShnbG9iYWxwLmxlbmd0aCksIHR5cGU6ICdnbG9iYWwnIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2NhbCA9IHByZWZpeC5sb2NhbCA9PT0gdW5kZWZpbmVkID8gJyMnIDogcHJlZml4LmxvY2FsO1xuICAgICAgICBpZiAobG9jYWwgIT09IHNlcGFyYXRvciAmJlxuICAgICAgICAgICAga2V5LnN0YXJ0c1dpdGgobG9jYWwpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IGtleToga2V5LnNsaWNlKGxvY2FsLmxlbmd0aCksIHR5cGU6ICdsb2NhbCcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJvb3QgPSBwcmVmaXgucm9vdCA9PT0gdW5kZWZpbmVkID8gJy8nIDogcHJlZml4LnJvb3Q7XG4gICAgICAgIGlmIChyb290ICE9PSBzZXBhcmF0b3IgJiZcbiAgICAgICAgICAgIGtleS5zdGFydHNXaXRoKHJvb3QpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IGtleToga2V5LnNsaWNlKHJvb3QubGVuZ3RoKSwgdHlwZTogJ3ZhbHVlJywgcm9vdDogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsga2V5LCB0eXBlOiAndmFsdWUnIH07XG59O1xuXG5cbmludGVybmFscy5hbmNlc3RvciA9IGZ1bmN0aW9uIChrZXksIHNlcGFyYXRvcikge1xuXG4gICAgaWYgKCFzZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIFsxLCAwXTsgICAgICAgICAgICAgIC8vICdhX2InIC0+IDEgKHBhcmVudClcbiAgICB9XG5cbiAgICBpZiAoa2V5WzBdICE9PSBzZXBhcmF0b3IpIHsgICAgIC8vICdhLmInIC0+IDEgKHBhcmVudClcbiAgICAgICAgcmV0dXJuIFsxLCAwXTtcbiAgICB9XG5cbiAgICBpZiAoa2V5WzFdICE9PSBzZXBhcmF0b3IpIHsgICAgIC8vICcuYS5iJyAtPiAwIChzZWxmKVxuICAgICAgICByZXR1cm4gWzAsIDFdO1xuICAgIH1cblxuICAgIGxldCBpID0gMjtcbiAgICB3aGlsZSAoa2V5W2ldID09PSBzZXBhcmF0b3IpIHtcbiAgICAgICAgKytpO1xuICAgIH1cblxuICAgIHJldHVybiBbaSAtIDEsIGldOyAgICAgICAgICAgICAgLy8gJy4uLmEuYi4nIC0+IDIgKGdyYW5kcGFyZW50KVxufTtcblxuXG5leHBvcnRzLnRvU2libGluZyA9IDA7XG5cbmV4cG9ydHMudG9QYXJlbnQgPSAxO1xuXG5cbmV4cG9ydHMuTWFuYWdlciA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMucmVmcyA9IFtdOyAgICAgICAgICAgICAgICAgICAgIC8vIDA6IFtzZWxmIHJlZnNdLCAxOiBbcGFyZW50IHJlZnNdLCAyOiBbZ3JhbmRwYXJlbnQgcmVmc10sIC4uLlxuICAgIH1cblxuICAgIHJlZ2lzdGVyKHNvdXJjZSwgdGFyZ2V0KSB7XG5cbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCA9IHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZXhwb3J0cy50b1BhcmVudCA6IHRhcmdldDtcblxuICAgICAgICAvLyBBcnJheVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIocmVmLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTY2hlbWFcblxuICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBzb3VyY2UuX3JlZnMucmVmcykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmFuY2VzdG9yIC0gdGFyZ2V0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZzLnB1c2goeyBhbmNlc3RvcjogaXRlbS5hbmNlc3RvciAtIHRhcmdldCwgcm9vdDogaXRlbS5yb290IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVmZXJlbmNlXG5cbiAgICAgICAgaWYgKGV4cG9ydHMuaXNSZWYoc291cmNlKSAmJlxuICAgICAgICAgICAgc291cmNlLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgICAgIHNvdXJjZS5hbmNlc3RvciAtIHRhcmdldCA+PSAwKSB7XG5cbiAgICAgICAgICAgIHRoaXMucmVmcy5wdXNoKHsgYW5jZXN0b3I6IHNvdXJjZS5hbmNlc3RvciAtIHRhcmdldCwgcm9vdDogc291cmNlLnJvb3QgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW1wbGF0ZVxuXG4gICAgICAgIFRlbXBsYXRlID0gVGVtcGxhdGUgfHwgcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuXG4gICAgICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoc291cmNlLnJlZnMoKSwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgY29uc3QgY29weSA9IG5ldyBleHBvcnRzLk1hbmFnZXIoKTtcbiAgICAgICAgY29weS5yZWZzID0gQ2xvbmUodGhpcy5yZWZzKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG5cbiAgICAgICAgdGhpcy5yZWZzID0gW107XG4gICAgfVxuXG4gICAgcm9vdHMoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcy5maWx0ZXIoKHJlZikgPT4gIXJlZi5hbmNlc3RvcikubWFwKChyZWYpID0+IHJlZi5yb290KTtcbiAgICB9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/ref.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/schemas.js":
/*!*****************************************!*\
  !*** ./node_modules/joi/lib/schemas.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Joi = __webpack_require__(/*! ./index */ \"./node_modules/joi/lib/index.js\");\n\n\nconst internals = {};\n\n\n// Preferences\n\ninternals.wrap = Joi.string()\n    .min(1)\n    .max(2)\n    .allow(false);\n\n\nexports.preferences = Joi.object({\n    allowUnknown: Joi.boolean(),\n    abortEarly: Joi.boolean(),\n    artifacts: Joi.boolean(),\n    cache: Joi.boolean(),\n    context: Joi.object(),\n    convert: Joi.boolean(),\n    dateFormat: Joi.valid('date', 'iso', 'string', 'time', 'utc'),\n    debug: Joi.boolean(),\n    errors: {\n        escapeHtml: Joi.boolean(),\n        label: Joi.valid('path', 'key', false),\n        language: [\n            Joi.string(),\n            Joi.object().ref()\n        ],\n        render: Joi.boolean(),\n        stack: Joi.boolean(),\n        wrap: {\n            label: internals.wrap,\n            array: internals.wrap\n        }\n    },\n    externals: Joi.boolean(),\n    messages: Joi.object(),\n    noDefaults: Joi.boolean(),\n    nonEnumerables: Joi.boolean(),\n    presence: Joi.valid('required', 'optional', 'forbidden'),\n    skipFunctions: Joi.boolean(),\n    stripUnknown: Joi.object({\n        arrays: Joi.boolean(),\n        objects: Joi.boolean()\n    })\n        .or('arrays', 'objects')\n        .allow(true, false),\n    warnings: Joi.boolean()\n})\n    .strict();\n\n\n// Extensions\n\ninternals.nameRx = /^[a-zA-Z0-9]\\w*$/;\n\n\ninternals.rule = Joi.object({\n    alias: Joi.array().items(Joi.string().pattern(internals.nameRx)).single(),\n    args: Joi.array().items(\n        Joi.string(),\n        Joi.object({\n            name: Joi.string().pattern(internals.nameRx).required(),\n            ref: Joi.boolean(),\n            assert: Joi.alternatives([\n                Joi.function(),\n                Joi.object().schema()\n            ])\n                .conditional('ref', { is: true, then: Joi.required() }),\n            normalize: Joi.function(),\n            message: Joi.string().when('assert', { is: Joi.function(), then: Joi.required() })\n        })\n    ),\n    convert: Joi.boolean(),\n    manifest: Joi.boolean(),\n    method: Joi.function().allow(false),\n    multi: Joi.boolean(),\n    validate: Joi.function()\n});\n\n\nexports.extension = Joi.object({\n    type: Joi.alternatives([\n        Joi.string(),\n        Joi.object().regex()\n    ])\n        .required(),\n    args: Joi.function(),\n    cast: Joi.object().pattern(internals.nameRx, Joi.object({\n        from: Joi.function().maxArity(1).required(),\n        to: Joi.function().minArity(1).maxArity(2).required()\n    })),\n    base: Joi.object().schema()\n        .when('type', { is: Joi.object().regex(), then: Joi.forbidden() }),\n    coerce: [\n        Joi.function().maxArity(3),\n        Joi.object({ method: Joi.function().maxArity(3).required(), from: Joi.array().items(Joi.string()).single() })\n    ],\n    flags: Joi.object().pattern(internals.nameRx, Joi.object({\n        setter: Joi.string(),\n        default: Joi.any()\n    })),\n    manifest: {\n        build: Joi.function().arity(2)\n    },\n    messages: [Joi.object(), Joi.string()],\n    modifiers: Joi.object().pattern(internals.nameRx, Joi.function().minArity(1).maxArity(2)),\n    overrides: Joi.object().pattern(internals.nameRx, Joi.function()),\n    prepare: Joi.function().maxArity(3),\n    rebuild: Joi.function().arity(1),\n    rules: Joi.object().pattern(internals.nameRx, internals.rule),\n    terms: Joi.object().pattern(internals.nameRx, Joi.object({\n        init: Joi.array().allow(null).required(),\n        manifest: Joi.object().pattern(/.+/, [\n            Joi.valid('schema', 'single'),\n            Joi.object({\n                mapped: Joi.object({\n                    from: Joi.string().required(),\n                    to: Joi.string().required()\n                })\n                    .required()\n            })\n        ])\n    })),\n    validate: Joi.function().maxArity(3)\n})\n    .strict();\n\n\nexports.extensions = Joi.array().items(Joi.object(), Joi.function().arity(1)).strict();\n\n\n// Manifest\n\ninternals.desc = {\n\n    buffer: Joi.object({\n        buffer: Joi.string()\n    }),\n\n    func: Joi.object({\n        function: Joi.function().required(),\n        options: {\n            literal: true\n        }\n    }),\n\n    override: Joi.object({\n        override: true\n    }),\n\n    ref: Joi.object({\n        ref: Joi.object({\n            type: Joi.valid('value', 'global', 'local'),\n            path: Joi.array().required(),\n            separator: Joi.string().length(1).allow(false),\n            ancestor: Joi.number().min(0).integer().allow('root'),\n            map: Joi.array().items(Joi.array().length(2)).min(1),\n            adjust: Joi.function(),\n            iterables: Joi.boolean(),\n            in: Joi.boolean(),\n            render: Joi.boolean()\n        })\n            .required()\n    }),\n\n    regex: Joi.object({\n        regex: Joi.string().min(3)\n    }),\n\n    special: Joi.object({\n        special: Joi.valid('deep').required()\n    }),\n\n    template: Joi.object({\n        template: Joi.string().required(),\n        options: Joi.object()\n    }),\n\n    value: Joi.object({\n        value: Joi.alternatives([Joi.object(), Joi.array()]).required()\n    })\n};\n\n\ninternals.desc.entity = Joi.alternatives([\n    Joi.array().items(Joi.link('...')),\n    Joi.boolean(),\n    Joi.function(),\n    Joi.number(),\n    Joi.string(),\n    internals.desc.buffer,\n    internals.desc.func,\n    internals.desc.ref,\n    internals.desc.regex,\n    internals.desc.special,\n    internals.desc.template,\n    internals.desc.value,\n    Joi.link('/')\n]);\n\n\ninternals.desc.values = Joi.array()\n    .items(\n        null,\n        Joi.boolean(),\n        Joi.function(),\n        Joi.number().allow(Infinity, -Infinity),\n        Joi.string().allow(''),\n        Joi.symbol(),\n        internals.desc.buffer,\n        internals.desc.func,\n        internals.desc.override,\n        internals.desc.ref,\n        internals.desc.regex,\n        internals.desc.template,\n        internals.desc.value\n    );\n\n\ninternals.desc.messages = Joi.object()\n    .pattern(/.+/, [\n        Joi.string(),\n        internals.desc.template,\n        Joi.object().pattern(/.+/, [Joi.string(), internals.desc.template])\n    ]);\n\n\nexports.description = Joi.object({\n    type: Joi.string().required(),\n    flags: Joi.object({\n        cast: Joi.string(),\n        default: Joi.any(),\n        description: Joi.string(),\n        empty: Joi.link('/'),\n        failover: internals.desc.entity,\n        id: Joi.string(),\n        label: Joi.string(),\n        only: true,\n        presence: ['optional', 'required', 'forbidden'],\n        result: ['raw', 'strip'],\n        strip: Joi.boolean(),\n        unit: Joi.string()\n    })\n        .unknown(),\n    preferences: {\n        allowUnknown: Joi.boolean(),\n        abortEarly: Joi.boolean(),\n        artifacts: Joi.boolean(),\n        cache: Joi.boolean(),\n        convert: Joi.boolean(),\n        dateFormat: ['date', 'iso', 'string', 'time', 'utc'],\n        errors: {\n            escapeHtml: Joi.boolean(),\n            label: ['path', 'key'],\n            language: [\n                Joi.string(),\n                internals.desc.ref\n            ],\n            wrap: {\n                label: internals.wrap,\n                array: internals.wrap\n            }\n        },\n        externals: Joi.boolean(),\n        messages: internals.desc.messages,\n        noDefaults: Joi.boolean(),\n        nonEnumerables: Joi.boolean(),\n        presence: ['required', 'optional', 'forbidden'],\n        skipFunctions: Joi.boolean(),\n        stripUnknown: Joi.object({\n            arrays: Joi.boolean(),\n            objects: Joi.boolean()\n        })\n            .or('arrays', 'objects')\n            .allow(true, false),\n        warnings: Joi.boolean()\n    },\n    allow: internals.desc.values,\n    invalid: internals.desc.values,\n    rules: Joi.array().min(1).items({\n        name: Joi.string().required(),\n        args: Joi.object().min(1),\n        keep: Joi.boolean(),\n        message: [\n            Joi.string(),\n            internals.desc.messages\n        ],\n        warn: Joi.boolean()\n    }),\n\n    // Terms\n\n    keys: Joi.object().pattern(/.*/, Joi.link('/')),\n    link: internals.desc.ref\n})\n    .pattern(/^[a-z]\\w*$/, Joi.any());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9zY2hlbWFzLmpzP2ZkNzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLGdEQUFTOzs7QUFHN0I7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQSxrREFBa0QsMkNBQTJDO0FBQzdGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QixrREFBa0Q7QUFDekU7QUFDQTtBQUNBLG9CQUFvQixnR0FBZ0c7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvam9pL2xpYi9zY2hlbWFzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBKb2kgPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuLy8gUHJlZmVyZW5jZXNcblxuaW50ZXJuYWxzLndyYXAgPSBKb2kuc3RyaW5nKClcbiAgICAubWluKDEpXG4gICAgLm1heCgyKVxuICAgIC5hbGxvdyhmYWxzZSk7XG5cblxuZXhwb3J0cy5wcmVmZXJlbmNlcyA9IEpvaS5vYmplY3Qoe1xuICAgIGFsbG93VW5rbm93bjogSm9pLmJvb2xlYW4oKSxcbiAgICBhYm9ydEVhcmx5OiBKb2kuYm9vbGVhbigpLFxuICAgIGFydGlmYWN0czogSm9pLmJvb2xlYW4oKSxcbiAgICBjYWNoZTogSm9pLmJvb2xlYW4oKSxcbiAgICBjb250ZXh0OiBKb2kub2JqZWN0KCksXG4gICAgY29udmVydDogSm9pLmJvb2xlYW4oKSxcbiAgICBkYXRlRm9ybWF0OiBKb2kudmFsaWQoJ2RhdGUnLCAnaXNvJywgJ3N0cmluZycsICd0aW1lJywgJ3V0YycpLFxuICAgIGRlYnVnOiBKb2kuYm9vbGVhbigpLFxuICAgIGVycm9yczoge1xuICAgICAgICBlc2NhcGVIdG1sOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBsYWJlbDogSm9pLnZhbGlkKCdwYXRoJywgJ2tleScsIGZhbHNlKSxcbiAgICAgICAgbGFuZ3VhZ2U6IFtcbiAgICAgICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIEpvaS5vYmplY3QoKS5yZWYoKVxuICAgICAgICBdLFxuICAgICAgICByZW5kZXI6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHN0YWNrOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICB3cmFwOiB7XG4gICAgICAgICAgICBsYWJlbDogaW50ZXJuYWxzLndyYXAsXG4gICAgICAgICAgICBhcnJheTogaW50ZXJuYWxzLndyYXBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXh0ZXJuYWxzOiBKb2kuYm9vbGVhbigpLFxuICAgIG1lc3NhZ2VzOiBKb2kub2JqZWN0KCksXG4gICAgbm9EZWZhdWx0czogSm9pLmJvb2xlYW4oKSxcbiAgICBub25FbnVtZXJhYmxlczogSm9pLmJvb2xlYW4oKSxcbiAgICBwcmVzZW5jZTogSm9pLnZhbGlkKCdyZXF1aXJlZCcsICdvcHRpb25hbCcsICdmb3JiaWRkZW4nKSxcbiAgICBza2lwRnVuY3Rpb25zOiBKb2kuYm9vbGVhbigpLFxuICAgIHN0cmlwVW5rbm93bjogSm9pLm9iamVjdCh7XG4gICAgICAgIGFycmF5czogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgb2JqZWN0czogSm9pLmJvb2xlYW4oKVxuICAgIH0pXG4gICAgICAgIC5vcignYXJyYXlzJywgJ29iamVjdHMnKVxuICAgICAgICAuYWxsb3codHJ1ZSwgZmFsc2UpLFxuICAgIHdhcm5pbmdzOiBKb2kuYm9vbGVhbigpXG59KVxuICAgIC5zdHJpY3QoKTtcblxuXG4vLyBFeHRlbnNpb25zXG5cbmludGVybmFscy5uYW1lUnggPSAvXlthLXpBLVowLTldXFx3KiQvO1xuXG5cbmludGVybmFscy5ydWxlID0gSm9pLm9iamVjdCh7XG4gICAgYWxpYXM6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngpKS5zaW5nbGUoKSxcbiAgICBhcmdzOiBKb2kuYXJyYXkoKS5pdGVtcyhcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIG5hbWU6IEpvaS5zdHJpbmcoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngpLnJlcXVpcmVkKCksXG4gICAgICAgICAgICByZWY6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBhc3NlcnQ6IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgICAgICAgICAgICAgIEpvaS5mdW5jdGlvbigpLFxuICAgICAgICAgICAgICAgIEpvaS5vYmplY3QoKS5zY2hlbWEoKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAuY29uZGl0aW9uYWwoJ3JlZicsIHsgaXM6IHRydWUsIHRoZW46IEpvaS5yZXF1aXJlZCgpIH0pLFxuICAgICAgICAgICAgbm9ybWFsaXplOiBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IEpvaS5zdHJpbmcoKS53aGVuKCdhc3NlcnQnLCB7IGlzOiBKb2kuZnVuY3Rpb24oKSwgdGhlbjogSm9pLnJlcXVpcmVkKCkgfSlcbiAgICAgICAgfSlcbiAgICApLFxuICAgIGNvbnZlcnQ6IEpvaS5ib29sZWFuKCksXG4gICAgbWFuaWZlc3Q6IEpvaS5ib29sZWFuKCksXG4gICAgbWV0aG9kOiBKb2kuZnVuY3Rpb24oKS5hbGxvdyhmYWxzZSksXG4gICAgbXVsdGk6IEpvaS5ib29sZWFuKCksXG4gICAgdmFsaWRhdGU6IEpvaS5mdW5jdGlvbigpXG59KTtcblxuXG5leHBvcnRzLmV4dGVuc2lvbiA9IEpvaS5vYmplY3Qoe1xuICAgIHR5cGU6IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgICAgICBKb2kuc3RyaW5nKCksXG4gICAgICAgIEpvaS5vYmplY3QoKS5yZWdleCgpXG4gICAgXSlcbiAgICAgICAgLnJlcXVpcmVkKCksXG4gICAgYXJnczogSm9pLmZ1bmN0aW9uKCksXG4gICAgY2FzdDogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgSm9pLm9iamVjdCh7XG4gICAgICAgIGZyb206IEpvaS5mdW5jdGlvbigpLm1heEFyaXR5KDEpLnJlcXVpcmVkKCksXG4gICAgICAgIHRvOiBKb2kuZnVuY3Rpb24oKS5taW5Bcml0eSgxKS5tYXhBcml0eSgyKS5yZXF1aXJlZCgpXG4gICAgfSkpLFxuICAgIGJhc2U6IEpvaS5vYmplY3QoKS5zY2hlbWEoKVxuICAgICAgICAud2hlbigndHlwZScsIHsgaXM6IEpvaS5vYmplY3QoKS5yZWdleCgpLCB0aGVuOiBKb2kuZm9yYmlkZGVuKCkgfSksXG4gICAgY29lcmNlOiBbXG4gICAgICAgIEpvaS5mdW5jdGlvbigpLm1heEFyaXR5KDMpLFxuICAgICAgICBKb2kub2JqZWN0KHsgbWV0aG9kOiBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgzKS5yZXF1aXJlZCgpLCBmcm9tOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLnNpbmdsZSgpIH0pXG4gICAgXSxcbiAgICBmbGFnczogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgSm9pLm9iamVjdCh7XG4gICAgICAgIHNldHRlcjogSm9pLnN0cmluZygpLFxuICAgICAgICBkZWZhdWx0OiBKb2kuYW55KClcbiAgICB9KSksXG4gICAgbWFuaWZlc3Q6IHtcbiAgICAgICAgYnVpbGQ6IEpvaS5mdW5jdGlvbigpLmFyaXR5KDIpXG4gICAgfSxcbiAgICBtZXNzYWdlczogW0pvaS5vYmplY3QoKSwgSm9pLnN0cmluZygpXSxcbiAgICBtb2RpZmllcnM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5mdW5jdGlvbigpLm1pbkFyaXR5KDEpLm1heEFyaXR5KDIpKSxcbiAgICBvdmVycmlkZXM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5mdW5jdGlvbigpKSxcbiAgICBwcmVwYXJlOiBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgzKSxcbiAgICByZWJ1aWxkOiBKb2kuZnVuY3Rpb24oKS5hcml0eSgxKSxcbiAgICBydWxlczogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgaW50ZXJuYWxzLnJ1bGUpLFxuICAgIHRlcm1zOiBKb2kub2JqZWN0KCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4LCBKb2kub2JqZWN0KHtcbiAgICAgICAgaW5pdDogSm9pLmFycmF5KCkuYWxsb3cobnVsbCkucmVxdWlyZWQoKSxcbiAgICAgICAgbWFuaWZlc3Q6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKC8uKy8sIFtcbiAgICAgICAgICAgIEpvaS52YWxpZCgnc2NoZW1hJywgJ3NpbmdsZScpLFxuICAgICAgICAgICAgSm9pLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgbWFwcGVkOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgICAgICAgICAgICAgICAgIHRvOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5yZXF1aXJlZCgpXG4gICAgICAgICAgICB9KVxuICAgICAgICBdKVxuICAgIH0pKSxcbiAgICB2YWxpZGF0ZTogSm9pLmZ1bmN0aW9uKCkubWF4QXJpdHkoMylcbn0pXG4gICAgLnN0cmljdCgpO1xuXG5cbmV4cG9ydHMuZXh0ZW5zaW9ucyA9IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5vYmplY3QoKSwgSm9pLmZ1bmN0aW9uKCkuYXJpdHkoMSkpLnN0cmljdCgpO1xuXG5cbi8vIE1hbmlmZXN0XG5cbmludGVybmFscy5kZXNjID0ge1xuXG4gICAgYnVmZmVyOiBKb2kub2JqZWN0KHtcbiAgICAgICAgYnVmZmVyOiBKb2kuc3RyaW5nKClcbiAgICB9KSxcblxuICAgIGZ1bmM6IEpvaS5vYmplY3Qoe1xuICAgICAgICBmdW5jdGlvbjogSm9pLmZ1bmN0aW9uKCkucmVxdWlyZWQoKSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgbGl0ZXJhbDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSksXG5cbiAgICBvdmVycmlkZTogSm9pLm9iamVjdCh7XG4gICAgICAgIG92ZXJyaWRlOiB0cnVlXG4gICAgfSksXG5cbiAgICByZWY6IEpvaS5vYmplY3Qoe1xuICAgICAgICByZWY6IEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogSm9pLnZhbGlkKCd2YWx1ZScsICdnbG9iYWwnLCAnbG9jYWwnKSxcbiAgICAgICAgICAgIHBhdGg6IEpvaS5hcnJheSgpLnJlcXVpcmVkKCksXG4gICAgICAgICAgICBzZXBhcmF0b3I6IEpvaS5zdHJpbmcoKS5sZW5ndGgoMSkuYWxsb3coZmFsc2UpLFxuICAgICAgICAgICAgYW5jZXN0b3I6IEpvaS5udW1iZXIoKS5taW4oMCkuaW50ZWdlcigpLmFsbG93KCdyb290JyksXG4gICAgICAgICAgICBtYXA6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5hcnJheSgpLmxlbmd0aCgyKSkubWluKDEpLFxuICAgICAgICAgICAgYWRqdXN0OiBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgICAgIGl0ZXJhYmxlczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIGluOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgcmVuZGVyOiBKb2kuYm9vbGVhbigpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAucmVxdWlyZWQoKVxuICAgIH0pLFxuXG4gICAgcmVnZXg6IEpvaS5vYmplY3Qoe1xuICAgICAgICByZWdleDogSm9pLnN0cmluZygpLm1pbigzKVxuICAgIH0pLFxuXG4gICAgc3BlY2lhbDogSm9pLm9iamVjdCh7XG4gICAgICAgIHNwZWNpYWw6IEpvaS52YWxpZCgnZGVlcCcpLnJlcXVpcmVkKClcbiAgICB9KSxcblxuICAgIHRlbXBsYXRlOiBKb2kub2JqZWN0KHtcbiAgICAgICAgdGVtcGxhdGU6IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpLFxuICAgICAgICBvcHRpb25zOiBKb2kub2JqZWN0KClcbiAgICB9KSxcblxuICAgIHZhbHVlOiBKb2kub2JqZWN0KHtcbiAgICAgICAgdmFsdWU6IEpvaS5hbHRlcm5hdGl2ZXMoW0pvaS5vYmplY3QoKSwgSm9pLmFycmF5KCldKS5yZXF1aXJlZCgpXG4gICAgfSlcbn07XG5cblxuaW50ZXJuYWxzLmRlc2MuZW50aXR5ID0gSm9pLmFsdGVybmF0aXZlcyhbXG4gICAgSm9pLmFycmF5KCkuaXRlbXMoSm9pLmxpbmsoJy4uLicpKSxcbiAgICBKb2kuYm9vbGVhbigpLFxuICAgIEpvaS5mdW5jdGlvbigpLFxuICAgIEpvaS5udW1iZXIoKSxcbiAgICBKb2kuc3RyaW5nKCksXG4gICAgaW50ZXJuYWxzLmRlc2MuYnVmZmVyLFxuICAgIGludGVybmFscy5kZXNjLmZ1bmMsXG4gICAgaW50ZXJuYWxzLmRlc2MucmVmLFxuICAgIGludGVybmFscy5kZXNjLnJlZ2V4LFxuICAgIGludGVybmFscy5kZXNjLnNwZWNpYWwsXG4gICAgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGUsXG4gICAgaW50ZXJuYWxzLmRlc2MudmFsdWUsXG4gICAgSm9pLmxpbmsoJy8nKVxuXSk7XG5cblxuaW50ZXJuYWxzLmRlc2MudmFsdWVzID0gSm9pLmFycmF5KClcbiAgICAuaXRlbXMoXG4gICAgICAgIG51bGwsXG4gICAgICAgIEpvaS5ib29sZWFuKCksXG4gICAgICAgIEpvaS5mdW5jdGlvbigpLFxuICAgICAgICBKb2kubnVtYmVyKCkuYWxsb3coSW5maW5pdHksIC1JbmZpbml0eSksXG4gICAgICAgIEpvaS5zdHJpbmcoKS5hbGxvdygnJyksXG4gICAgICAgIEpvaS5zeW1ib2woKSxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MuYnVmZmVyLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy5mdW5jLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy5vdmVycmlkZSxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MucmVmLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy5yZWdleCxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGUsXG4gICAgICAgIGludGVybmFscy5kZXNjLnZhbHVlXG4gICAgKTtcblxuXG5pbnRlcm5hbHMuZGVzYy5tZXNzYWdlcyA9IEpvaS5vYmplY3QoKVxuICAgIC5wYXR0ZXJuKC8uKy8sIFtcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy50ZW1wbGF0ZSxcbiAgICAgICAgSm9pLm9iamVjdCgpLnBhdHRlcm4oLy4rLywgW0pvaS5zdHJpbmcoKSwgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGVdKVxuICAgIF0pO1xuXG5cbmV4cG9ydHMuZGVzY3JpcHRpb24gPSBKb2kub2JqZWN0KHtcbiAgICB0eXBlOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICBmbGFnczogSm9pLm9iamVjdCh7XG4gICAgICAgIGNhc3Q6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgZGVmYXVsdDogSm9pLmFueSgpLFxuICAgICAgICBkZXNjcmlwdGlvbjogSm9pLnN0cmluZygpLFxuICAgICAgICBlbXB0eTogSm9pLmxpbmsoJy8nKSxcbiAgICAgICAgZmFpbG92ZXI6IGludGVybmFscy5kZXNjLmVudGl0eSxcbiAgICAgICAgaWQ6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgbGFiZWw6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgb25seTogdHJ1ZSxcbiAgICAgICAgcHJlc2VuY2U6IFsnb3B0aW9uYWwnLCAncmVxdWlyZWQnLCAnZm9yYmlkZGVuJ10sXG4gICAgICAgIHJlc3VsdDogWydyYXcnLCAnc3RyaXAnXSxcbiAgICAgICAgc3RyaXA6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHVuaXQ6IEpvaS5zdHJpbmcoKVxuICAgIH0pXG4gICAgICAgIC51bmtub3duKCksXG4gICAgcHJlZmVyZW5jZXM6IHtcbiAgICAgICAgYWxsb3dVbmtub3duOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBhYm9ydEVhcmx5OiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBhcnRpZmFjdHM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIGNhY2hlOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBjb252ZXJ0OiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBkYXRlRm9ybWF0OiBbJ2RhdGUnLCAnaXNvJywgJ3N0cmluZycsICd0aW1lJywgJ3V0YyddLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgIGVzY2FwZUh0bWw6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBsYWJlbDogWydwYXRoJywgJ2tleSddLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IFtcbiAgICAgICAgICAgICAgICBKb2kuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzLmRlc2MucmVmXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgd3JhcDoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBpbnRlcm5hbHMud3JhcCxcbiAgICAgICAgICAgICAgICBhcnJheTogaW50ZXJuYWxzLndyYXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXh0ZXJuYWxzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBtZXNzYWdlczogaW50ZXJuYWxzLmRlc2MubWVzc2FnZXMsXG4gICAgICAgIG5vRGVmYXVsdHM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIG5vbkVudW1lcmFibGVzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBwcmVzZW5jZTogWydyZXF1aXJlZCcsICdvcHRpb25hbCcsICdmb3JiaWRkZW4nXSxcbiAgICAgICAgc2tpcEZ1bmN0aW9uczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgc3RyaXBVbmtub3duOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIGFycmF5czogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIG9iamVjdHM6IEpvaS5ib29sZWFuKClcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vcignYXJyYXlzJywgJ29iamVjdHMnKVxuICAgICAgICAgICAgLmFsbG93KHRydWUsIGZhbHNlKSxcbiAgICAgICAgd2FybmluZ3M6IEpvaS5ib29sZWFuKClcbiAgICB9LFxuICAgIGFsbG93OiBpbnRlcm5hbHMuZGVzYy52YWx1ZXMsXG4gICAgaW52YWxpZDogaW50ZXJuYWxzLmRlc2MudmFsdWVzLFxuICAgIHJ1bGVzOiBKb2kuYXJyYXkoKS5taW4oMSkuaXRlbXMoe1xuICAgICAgICBuYW1lOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICAgICAgYXJnczogSm9pLm9iamVjdCgpLm1pbigxKSxcbiAgICAgICAga2VlcDogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgbWVzc2FnZTogW1xuICAgICAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICAgICAgaW50ZXJuYWxzLmRlc2MubWVzc2FnZXNcbiAgICAgICAgXSxcbiAgICAgICAgd2FybjogSm9pLmJvb2xlYW4oKVxuICAgIH0pLFxuXG4gICAgLy8gVGVybXNcblxuICAgIGtleXM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKC8uKi8sIEpvaS5saW5rKCcvJykpLFxuICAgIGxpbms6IGludGVybmFscy5kZXNjLnJlZlxufSlcbiAgICAucGF0dGVybigvXlthLXpdXFx3KiQvLCBKb2kuYW55KCkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/schemas.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/state.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/state.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"@hapi/hoek/lib/clone\");\nconst Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ \"@hapi/hoek/lib/reach\");\n\nconst Common = __webpack_require__(/*! ./common */ \"./node_modules/joi/lib/common.js\");\n\n\nconst internals = {\n    value: Symbol('value')\n};\n\n\nmodule.exports = internals.State = class {\n\n    constructor(path, ancestors, state) {\n\n        this.path = path;\n        this.ancestors = ancestors;                 // [parent, ..., root]\n\n        this.mainstay = state.mainstay;\n        this.schemas = state.schemas;               // [current, ..., root]\n        this.debug = null;\n    }\n\n    localize(path, ancestors = null, schema = null) {\n\n        const state = new internals.State(path, ancestors, this);\n\n        if (schema &&\n            state.schemas) {\n\n            state.schemas = [internals.schemas(schema), ...state.schemas];\n        }\n\n        return state;\n    }\n\n    nest(schema, debug) {\n\n        const state = new internals.State(this.path, this.ancestors, this);\n        state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];\n        state.debug = debug;\n        return state;\n    }\n\n    shadow(value, reason) {\n\n        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();\n        this.mainstay.shadow.set(this.path, value, reason);\n    }\n\n    snapshot() {\n\n        if (this.mainstay.shadow) {\n            this._snapshot = Clone(this.mainstay.shadow.node(this.path));\n        }\n    }\n\n    restore() {\n\n        if (this.mainstay.shadow) {\n            this.mainstay.shadow.override(this.path, this._snapshot);\n            this._snapshot = undefined;\n        }\n    }\n};\n\n\ninternals.schemas = function (schema) {\n\n    if (Common.isSchema(schema)) {\n        return { schema };\n    }\n\n    return schema;\n};\n\n\ninternals.Shadow = class {\n\n    constructor() {\n\n        this._values = null;\n    }\n\n    set(path, value, reason) {\n\n        if (!path.length) {                                     // No need to store root value\n            return;\n        }\n\n        if (reason === 'strip' &&\n            typeof path[path.length - 1] === 'number') {        // Cannot store stripped array values (due to shift)\n\n            return;\n        }\n\n        this._values = this._values || new Map();\n\n        let node = this._values;\n        for (let i = 0; i < path.length; ++i) {\n            const segment = path[i];\n            let next = node.get(segment);\n            if (!next) {\n                next = new Map();\n                node.set(segment, next);\n            }\n\n            node = next;\n        }\n\n        node[internals.value] = value;\n    }\n\n    get(path) {\n\n        const node = this.node(path);\n        if (node) {\n            return node[internals.value];\n        }\n    }\n\n    node(path) {\n\n        if (!this._values) {\n            return;\n        }\n\n        return Reach(this._values, path, { iterables: true });\n    }\n\n    override(path, node) {\n\n        if (!this._values) {\n            return;\n        }\n\n        const parents = path.slice(0, -1);\n        const own = path[path.length - 1];\n        const parent = Reach(this._values, parents, { iterables: true });\n\n        if (node) {\n            parent.set(own, node);\n            return;\n        }\n\n        if (parent) {\n            parent.delete(own);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9zdGF0ZS5qcz85MmIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxrREFBc0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLGtEQUFzQjs7QUFFNUMsZUFBZSxtQkFBTyxDQUFDLGtEQUFVOzs7QUFHakM7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLGtCQUFrQjtBQUM1RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0I7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvam9pL2xpYi9zdGF0ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgUmVhY2ggPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9yZWFjaCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICB2YWx1ZTogU3ltYm9sKCd2YWx1ZScpXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlN0YXRlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IocGF0aCwgYW5jZXN0b3JzLCBzdGF0ZSkge1xuXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuYW5jZXN0b3JzID0gYW5jZXN0b3JzOyAgICAgICAgICAgICAgICAgLy8gW3BhcmVudCwgLi4uLCByb290XVxuXG4gICAgICAgIHRoaXMubWFpbnN0YXkgPSBzdGF0ZS5tYWluc3RheTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gc3RhdGUuc2NoZW1hczsgICAgICAgICAgICAgICAvLyBbY3VycmVudCwgLi4uLCByb290XVxuICAgICAgICB0aGlzLmRlYnVnID0gbnVsbDtcbiAgICB9XG5cbiAgICBsb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMgPSBudWxsLCBzY2hlbWEgPSBudWxsKSB7XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgaW50ZXJuYWxzLlN0YXRlKHBhdGgsIGFuY2VzdG9ycywgdGhpcyk7XG5cbiAgICAgICAgaWYgKHNjaGVtYSAmJlxuICAgICAgICAgICAgc3RhdGUuc2NoZW1hcykge1xuXG4gICAgICAgICAgICBzdGF0ZS5zY2hlbWFzID0gW2ludGVybmFscy5zY2hlbWFzKHNjaGVtYSksIC4uLnN0YXRlLnNjaGVtYXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIG5lc3Qoc2NoZW1hLCBkZWJ1Zykge1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gbmV3IGludGVybmFscy5TdGF0ZSh0aGlzLnBhdGgsIHRoaXMuYW5jZXN0b3JzLCB0aGlzKTtcbiAgICAgICAgc3RhdGUuc2NoZW1hcyA9IHN0YXRlLnNjaGVtYXMgJiYgW2ludGVybmFscy5zY2hlbWFzKHNjaGVtYSksIC4uLnN0YXRlLnNjaGVtYXNdO1xuICAgICAgICBzdGF0ZS5kZWJ1ZyA9IGRlYnVnO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgc2hhZG93KHZhbHVlLCByZWFzb24pIHtcblxuICAgICAgICB0aGlzLm1haW5zdGF5LnNoYWRvdyA9IHRoaXMubWFpbnN0YXkuc2hhZG93IHx8IG5ldyBpbnRlcm5hbHMuU2hhZG93KCk7XG4gICAgICAgIHRoaXMubWFpbnN0YXkuc2hhZG93LnNldCh0aGlzLnBhdGgsIHZhbHVlLCByZWFzb24pO1xuICAgIH1cblxuICAgIHNuYXBzaG90KCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1haW5zdGF5LnNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5fc25hcHNob3QgPSBDbG9uZSh0aGlzLm1haW5zdGF5LnNoYWRvdy5ub2RlKHRoaXMucGF0aCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzdG9yZSgpIHtcblxuICAgICAgICBpZiAodGhpcy5tYWluc3RheS5zaGFkb3cpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbnN0YXkuc2hhZG93Lm92ZXJyaWRlKHRoaXMucGF0aCwgdGhpcy5fc25hcHNob3QpO1xuICAgICAgICAgICAgdGhpcy5fc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zY2hlbWFzID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgaWYgKENvbW1vbi5pc1NjaGVtYShzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiB7IHNjaGVtYSB9O1xuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWE7XG59O1xuXG5cbmludGVybmFscy5TaGFkb3cgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHNldChwYXRoLCB2YWx1ZSwgcmVhc29uKSB7XG5cbiAgICAgICAgaWYgKCFwYXRoLmxlbmd0aCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIHN0b3JlIHJvb3QgdmFsdWVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWFzb24gPT09ICdzdHJpcCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICdudW1iZXInKSB7ICAgICAgICAvLyBDYW5ub3Qgc3RvcmUgc3RyaXBwZWQgYXJyYXkgdmFsdWVzIChkdWUgdG8gc2hpZnQpXG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHRoaXMuX3ZhbHVlcyB8fCBuZXcgTWFwKCk7XG5cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl92YWx1ZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHBhdGhbaV07XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUuZ2V0KHNlZ21lbnQpO1xuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBub2RlLnNldChzZWdtZW50LCBuZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlW2ludGVybmFscy52YWx1ZV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQocGF0aCkge1xuXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGUocGF0aCk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZVtpbnRlcm5hbHMudmFsdWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbm9kZShwYXRoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjaCh0aGlzLl92YWx1ZXMsIHBhdGgsIHsgaXRlcmFibGVzOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIG92ZXJyaWRlKHBhdGgsIG5vZGUpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyZW50cyA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgICAgICBjb25zdCBvd24gPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IFJlYWNoKHRoaXMuX3ZhbHVlcywgcGFyZW50cywgeyBpdGVyYWJsZXM6IHRydWUgfSk7XG5cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudC5zZXQob3duLCBub2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5kZWxldGUob3duKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/state.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/template.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/template.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"@hapi/hoek/lib/clone\");\nconst EscapeHtml = __webpack_require__(/*! @hapi/hoek/lib/escapeHtml */ \"@hapi/hoek/lib/escapeHtml\");\nconst Formula = __webpack_require__(/*! @sideway/formula */ \"@sideway/formula\");\n\nconst Common = __webpack_require__(/*! ./common */ \"./node_modules/joi/lib/common.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"./node_modules/joi/lib/errors.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"./node_modules/joi/lib/ref.js\");\n\n\nconst internals = {\n    symbol: Symbol('template'),\n\n    opens: new Array(1000).join('\\u0000'),\n    closes: new Array(1000).join('\\u0001'),\n\n    dateFormat: {\n        date: Date.prototype.toDateString,\n        iso: Date.prototype.toISOString,\n        string: Date.prototype.toString,\n        time: Date.prototype.toTimeString,\n        utc: Date.prototype.toUTCString\n    }\n};\n\n\nmodule.exports = exports = internals.Template = class {\n\n    constructor(source, options) {\n\n        Assert(typeof source === 'string', 'Template source must be a string');\n        Assert(!source.includes('\\u0000') && !source.includes('\\u0001'), 'Template source cannot contain reserved control characters');\n\n        this.source = source;\n        this.rendered = source;\n\n        this._template = null;\n        this._settings = Clone(options);\n\n        this._parse();\n    }\n\n    _parse() {\n\n        // 'text {raw} {{ref}} \\\\{{ignore}} {{ignore\\\\}} {{ignore {{ignore}'\n\n        if (!this.source.includes('{')) {\n            return;\n        }\n\n        // Encode escaped \\\\{{{{{\n\n        const encoded = internals.encode(this.source);\n\n        // Split on first { in each set\n\n        const parts = internals.split(encoded);\n\n        // Process parts\n\n        let refs = false;\n        const processed = [];\n        const head = parts.shift();\n        if (head) {\n            processed.push(head);\n        }\n\n        for (const part of parts) {\n            const raw = part[0] !== '{';\n            const ender = raw ? '}' : '}}';\n            const end = part.indexOf(ender);\n            if (end === -1 ||                               // Ignore non-matching closing\n                part[1] === '{') {                          // Ignore more than two {\n\n                processed.push(`{${internals.decode(part)}`);\n                continue;\n            }\n\n            let variable = part.slice(raw ? 0 : 1, end);\n            const wrapped = variable[0] === ':';\n            if (wrapped) {\n                variable = variable.slice(1);\n            }\n\n            const dynamic = this._ref(internals.decode(variable), { raw, wrapped });\n            processed.push(dynamic);\n            if (typeof dynamic !== 'string') {\n                refs = true;\n            }\n\n            const rest = part.slice(end + ender.length);\n            if (rest) {\n                processed.push(internals.decode(rest));\n            }\n        }\n\n        if (!refs) {\n            this.rendered = processed.join('');\n            return;\n        }\n\n        this._template = processed;\n    }\n\n    static date(date, prefs) {\n\n        return internals.dateFormat[prefs.dateFormat].call(date);\n    }\n\n    describe(options = {}) {\n\n        if (!this._settings &&\n            options.compact) {\n\n            return this.source;\n        }\n\n        const desc = { template: this.source };\n        if (this._settings) {\n            desc.options = this._settings;\n        }\n\n        return desc;\n    }\n\n    static build(desc) {\n\n        return new internals.Template(desc.template, desc.options);\n    }\n\n    isDynamic() {\n\n        return !!this._template;\n    }\n\n    static isTemplate(template) {\n\n        return template ? !!template[Common.symbols.template] : false;\n    }\n\n    refs() {\n\n        if (!this._template) {\n            return;\n        }\n\n        const refs = [];\n        for (const part of this._template) {\n            if (typeof part !== 'string') {\n                refs.push(...part.refs);\n            }\n        }\n\n        return refs;\n    }\n\n    resolve(value, state, prefs, local) {\n\n        if (this._template &&\n            this._template.length === 1) {\n\n            return this._part(this._template[0], /* context -> [*/ value, state, prefs, local, {} /*] */);\n        }\n\n        return this.render(value, state, prefs, local);\n    }\n\n    _part(part, ...args) {\n\n        if (part.ref) {\n            return part.ref.resolve(...args);\n        }\n\n        return part.formula.evaluate(args);\n    }\n\n    render(value, state, prefs, local, options = {}) {\n\n        if (!this.isDynamic()) {\n            return this.rendered;\n        }\n\n        const parts = [];\n        for (const part of this._template) {\n            if (typeof part === 'string') {\n                parts.push(part);\n            }\n            else {\n                const rendered = this._part(part, /* context -> [*/ value, state, prefs, local, options /*] */);\n                const string = internals.stringify(rendered, value, state, prefs, local, options);\n                if (string !== undefined) {\n                    const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);\n                    parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));\n                }\n            }\n        }\n\n        return parts.join('');\n    }\n\n    _ref(content, { raw, wrapped }) {\n\n        const refs = [];\n        const reference = (variable) => {\n\n            const ref = Ref.create(variable, this._settings);\n            refs.push(ref);\n            return (context) => ref.resolve(...context);\n        };\n\n        try {\n            var formula = new Formula.Parser(content, { reference, functions: internals.functions, constants: internals.constants });\n        }\n        catch (err) {\n            err.message = `Invalid template variable \"${content}\" fails due to: ${err.message}`;\n            throw err;\n        }\n\n        if (formula.single) {\n            if (formula.single.type === 'reference') {\n                const ref = refs[0];\n                return { ref, raw, refs, wrapped: wrapped || ref.type === 'local' && ref.key === 'label' };\n            }\n\n            return internals.stringify(formula.single.value);\n        }\n\n        return { formula, raw, refs };\n    }\n\n    toString() {\n\n        return this.source;\n    }\n};\n\n\ninternals.Template.prototype[Common.symbols.template] = true;\ninternals.Template.prototype.isImmutable = true;                // Prevents Hoek from deep cloning schema objects\n\n\ninternals.encode = function (string) {\n\n    return string\n        .replace(/\\\\(\\{+)/g, ($0, $1) => {\n\n            return internals.opens.slice(0, $1.length);\n        })\n        .replace(/\\\\(\\}+)/g, ($0, $1) => {\n\n            return internals.closes.slice(0, $1.length);\n        });\n};\n\n\ninternals.decode = function (string) {\n\n    return string\n        .replace(/\\u0000/g, '{')\n        .replace(/\\u0001/g, '}');\n};\n\n\ninternals.split = function (string) {\n\n    const parts = [];\n    let current = '';\n\n    for (let i = 0; i < string.length; ++i) {\n        const char = string[i];\n\n        if (char === '{') {\n            let next = '';\n            while (i + 1 < string.length &&\n                string[i + 1] === '{') {\n\n                next += '{';\n                ++i;\n            }\n\n            parts.push(current);\n            current = next;\n        }\n        else {\n            current += char;\n        }\n    }\n\n    parts.push(current);\n    return parts;\n};\n\n\ninternals.wrap = function (value, ends) {\n\n    if (!ends) {\n        return value;\n    }\n\n    if (ends.length === 1) {\n        return `${ends}${value}${ends}`;\n    }\n\n    return `${ends[0]}${value}${ends[1]}`;\n};\n\n\ninternals.stringify = function (value, original, state, prefs, local, options) {\n\n    const type = typeof value;\n\n    let skipWrap = false;\n    if (Ref.isRef(value) &&\n        value.render) {\n\n        skipWrap = value.in;\n        value = value.resolve(original, state, prefs, local, { in: value.in, ...options });\n    }\n\n    if (value === null) {\n        return 'null';\n    }\n\n    if (type === 'string') {\n        return value;\n    }\n\n    if (type === 'number' ||\n        type === 'function' ||\n        type === 'symbol') {\n\n        return value.toString();\n    }\n\n    if (type !== 'object') {\n        return JSON.stringify(value);\n    }\n\n    if (value instanceof Date) {\n        return internals.Template.date(value, prefs);\n    }\n\n    if (value instanceof Map) {\n        const pairs = [];\n        for (const [key, sym] of value.entries()) {\n            pairs.push(`${key.toString()} -> ${sym.toString()}`);\n        }\n\n        value = pairs;\n    }\n\n    if (!Array.isArray(value)) {\n        return value.toString();\n    }\n\n    let partial = '';\n    for (const item of value) {\n        partial = partial + (partial.length ? ', ' : '') + internals.stringify(item, original, state, prefs, local, options);\n    }\n\n    if (skipWrap) {\n        return partial;\n    }\n\n    return internals.wrap(partial, prefs.errors.wrap.array);\n};\n\n\ninternals.constants = {\n\n    true: true,\n    false: false,\n    null: null,\n\n    second: 1000,\n    minute: 60 * 1000,\n    hour: 60 * 60 * 1000,\n    day: 24 * 60 * 60 * 1000\n};\n\n\ninternals.functions = {\n\n    if(condition, then, otherwise) {\n\n        return condition ? then : otherwise;\n    },\n\n    msg(code) {\n\n        const [value, state, prefs, local, options] = this;\n        const messages = options.messages;\n        if (!messages) {\n            return '';\n        }\n\n        const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);\n        if (!template) {\n            return '';\n        }\n\n        return template.render(value, state, prefs, local, options);\n    },\n\n    number(value) {\n\n        if (typeof value === 'number') {\n            return value;\n        }\n\n        if (typeof value === 'string') {\n            return parseFloat(value);\n        }\n\n        if (typeof value === 'boolean') {\n            return value ? 1 : 0;\n        }\n\n        if (value instanceof Date) {\n            return value.getTime();\n        }\n\n        return null;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90ZW1wbGF0ZS5qcz8zYWFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxvREFBdUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLGtEQUFzQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyw0REFBMkI7QUFDdEQsZ0JBQWdCLG1CQUFPLENBQUMsMENBQWtCOztBQUUxQyxlQUFlLG1CQUFPLENBQUMsa0RBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLGtEQUFVO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTzs7O0FBRzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixJQUFJLEdBQUcsS0FBSyxLQUFLLFFBQVEsR0FBRyxVQUFVLEdBQUcsU0FBUyxPQUFPOztBQUUzRSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwyQkFBMkI7O0FBRTNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QyxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0EsOEJBQThCLElBQUk7O0FBRWxDLGlDQUFpQyxFQUFFLHVCQUF1QjtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUVBQW1FLGVBQWU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlHQUFpRztBQUNqRzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsZUFBZTs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCw0RUFBNEU7QUFDbkk7QUFDQTtBQUNBLHdEQUF3RCxRQUFRLGtCQUFrQixZQUFZO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxnREFBZ0Q7OztBQUdoRDs7QUFFQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCOztBQUV2QjtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSztBQUN0Qzs7QUFFQSxjQUFjLFFBQVEsRUFBRSxNQUFNLEVBQUUsUUFBUTtBQUN4Qzs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThELDJCQUEyQjtBQUN6Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWUsTUFBTSxlQUFlO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvam9pL2xpYi90ZW1wbGF0ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5jb25zdCBFc2NhcGVIdG1sID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZXNjYXBlSHRtbCcpO1xuY29uc3QgRm9ybXVsYSA9IHJlcXVpcmUoJ0BzaWRld2F5L2Zvcm11bGEnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBzeW1ib2w6IFN5bWJvbCgndGVtcGxhdGUnKSxcblxuICAgIG9wZW5zOiBuZXcgQXJyYXkoMTAwMCkuam9pbignXFx1MDAwMCcpLFxuICAgIGNsb3NlczogbmV3IEFycmF5KDEwMDApLmpvaW4oJ1xcdTAwMDEnKSxcblxuICAgIGRhdGVGb3JtYXQ6IHtcbiAgICAgICAgZGF0ZTogRGF0ZS5wcm90b3R5cGUudG9EYXRlU3RyaW5nLFxuICAgICAgICBpc286IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nLFxuICAgICAgICBzdHJpbmc6IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICB0aW1lOiBEYXRlLnByb3RvdHlwZS50b1RpbWVTdHJpbmcsXG4gICAgICAgIHV0YzogRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmdcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGludGVybmFscy5UZW1wbGF0ZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJywgJ1RlbXBsYXRlIHNvdXJjZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIEFzc2VydCghc291cmNlLmluY2x1ZGVzKCdcXHUwMDAwJykgJiYgIXNvdXJjZS5pbmNsdWRlcygnXFx1MDAwMScpLCAnVGVtcGxhdGUgc291cmNlIGNhbm5vdCBjb250YWluIHJlc2VydmVkIGNvbnRyb2wgY2hhcmFjdGVycycpO1xuXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnJlbmRlcmVkID0gc291cmNlO1xuXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBDbG9uZShvcHRpb25zKTtcblxuICAgICAgICB0aGlzLl9wYXJzZSgpO1xuICAgIH1cblxuICAgIF9wYXJzZSgpIHtcblxuICAgICAgICAvLyAndGV4dCB7cmF3fSB7e3JlZn19IFxcXFx7e2lnbm9yZX19IHt7aWdub3JlXFxcXH19IHt7aWdub3JlIHt7aWdub3JlfSdcblxuICAgICAgICBpZiAoIXRoaXMuc291cmNlLmluY2x1ZGVzKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuY29kZSBlc2NhcGVkIFxcXFx7e3t7e1xuXG4gICAgICAgIGNvbnN0IGVuY29kZWQgPSBpbnRlcm5hbHMuZW5jb2RlKHRoaXMuc291cmNlKTtcblxuICAgICAgICAvLyBTcGxpdCBvbiBmaXJzdCB7IGluIGVhY2ggc2V0XG5cbiAgICAgICAgY29uc3QgcGFydHMgPSBpbnRlcm5hbHMuc3BsaXQoZW5jb2RlZCk7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBwYXJ0c1xuXG4gICAgICAgIGxldCByZWZzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IFtdO1xuICAgICAgICBjb25zdCBoZWFkID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGhlYWQpIHtcbiAgICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKGhlYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSBwYXJ0WzBdICE9PSAneyc7XG4gICAgICAgICAgICBjb25zdCBlbmRlciA9IHJhdyA/ICd9JyA6ICd9fSc7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBwYXJ0LmluZGV4T2YoZW5kZXIpO1xuICAgICAgICAgICAgaWYgKGVuZCA9PT0gLTEgfHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIG5vbi1tYXRjaGluZyBjbG9zaW5nXG4gICAgICAgICAgICAgICAgcGFydFsxXSA9PT0gJ3snKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgbW9yZSB0aGFuIHR3byB7XG5cbiAgICAgICAgICAgICAgICBwcm9jZXNzZWQucHVzaChgeyR7aW50ZXJuYWxzLmRlY29kZShwYXJ0KX1gKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHZhcmlhYmxlID0gcGFydC5zbGljZShyYXcgPyAwIDogMSwgZW5kKTtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZWQgPSB2YXJpYWJsZVswXSA9PT0gJzonO1xuICAgICAgICAgICAgaWYgKHdyYXBwZWQpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkeW5hbWljID0gdGhpcy5fcmVmKGludGVybmFscy5kZWNvZGUodmFyaWFibGUpLCB7IHJhdywgd3JhcHBlZCB9KTtcbiAgICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKGR5bmFtaWMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkeW5hbWljICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlZnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXN0ID0gcGFydC5zbGljZShlbmQgKyBlbmRlci5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWQucHVzaChpbnRlcm5hbHMuZGVjb2RlKHJlc3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVmcykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZCA9IHByb2Nlc3NlZC5qb2luKCcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlID0gcHJvY2Vzc2VkO1xuICAgIH1cblxuICAgIHN0YXRpYyBkYXRlKGRhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5kYXRlRm9ybWF0W3ByZWZzLmRhdGVGb3JtYXRdLmNhbGwoZGF0ZSk7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zZXR0aW5ncyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5jb21wYWN0KSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlc2MgPSB7IHRlbXBsYXRlOiB0aGlzLnNvdXJjZSB9O1xuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGRlc2Mub3B0aW9ucyA9IHRoaXMuX3NldHRpbmdzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuXG4gICAgc3RhdGljIGJ1aWxkKGRlc2MpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5UZW1wbGF0ZShkZXNjLnRlbXBsYXRlLCBkZXNjLm9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlzRHluYW1pYygpIHtcblxuICAgICAgICByZXR1cm4gISF0aGlzLl90ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSA/ICEhdGVtcGxhdGVbQ29tbW9uLnN5bWJvbHMudGVtcGxhdGVdIDogZmFsc2U7XG4gICAgfVxuXG4gICAgcmVmcygpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3RlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWZzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlZnMucHVzaCguLi5wYXJ0LnJlZnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZnM7XG4gICAgfVxuXG4gICAgcmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCkge1xuXG4gICAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSAmJlxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUubGVuZ3RoID09PSAxKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJ0KHRoaXMuX3RlbXBsYXRlWzBdLCAvKiBjb250ZXh0IC0+IFsqLyB2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCwge30gLypdICovKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCk7XG4gICAgfVxuXG4gICAgX3BhcnQocGFydCwgLi4uYXJncykge1xuXG4gICAgICAgIGlmIChwYXJ0LnJlZikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnQucmVmLnJlc29sdmUoLi4uYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFydC5mb3JtdWxhLmV2YWx1YXRlKGFyZ3MpO1xuICAgIH1cblxuICAgIHJlbmRlcih2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRHluYW1pYygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlZCA9IHRoaXMuX3BhcnQocGFydCwgLyogY29udGV4dCAtPiBbKi8gdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgLypdICovKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmcgPSBpbnRlcm5hbHMuc3RyaW5naWZ5KHJlbmRlcmVkLCB2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnQucmF3IHx8IChvcHRpb25zLmVycm9ycyAmJiBvcHRpb25zLmVycm9ycy5lc2NhcGVIdG1sKSA9PT0gZmFsc2UgPyBzdHJpbmcgOiBFc2NhcGVIdG1sKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goaW50ZXJuYWxzLndyYXAocmVzdWx0LCBwYXJ0LndyYXBwZWQgJiYgcHJlZnMuZXJyb3JzLndyYXAubGFiZWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignJyk7XG4gICAgfVxuXG4gICAgX3JlZihjb250ZW50LCB7IHJhdywgd3JhcHBlZCB9KSB7XG5cbiAgICAgICAgY29uc3QgcmVmcyA9IFtdO1xuICAgICAgICBjb25zdCByZWZlcmVuY2UgPSAodmFyaWFibGUpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgcmVmID0gUmVmLmNyZWF0ZSh2YXJpYWJsZSwgdGhpcy5fc2V0dGluZ3MpO1xuICAgICAgICAgICAgcmVmcy5wdXNoKHJlZik7XG4gICAgICAgICAgICByZXR1cm4gKGNvbnRleHQpID0+IHJlZi5yZXNvbHZlKC4uLmNvbnRleHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZm9ybXVsYSA9IG5ldyBGb3JtdWxhLlBhcnNlcihjb250ZW50LCB7IHJlZmVyZW5jZSwgZnVuY3Rpb25zOiBpbnRlcm5hbHMuZnVuY3Rpb25zLCBjb25zdGFudHM6IGludGVybmFscy5jb25zdGFudHMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgSW52YWxpZCB0ZW1wbGF0ZSB2YXJpYWJsZSBcIiR7Y29udGVudH1cIiBmYWlscyBkdWUgdG86ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JtdWxhLnNpbmdsZSkge1xuICAgICAgICAgICAgaWYgKGZvcm11bGEuc2luZ2xlLnR5cGUgPT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gcmVmc1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZWYsIHJhdywgcmVmcywgd3JhcHBlZDogd3JhcHBlZCB8fCByZWYudHlwZSA9PT0gJ2xvY2FsJyAmJiByZWYua2V5ID09PSAnbGFiZWwnIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuc3RyaW5naWZ5KGZvcm11bGEuc2luZ2xlLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGZvcm11bGEsIHJhdywgcmVmcyB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5UZW1wbGF0ZS5wcm90b3R5cGVbQ29tbW9uLnN5bWJvbHMudGVtcGxhdGVdID0gdHJ1ZTtcbmludGVybmFscy5UZW1wbGF0ZS5wcm90b3R5cGUuaXNJbW11dGFibGUgPSB0cnVlOyAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBIb2VrIGZyb20gZGVlcCBjbG9uaW5nIHNjaGVtYSBvYmplY3RzXG5cblxuaW50ZXJuYWxzLmVuY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIHJldHVybiBzdHJpbmdcbiAgICAgICAgLnJlcGxhY2UoL1xcXFwoXFx7KykvZywgKCQwLCAkMSkgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLm9wZW5zLnNsaWNlKDAsICQxLmxlbmd0aCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcKFxcfSspL2csICgkMCwgJDEpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5jbG9zZXMuc2xpY2UoMCwgJDEubGVuZ3RoKTtcbiAgICAgICAgfSk7XG59O1xuXG5cbmludGVybmFscy5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICByZXR1cm4gc3RyaW5nXG4gICAgICAgIC5yZXBsYWNlKC9cXHUwMDAwL2csICd7JylcbiAgICAgICAgLnJlcGxhY2UoL1xcdTAwMDEvZywgJ30nKTtcbn07XG5cblxuaW50ZXJuYWxzLnNwbGl0ID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBsZXQgY3VycmVudCA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHN0cmluZ1tpXTtcblxuICAgICAgICBpZiAoY2hhciA9PT0gJ3snKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKGkgKyAxIDwgc3RyaW5nLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ1tpICsgMV0gPT09ICd7Jykge1xuXG4gICAgICAgICAgICAgICAgbmV4dCArPSAneyc7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50ICs9IGNoYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKGN1cnJlbnQpO1xuICAgIHJldHVybiBwYXJ0cztcbn07XG5cblxuaW50ZXJuYWxzLndyYXAgPSBmdW5jdGlvbiAodmFsdWUsIGVuZHMpIHtcblxuICAgIGlmICghZW5kcykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGVuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBgJHtlbmRzfSR7dmFsdWV9JHtlbmRzfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2VuZHNbMF19JHt2YWx1ZX0ke2VuZHNbMV19YDtcbn07XG5cblxuaW50ZXJuYWxzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3JpZ2luYWwsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBsZXQgc2tpcFdyYXAgPSBmYWxzZTtcbiAgICBpZiAoUmVmLmlzUmVmKHZhbHVlKSAmJlxuICAgICAgICB2YWx1ZS5yZW5kZXIpIHtcblxuICAgICAgICBza2lwV3JhcCA9IHZhbHVlLmluO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlc29sdmUob3JpZ2luYWwsIHN0YXRlLCBwcmVmcywgbG9jYWwsIHsgaW46IHZhbHVlLmluLCAuLi5vcHRpb25zIH0pO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgdHlwZSA9PT0gJ3N5bWJvbCcpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuVGVtcGxhdGUuZGF0ZSh2YWx1ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHN5bV0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICBwYWlycy5wdXNoKGAke2tleS50b1N0cmluZygpfSAtPiAke3N5bS50b1N0cmluZygpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBwYWlycztcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGxldCBwYXJ0aWFsID0gJyc7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIHBhcnRpYWwgPSBwYXJ0aWFsICsgKHBhcnRpYWwubGVuZ3RoID8gJywgJyA6ICcnKSArIGludGVybmFscy5zdHJpbmdpZnkoaXRlbSwgb3JpZ2luYWwsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChza2lwV3JhcCkge1xuICAgICAgICByZXR1cm4gcGFydGlhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLndyYXAocGFydGlhbCwgcHJlZnMuZXJyb3JzLndyYXAuYXJyYXkpO1xufTtcblxuXG5pbnRlcm5hbHMuY29uc3RhbnRzID0ge1xuXG4gICAgdHJ1ZTogdHJ1ZSxcbiAgICBmYWxzZTogZmFsc2UsXG4gICAgbnVsbDogbnVsbCxcblxuICAgIHNlY29uZDogMTAwMCxcbiAgICBtaW51dGU6IDYwICogMTAwMCxcbiAgICBob3VyOiA2MCAqIDYwICogMTAwMCxcbiAgICBkYXk6IDI0ICogNjAgKiA2MCAqIDEwMDBcbn07XG5cblxuaW50ZXJuYWxzLmZ1bmN0aW9ucyA9IHtcblxuICAgIGlmKGNvbmRpdGlvbiwgdGhlbiwgb3RoZXJ3aXNlKSB7XG5cbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IHRoZW4gOiBvdGhlcndpc2U7XG4gICAgfSxcblxuICAgIG1zZyhjb2RlKSB7XG5cbiAgICAgICAgY29uc3QgW3ZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zXSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcztcbiAgICAgICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBFcnJvcnMudGVtcGxhdGUodmFsdWUsIG1lc3NhZ2VzWzBdLCBjb2RlLCBzdGF0ZSwgcHJlZnMpIHx8IEVycm9ycy50ZW1wbGF0ZSh2YWx1ZSwgbWVzc2FnZXNbMV0sIGNvZGUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBudW1iZXIodmFsdWUpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gMSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/template.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/trace.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/trace.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ \"@hapi/hoek/lib/deepEqual\");\nconst Pinpoint = __webpack_require__(/*! @sideway/pinpoint */ \"@sideway/pinpoint\");\n\nconst Errors = __webpack_require__(/*! ./errors */ \"./node_modules/joi/lib/errors.js\");\n\n\nconst internals = {\n    codes: {\n        error: 1,\n        pass: 2,\n        full: 3\n    },\n    labels: {\n        0: 'never used',\n        1: 'always error',\n        2: 'always pass'\n    }\n};\n\n\nexports.setup = function (root) {\n\n    const trace = function () {\n\n        root._tracer = root._tracer || new internals.Tracer();\n        return root._tracer;\n    };\n\n    root.trace = trace;\n    root[Symbol.for('@hapi/lab/coverage/initialize')] = trace;\n\n    root.untrace = () => {\n\n        root._tracer = null;\n    };\n};\n\n\nexports.location = function (schema) {\n\n    return schema.$_setFlag('_tracerLocation', Pinpoint.location(2));                       // base.tracer(), caller\n};\n\n\ninternals.Tracer = class {\n\n    constructor() {\n\n        this.name = 'Joi';\n        this._schemas = new Map();\n    }\n\n    _register(schema) {\n\n        const existing = this._schemas.get(schema);\n        if (existing) {\n            return existing.store;\n        }\n\n        const store = new internals.Store(schema);\n        const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5);   // internals.tracer(), internals.entry(), exports.entry(), validate(), caller\n        this._schemas.set(schema, { filename, line, store });\n        return store;\n    }\n\n    _combine(merged, sources) {\n\n        for (const { store } of this._schemas.values()) {\n            store._combine(merged, sources);\n        }\n    }\n\n    report(file) {\n\n        const coverage = [];\n\n        // Process each registered schema\n\n        for (const { filename, line, store } of this._schemas.values()) {\n            if (file &&\n                file !== filename) {\n\n                continue;\n            }\n\n            // Process sub schemas of the registered root\n\n            const missing = [];\n            const skipped = [];\n\n            for (const [schema, log] of store._sources.entries()) {\n\n                // Check if sub schema parent skipped\n\n                if (internals.sub(log.paths, skipped)) {\n                    continue;\n                }\n\n                // Check if sub schema reached\n\n                if (!log.entry) {\n                    missing.push({\n                        status: 'never reached',\n                        paths: [...log.paths]\n                    });\n\n                    skipped.push(...log.paths);\n                    continue;\n                }\n\n                // Check values\n\n                for (const type of ['valid', 'invalid']) {\n                    const set = schema[`_${type}s`];\n                    if (!set) {\n                        continue;\n                    }\n\n                    const values = new Set(set._values);\n                    const refs = new Set(set._refs);\n                    for (const { value, ref } of log[type]) {\n                        values.delete(value);\n                        refs.delete(ref);\n                    }\n\n                    if (values.size ||\n                        refs.size) {\n\n                        missing.push({\n                            status: [...values, ...[...refs].map((ref) => ref.display)],\n                            rule: `${type}s`\n                        });\n                    }\n                }\n\n                // Check rules status\n\n                const rules = schema._rules.map((rule) => rule.name);\n                for (const type of ['default', 'failover']) {\n                    if (schema._flags[type] !== undefined) {\n                        rules.push(type);\n                    }\n                }\n\n                for (const name of rules) {\n                    const status = internals.labels[log.rule[name] || 0];\n                    if (status) {\n                        const report = { rule: name, status };\n                        if (log.paths.size) {\n                            report.paths = [...log.paths];\n                        }\n\n                        missing.push(report);\n                    }\n                }\n            }\n\n            if (missing.length) {\n                coverage.push({\n                    filename,\n                    line,\n                    missing,\n                    severity: 'error',\n                    message: `Schema missing tests for ${missing.map(internals.message).join(', ')}`\n                });\n            }\n        }\n\n        return coverage.length ? coverage : null;\n    }\n};\n\n\ninternals.Store = class {\n\n    constructor(schema) {\n\n        this.active = true;\n        this._sources = new Map();          // schema -> { paths, entry, rule, valid, invalid }\n        this._combos = new Map();           // merged -> [sources]\n        this._scan(schema);\n    }\n\n    debug(state, source, name, result) {\n\n        state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });\n    }\n\n    entry(schema, state) {\n\n        internals.debug(state, { type: 'entry' });\n\n        this._record(schema, (log) => {\n\n            log.entry = true;\n        });\n    }\n\n    filter(schema, state, source, value) {\n\n        internals.debug(state, { type: source, ...value });\n\n        this._record(schema, (log) => {\n\n            log[source].add(value);\n        });\n    }\n\n    log(schema, state, source, name, result) {\n\n        internals.debug(state, { type: source, name, result: result === 'full' ? 'pass' : result });\n\n        this._record(schema, (log) => {\n\n            log[source][name] = log[source][name] || 0;\n            log[source][name] |= internals.codes[result];\n        });\n    }\n\n    resolve(state, ref, to) {\n\n        if (!state.mainstay.debug) {\n            return;\n        }\n\n        const log = { type: 'resolve', ref: ref.display, to, path: state.path };\n        state.mainstay.debug.push(log);\n    }\n\n    value(state, by, from, to, name) {\n\n        if (!state.mainstay.debug ||\n            DeepEqual(from, to)) {\n\n            return;\n        }\n\n        const log = { type: 'value', by, from, to, path: state.path };\n        if (name) {\n            log.name = name;\n        }\n\n        state.mainstay.debug.push(log);\n    }\n\n    _record(schema, each) {\n\n        const log = this._sources.get(schema);\n        if (log) {\n            each(log);\n            return;\n        }\n\n        const sources = this._combos.get(schema);\n        for (const source of sources) {\n            this._record(source, each);\n        }\n    }\n\n    _scan(schema, _path) {\n\n        const path = _path || [];\n\n        let log = this._sources.get(schema);\n        if (!log) {\n            log = {\n                paths: new Set(),\n                entry: false,\n                rule: {},\n                valid: new Set(),\n                invalid: new Set()\n            };\n\n            this._sources.set(schema, log);\n        }\n\n        if (path.length) {\n            log.paths.add(path);\n        }\n\n        const each = (sub, source) => {\n\n            const subId = internals.id(sub, source);\n            this._scan(sub, path.concat(subId));\n        };\n\n        schema.$_modify({ each, ref: false });\n    }\n\n    _combine(merged, sources) {\n\n        this._combos.set(merged, sources);\n    }\n};\n\n\ninternals.message = function (item) {\n\n    const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ':' : '') : '';\n    return `${path}${item.rule || ''} (${item.status})`;\n};\n\n\ninternals.id = function (schema, { source, name, path, key }) {\n\n    if (schema._flags.id) {\n        return schema._flags.id;\n    }\n\n    if (key) {\n        return key;\n    }\n\n    name = `@${name}`;\n\n    if (source === 'terms') {\n        return [name, path[Math.min(path.length - 1, 1)]];\n    }\n\n    return name;\n};\n\n\ninternals.sub = function (paths, skipped) {\n\n    for (const path of paths) {\n        for (const skip of skipped) {\n            if (DeepEqual(path.slice(0, skip.length), skip)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n\ninternals.debug = function (state, event) {\n\n    if (state.mainstay.debug) {\n        event.path = state.debug ? [...state.path, state.debug] : state.path;\n        state.mainstay.debug.push(event);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90cmFjZS5qcz8zNGM0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLDBEQUEwQjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQyw0Q0FBbUI7O0FBRTVDLGVBQWUsbUJBQU8sQ0FBQyxrREFBVTs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLHFFQUFxRTtBQUNyRTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxpQkFBaUIseURBQXlEO0FBQ3pGLG1DQUFtQyx3QkFBd0I7QUFDM0Q7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwwQ0FBMEM7QUFDbkcsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUEsMkRBQTJELCtDQUErQztBQUMxRzs7QUFFQTs7QUFFQSxnQ0FBZ0MsZ0JBQWdCOztBQUVoRDs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQSxnQ0FBZ0MseUJBQXlCOztBQUV6RDs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQSxnQ0FBZ0Msa0VBQWtFOztBQUVsRzs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLG1CQUFtQjtBQUM1Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsY0FBYyxLQUFLLEVBQUUsZ0JBQWdCLElBQUksWUFBWTtBQUNyRDs7O0FBR0Esa0NBQWtDLDBCQUEwQjs7QUFFNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLEtBQUs7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHJhY2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuY29uc3QgUGlucG9pbnQgPSByZXF1aXJlKCdAc2lkZXdheS9waW5wb2ludCcpO1xuXG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBjb2Rlczoge1xuICAgICAgICBlcnJvcjogMSxcbiAgICAgICAgcGFzczogMixcbiAgICAgICAgZnVsbDogM1xuICAgIH0sXG4gICAgbGFiZWxzOiB7XG4gICAgICAgIDA6ICduZXZlciB1c2VkJyxcbiAgICAgICAgMTogJ2Fsd2F5cyBlcnJvcicsXG4gICAgICAgIDI6ICdhbHdheXMgcGFzcydcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuc2V0dXAgPSBmdW5jdGlvbiAocm9vdCkge1xuXG4gICAgY29uc3QgdHJhY2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcm9vdC5fdHJhY2VyID0gcm9vdC5fdHJhY2VyIHx8IG5ldyBpbnRlcm5hbHMuVHJhY2VyKCk7XG4gICAgICAgIHJldHVybiByb290Ll90cmFjZXI7XG4gICAgfTtcblxuICAgIHJvb3QudHJhY2UgPSB0cmFjZTtcbiAgICByb290W1N5bWJvbC5mb3IoJ0BoYXBpL2xhYi9jb3ZlcmFnZS9pbml0aWFsaXplJyldID0gdHJhY2U7XG5cbiAgICByb290LnVudHJhY2UgPSAoKSA9PiB7XG5cbiAgICAgICAgcm9vdC5fdHJhY2VyID0gbnVsbDtcbiAgICB9O1xufTtcblxuXG5leHBvcnRzLmxvY2F0aW9uID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgcmV0dXJuIHNjaGVtYS4kX3NldEZsYWcoJ190cmFjZXJMb2NhdGlvbicsIFBpbnBvaW50LmxvY2F0aW9uKDIpKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2UudHJhY2VyKCksIGNhbGxlclxufTtcblxuXG5pbnRlcm5hbHMuVHJhY2VyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ0pvaSc7XG4gICAgICAgIHRoaXMuX3NjaGVtYXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgX3JlZ2lzdGVyKHNjaGVtYSkge1xuXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5fc2NoZW1hcy5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmcuc3RvcmU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdG9yZSA9IG5ldyBpbnRlcm5hbHMuU3RvcmUoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgeyBmaWxlbmFtZSwgbGluZSB9ID0gc2NoZW1hLl9mbGFncy5fdHJhY2VyTG9jYXRpb24gfHwgUGlucG9pbnQubG9jYXRpb24oNSk7ICAgLy8gaW50ZXJuYWxzLnRyYWNlcigpLCBpbnRlcm5hbHMuZW50cnkoKSwgZXhwb3J0cy5lbnRyeSgpLCB2YWxpZGF0ZSgpLCBjYWxsZXJcbiAgICAgICAgdGhpcy5fc2NoZW1hcy5zZXQoc2NoZW1hLCB7IGZpbGVuYW1lLCBsaW5lLCBzdG9yZSB9KTtcbiAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH1cblxuICAgIF9jb21iaW5lKG1lcmdlZCwgc291cmNlcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgeyBzdG9yZSB9IG9mIHRoaXMuX3NjaGVtYXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHN0b3JlLl9jb21iaW5lKG1lcmdlZCwgc291cmNlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXBvcnQoZmlsZSkge1xuXG4gICAgICAgIGNvbnN0IGNvdmVyYWdlID0gW107XG5cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIHJlZ2lzdGVyZWQgc2NoZW1hXG5cbiAgICAgICAgZm9yIChjb25zdCB7IGZpbGVuYW1lLCBsaW5lLCBzdG9yZSB9IG9mIHRoaXMuX3NjaGVtYXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChmaWxlICYmXG4gICAgICAgICAgICAgICAgZmlsZSAhPT0gZmlsZW5hbWUpIHtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIHN1YiBzY2hlbWFzIG9mIHRoZSByZWdpc3RlcmVkIHJvb3RcblxuICAgICAgICAgICAgY29uc3QgbWlzc2luZyA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc2tpcHBlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtzY2hlbWEsIGxvZ10gb2Ygc3RvcmUuX3NvdXJjZXMuZW50cmllcygpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBzdWIgc2NoZW1hIHBhcmVudCBza2lwcGVkXG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLnN1Yihsb2cucGF0aHMsIHNraXBwZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHN1YiBzY2hlbWEgcmVhY2hlZFxuXG4gICAgICAgICAgICAgICAgaWYgKCFsb2cuZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ25ldmVyIHJlYWNoZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHM6IFsuLi5sb2cucGF0aHNdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCguLi5sb2cucGF0aHMpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB2YWx1ZXNcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBbJ3ZhbGlkJywgJ2ludmFsaWQnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXQgPSBzY2hlbWFbYF8ke3R5cGV9c2BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KHNldC5fdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmcyA9IG5ldyBTZXQoc2V0Ll9yZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHZhbHVlLCByZWYgfSBvZiBsb2dbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcy5kZWxldGUocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMuc2l6ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcy5zaXplKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBbLi4udmFsdWVzLCAuLi5bLi4ucmVmc10ubWFwKChyZWYpID0+IHJlZi5kaXNwbGF5KV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYCR7dHlwZX1zYFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBydWxlcyBzdGF0dXNcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gc2NoZW1hLl9ydWxlcy5tYXAoKHJ1bGUpID0+IHJ1bGUubmFtZSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIFsnZGVmYXVsdCcsICdmYWlsb3ZlciddKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgcnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gaW50ZXJuYWxzLmxhYmVsc1tsb2cucnVsZVtuYW1lXSB8fCAwXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0geyBydWxlOiBuYW1lLCBzdGF0dXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cucGF0aHMuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRocyA9IFsuLi5sb2cucGF0aHNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2gocmVwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY292ZXJhZ2UucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLFxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFNjaGVtYSBtaXNzaW5nIHRlc3RzIGZvciAke21pc3NpbmcubWFwKGludGVybmFscy5tZXNzYWdlKS5qb2luKCcsICcpfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3ZlcmFnZS5sZW5ndGggPyBjb3ZlcmFnZSA6IG51bGw7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuU3RvcmUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcblxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgTWFwKCk7ICAgICAgICAgIC8vIHNjaGVtYSAtPiB7IHBhdGhzLCBlbnRyeSwgcnVsZSwgdmFsaWQsIGludmFsaWQgfVxuICAgICAgICB0aGlzLl9jb21ib3MgPSBuZXcgTWFwKCk7ICAgICAgICAgICAvLyBtZXJnZWQgLT4gW3NvdXJjZXNdXG4gICAgICAgIHRoaXMuX3NjYW4oc2NoZW1hKTtcbiAgICB9XG5cbiAgICBkZWJ1ZyhzdGF0ZSwgc291cmNlLCBuYW1lLCByZXN1bHQpIHtcblxuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1ZyAmJiBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKHsgdHlwZTogc291cmNlLCBuYW1lLCByZXN1bHQsIHBhdGg6IHN0YXRlLnBhdGggfSk7XG4gICAgfVxuXG4gICAgZW50cnkoc2NoZW1hLCBzdGF0ZSkge1xuXG4gICAgICAgIGludGVybmFscy5kZWJ1ZyhzdGF0ZSwgeyB0eXBlOiAnZW50cnknIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlY29yZChzY2hlbWEsIChsb2cpID0+IHtcblxuICAgICAgICAgICAgbG9nLmVudHJ5ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmlsdGVyKHNjaGVtYSwgc3RhdGUsIHNvdXJjZSwgdmFsdWUpIHtcblxuICAgICAgICBpbnRlcm5hbHMuZGVidWcoc3RhdGUsIHsgdHlwZTogc291cmNlLCAuLi52YWx1ZSB9KTtcblxuICAgICAgICB0aGlzLl9yZWNvcmQoc2NoZW1hLCAobG9nKSA9PiB7XG5cbiAgICAgICAgICAgIGxvZ1tzb3VyY2VdLmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxvZyhzY2hlbWEsIHN0YXRlLCBzb3VyY2UsIG5hbWUsIHJlc3VsdCkge1xuXG4gICAgICAgIGludGVybmFscy5kZWJ1ZyhzdGF0ZSwgeyB0eXBlOiBzb3VyY2UsIG5hbWUsIHJlc3VsdDogcmVzdWx0ID09PSAnZnVsbCcgPyAncGFzcycgOiByZXN1bHQgfSk7XG5cbiAgICAgICAgdGhpcy5fcmVjb3JkKHNjaGVtYSwgKGxvZykgPT4ge1xuXG4gICAgICAgICAgICBsb2dbc291cmNlXVtuYW1lXSA9IGxvZ1tzb3VyY2VdW25hbWVdIHx8IDA7XG4gICAgICAgICAgICBsb2dbc291cmNlXVtuYW1lXSB8PSBpbnRlcm5hbHMuY29kZXNbcmVzdWx0XTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZShzdGF0ZSwgcmVmLCB0bykge1xuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvZyA9IHsgdHlwZTogJ3Jlc29sdmUnLCByZWY6IHJlZi5kaXNwbGF5LCB0bywgcGF0aDogc3RhdGUucGF0aCB9O1xuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKGxvZyk7XG4gICAgfVxuXG4gICAgdmFsdWUoc3RhdGUsIGJ5LCBmcm9tLCB0bywgbmFtZSkge1xuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkuZGVidWcgfHxcbiAgICAgICAgICAgIERlZXBFcXVhbChmcm9tLCB0bykpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9nID0geyB0eXBlOiAndmFsdWUnLCBieSwgZnJvbSwgdG8sIHBhdGg6IHN0YXRlLnBhdGggfTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGxvZy5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmRlYnVnLnB1c2gobG9nKTtcbiAgICB9XG5cbiAgICBfcmVjb3JkKHNjaGVtYSwgZWFjaCkge1xuXG4gICAgICAgIGNvbnN0IGxvZyA9IHRoaXMuX3NvdXJjZXMuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgICAgIGVhY2gobG9nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSB0aGlzLl9jb21ib3MuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZChzb3VyY2UsIGVhY2gpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NjYW4oc2NoZW1hLCBfcGF0aCkge1xuXG4gICAgICAgIGNvbnN0IHBhdGggPSBfcGF0aCB8fCBbXTtcblxuICAgICAgICBsZXQgbG9nID0gdGhpcy5fc291cmNlcy5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKCFsb2cpIHtcbiAgICAgICAgICAgIGxvZyA9IHtcbiAgICAgICAgICAgICAgICBwYXRoczogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIGVudHJ5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBydWxlOiB7fSxcbiAgICAgICAgICAgICAgICB2YWxpZDogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIGludmFsaWQ6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fc291cmNlcy5zZXQoc2NoZW1hLCBsb2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2cucGF0aHMuYWRkKHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChzdWIsIHNvdXJjZSkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBzdWJJZCA9IGludGVybmFscy5pZChzdWIsIHNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLl9zY2FuKHN1YiwgcGF0aC5jb25jYXQoc3ViSWQpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzY2hlbWEuJF9tb2RpZnkoeyBlYWNoLCByZWY6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIF9jb21iaW5lKG1lcmdlZCwgc291cmNlcykge1xuXG4gICAgICAgIHRoaXMuX2NvbWJvcy5zZXQobWVyZ2VkLCBzb3VyY2VzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5tZXNzYWdlID0gZnVuY3Rpb24gKGl0ZW0pIHtcblxuICAgIGNvbnN0IHBhdGggPSBpdGVtLnBhdGhzID8gRXJyb3JzLnBhdGgoaXRlbS5wYXRoc1swXSkgKyAoaXRlbS5ydWxlID8gJzonIDogJycpIDogJyc7XG4gICAgcmV0dXJuIGAke3BhdGh9JHtpdGVtLnJ1bGUgfHwgJyd9ICgke2l0ZW0uc3RhdHVzfSlgO1xufTtcblxuXG5pbnRlcm5hbHMuaWQgPSBmdW5jdGlvbiAoc2NoZW1hLCB7IHNvdXJjZSwgbmFtZSwgcGF0aCwga2V5IH0pIHtcblxuICAgIGlmIChzY2hlbWEuX2ZsYWdzLmlkKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuX2ZsYWdzLmlkO1xuICAgIH1cblxuICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICBuYW1lID0gYEAke25hbWV9YDtcblxuICAgIGlmIChzb3VyY2UgPT09ICd0ZXJtcycpIHtcbiAgICAgICAgcmV0dXJuIFtuYW1lLCBwYXRoW01hdGgubWluKHBhdGgubGVuZ3RoIC0gMSwgMSldXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbn07XG5cblxuaW50ZXJuYWxzLnN1YiA9IGZ1bmN0aW9uIChwYXRocywgc2tpcHBlZCkge1xuXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2tpcCBvZiBza2lwcGVkKSB7XG4gICAgICAgICAgICBpZiAoRGVlcEVxdWFsKHBhdGguc2xpY2UoMCwgc2tpcC5sZW5ndGgpLCBza2lwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5pbnRlcm5hbHMuZGVidWcgPSBmdW5jdGlvbiAoc3RhdGUsIGV2ZW50KSB7XG5cbiAgICBpZiAoc3RhdGUubWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgZXZlbnQucGF0aCA9IHN0YXRlLmRlYnVnID8gWy4uLnN0YXRlLnBhdGgsIHN0YXRlLmRlYnVnXSA6IHN0YXRlLnBhdGg7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmRlYnVnLnB1c2goZXZlbnQpO1xuICAgIH1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/trace.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/types/alternatives.js":
/*!****************************************************!*\
  !*** ./node_modules/joi/lib/types/alternatives.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst Merge = __webpack_require__(/*! @hapi/hoek/lib/merge */ \"@hapi/hoek/lib/merge\");\n\nconst Any = __webpack_require__(/*! ./any */ \"./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ../compile */ \"./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"./node_modules/joi/lib/errors.js\");\nconst Ref = __webpack_require__(/*! ../ref */ \"./node_modules/joi/lib/ref.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'alternatives',\n\n    flags: {\n\n        match: { default: 'any' }                 // 'any', 'one', 'all'\n    },\n\n    terms: {\n\n        matches: { init: [], register: Ref.toSibling }\n    },\n\n    args(schema, ...schemas) {\n\n        if (schemas.length === 1) {\n            if (Array.isArray(schemas[0])) {\n                return schema.try(...schemas[0]);\n            }\n        }\n\n        return schema.try(...schemas);\n    },\n\n    validate(value, helpers) {\n\n        const { schema, error, state, prefs } = helpers;\n\n        // Match all or one\n\n        if (schema._flags.match) {\n            const matched = [];\n\n            for (let i = 0; i < schema.$_terms.matches.length; ++i) {\n                const item = schema.$_terms.matches[i];\n                const localState = state.nest(item.schema, `match.${i}`);\n                localState.snapshot();\n\n                const result = item.schema.$_validate(value, localState, prefs);\n                if (!result.errors) {\n                    matched.push(result.value);\n                }\n                else {\n                    localState.restore();\n                }\n            }\n\n            if (matched.length === 0) {\n                return { errors: error('alternatives.any') };\n            }\n\n            if (schema._flags.match === 'one') {\n                return matched.length === 1 ? { value: matched[0] } : { errors: error('alternatives.one') };\n            }\n\n            if (matched.length !== schema.$_terms.matches.length) {\n                return { errors: error('alternatives.all') };\n            }\n\n            const allobj = schema.$_terms.matches.reduce((acc, v) => acc && v.schema.type === 'object', true);\n            return allobj ? { value: matched.reduce((acc, v) => Merge(acc, v, { mergeArrays: false })) } : { value: matched[matched.length - 1] };\n        }\n\n        // Match any\n\n        const errors = [];\n        for (let i = 0; i < schema.$_terms.matches.length; ++i) {\n            const item = schema.$_terms.matches[i];\n\n            // Try\n\n            if (item.schema) {\n                const localState = state.nest(item.schema, `match.${i}`);\n                localState.snapshot();\n\n                const result = item.schema.$_validate(value, localState, prefs);\n                if (!result.errors) {\n                    return result;\n                }\n\n                localState.restore();\n                errors.push({ schema: item.schema, reports: result.errors });\n                continue;\n            }\n\n            // Conditional\n\n            const input = item.ref ? item.ref.resolve(value, state, prefs) : value;\n            const tests = item.is ? [item] : item.switch;\n\n            for (let j = 0; j < tests.length; ++j) {\n                const test = tests[j];\n                const { is, then, otherwise } = test;\n\n                const id = `match.${i}${item.switch ? '.' + j : ''}`;\n                if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {\n                    if (otherwise) {\n                        return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);\n                    }\n                }\n                else if (then) {\n                    return then.$_validate(value, state.nest(then, `${id}.then`), prefs);\n                }\n            }\n        }\n\n        return internals.errors(errors, helpers);\n    },\n\n    rules: {\n\n        conditional: {\n            method(condition, options) {\n\n                Assert(!this._flags._endedSwitch, 'Unreachable condition');\n                Assert(!this._flags.match, 'Cannot combine match mode', this._flags.match, 'with conditional rule');\n                Assert(options.break === undefined, 'Cannot use break option with alternatives conditional');\n\n                const obj = this.clone();\n\n                const match = Compile.when(obj, condition, options);\n                const conditions = match.is ? [match] : match.switch;\n                for (const item of conditions) {\n                    if (item.then &&\n                        item.otherwise) {\n\n                        obj.$_setFlag('_endedSwitch', true, { clone: false });\n                        break;\n                    }\n                }\n\n                obj.$_terms.matches.push(match);\n                return obj.$_mutateRebuild();\n            }\n        },\n\n        match: {\n            method(mode) {\n\n                Assert(['any', 'one', 'all'].includes(mode), 'Invalid alternatives match mode', mode);\n\n                if (mode !== 'any') {\n                    for (const match of this.$_terms.matches) {\n                        Assert(match.schema, 'Cannot combine match mode', mode, 'with conditional rules');\n                    }\n                }\n\n                return this.$_setFlag('match', mode);\n            }\n        },\n\n        try: {\n            method(...schemas) {\n\n                Assert(schemas.length, 'Missing alternative schemas');\n                Common.verifyFlat(schemas, 'try');\n\n                Assert(!this._flags._endedSwitch, 'Unreachable condition');\n\n                const obj = this.clone();\n                for (const schema of schemas) {\n                    obj.$_terms.matches.push({ schema: obj.$_compile(schema) });\n                }\n\n                return obj.$_mutateRebuild();\n            }\n        }\n    },\n\n    overrides: {\n\n        label(name) {\n\n            const obj = this.$_parent('label', name);\n            const each = (item, source) => (source.path[0] !== 'is' ? item.label(name) : undefined);\n            return obj.$_modify({ each, ref: false });\n        }\n    },\n\n    rebuild(schema) {\n\n        // Flag when an alternative type is an array\n\n        const each = (item) => {\n\n            if (Common.isSchema(item) &&\n                item.type === 'array') {\n\n                schema.$_setFlag('_arrayItems', true, { clone: false });\n            }\n        };\n\n        schema.$_modify({ each });\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.matches) {\n                for (const match of desc.matches) {\n                    const { schema, ref, is, not, then, otherwise } = match;\n                    if (schema) {\n                        obj = obj.try(schema);\n                    }\n                    else if (ref) {\n                        obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });\n                    }\n                    else {\n                        obj = obj.conditional(is, { then, otherwise });\n                    }\n                }\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'alternatives.all': '{{#label}} does not match all of the required types',\n        'alternatives.any': '{{#label}} does not match any of the allowed types',\n        'alternatives.match': '{{#label}} does not match any of the allowed types',\n        'alternatives.one': '{{#label}} matches more than one allowed type',\n        'alternatives.types': '{{#label}} must be one of {{#types}}'\n    }\n});\n\n\n// Helpers\n\ninternals.errors = function (failures, { error, state }) {\n\n    // Nothing matched due to type criteria rules\n\n    if (!failures.length) {\n        return { errors: error('alternatives.any') };\n    }\n\n    // Single error\n\n    if (failures.length === 1) {\n        return { errors: failures[0].reports };\n    }\n\n    // Analyze reasons\n\n    const valids = new Set();\n    const complex = [];\n\n    for (const { reports, schema } of failures) {\n\n        // Multiple errors (!abortEarly)\n\n        if (reports.length > 1) {\n            return internals.unmatched(failures, error);\n        }\n\n        // Custom error\n\n        const report = reports[0];\n        if (report instanceof Errors.Report === false) {\n            return internals.unmatched(failures, error);\n        }\n\n        // Internal object or array error\n\n        if (report.state.path.length !== state.path.length) {\n            complex.push({ type: schema.type, report });\n            continue;\n        }\n\n        // Valids\n\n        if (report.code === 'any.only') {\n            for (const valid of report.local.valids) {\n                valids.add(valid);\n            }\n\n            continue;\n        }\n\n        // Base type\n\n        const [type, code] = report.code.split('.');\n        if (code !== 'base') {\n            complex.push({ type: schema.type, report });\n            continue;\n        }\n\n        valids.add(type);\n    }\n\n    // All errors are base types or valids\n\n    if (!complex.length) {\n        return { errors: error('alternatives.types', { types: [...valids] }) };\n    }\n\n    // Single complex error\n\n    if (complex.length === 1) {\n        return { errors: complex[0].report };\n    }\n\n    return internals.unmatched(failures, error);\n};\n\n\ninternals.unmatched = function (failures, error) {\n\n    const errors = [];\n    for (const failure of failures) {\n        errors.push(...failure.reports);\n    }\n\n    return { errors: error('alternatives.match', Errors.details(errors, { override: false })) };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hbHRlcm5hdGl2ZXMuanM/YTU5OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0RBQXVCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyxrREFBc0I7O0FBRTVDLFlBQVksbUJBQU8sQ0FBQyxrREFBTztBQUMzQixlQUFlLG1CQUFPLENBQUMsbURBQVc7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMscURBQVk7QUFDcEMsZUFBZSxtQkFBTyxDQUFDLG1EQUFXO0FBQ2xDLFlBQVksbUJBQU8sQ0FBQyw2Q0FBUTs7O0FBRzVCOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLEtBQUs7O0FBRUw7O0FBRUEsa0JBQWtCO0FBQ2xCLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsZUFBZSw4QkFBOEI7O0FBRTdDOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLG1DQUFtQztBQUM5RDtBQUNBLG9FQUFvRSxFQUFFO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQSwrQ0FBK0Msb0JBQW9CLElBQUk7QUFDdkU7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQSw2QkFBNkIsa0RBQWtELHFCQUFxQixJQUFJLElBQUk7QUFDNUc7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsbUNBQW1DO0FBQzFEOztBQUVBOztBQUVBO0FBQ0Esb0VBQW9FLEVBQUU7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsOENBQThDO0FBQzNFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0EsdUJBQXVCLHNCQUFzQjs7QUFFN0Msb0NBQW9DLEVBQUUsRUFBRSwyQkFBMkI7QUFDbkUseURBQXlELEdBQUc7QUFDNUQ7QUFDQSxvRkFBb0YsR0FBRztBQUN2RjtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsR0FBRztBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZELGVBQWU7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLGdDQUFnQztBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVEQUF1RCxlQUFlO0FBQ3RFO0FBQ0E7O0FBRUEseUJBQXlCLE9BQU87QUFDaEMsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLHdDQUF3QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpREFBaUQ7QUFDckc7QUFDQTtBQUNBLG1EQUFtRCxrQkFBa0I7QUFDckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7QUFDdkMsaUNBQWlDLFFBQVE7QUFDekMsK0JBQStCLFFBQVE7QUFDdkMsaUNBQWlDLFFBQVEsa0JBQWtCLFFBQVE7QUFDbkU7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQSx3Q0FBd0MsZUFBZTs7QUFFdkQ7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0Isa0JBQWtCOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0Isc0NBQXNDLHFCQUFxQjtBQUMzRTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLDZEQUE2RCxrQkFBa0I7QUFDM0YiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hbHRlcm5hdGl2ZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgTWVyZ2UgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9tZXJnZScpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2FsdGVybmF0aXZlcycsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIG1hdGNoOiB7IGRlZmF1bHQ6ICdhbnknIH0gICAgICAgICAgICAgICAgIC8vICdhbnknLCAnb25lJywgJ2FsbCdcbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBtYXRjaGVzOiB7IGluaXQ6IFtdLCByZWdpc3RlcjogUmVmLnRvU2libGluZyB9XG4gICAgfSxcblxuICAgIGFyZ3Moc2NoZW1hLCAuLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgaWYgKHNjaGVtYXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWFzWzBdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2hlbWEudHJ5KC4uLnNjaGVtYXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYS50cnkoLi4uc2NoZW1hcyk7XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGVycm9yLCBzdGF0ZSwgcHJlZnMgfSA9IGhlbHBlcnM7XG5cbiAgICAgICAgLy8gTWF0Y2ggYWxsIG9yIG9uZVxuXG4gICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hLiRfdGVybXMubWF0Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBzY2hlbWEuJF90ZXJtcy5tYXRjaGVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5uZXN0KGl0ZW0uc2NoZW1hLCBgbWF0Y2guJHtpfWApO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuc25hcHNob3QoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZW0uc2NoZW1hLiRfdmFsaWRhdGUodmFsdWUsIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5hbnknKSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFncy5tYXRjaCA9PT0gJ29uZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlZC5sZW5ndGggPT09IDEgPyB7IHZhbHVlOiBtYXRjaGVkWzBdIH0gOiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5vbmUnKSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWF0Y2hlZC5sZW5ndGggIT09IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcignYWx0ZXJuYXRpdmVzLmFsbCcpIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGFsbG9iaiA9IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXMucmVkdWNlKChhY2MsIHYpID0+IGFjYyAmJiB2LnNjaGVtYS50eXBlID09PSAnb2JqZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWxsb2JqID8geyB2YWx1ZTogbWF0Y2hlZC5yZWR1Y2UoKGFjYywgdikgPT4gTWVyZ2UoYWNjLCB2LCB7IG1lcmdlQXJyYXlzOiBmYWxzZSB9KSkgfSA6IHsgdmFsdWU6IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWF0Y2ggYW55XG5cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hLiRfdGVybXMubWF0Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXNbaV07XG5cbiAgICAgICAgICAgIC8vIFRyeVxuXG4gICAgICAgICAgICBpZiAoaXRlbS5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubmVzdChpdGVtLnNjaGVtYSwgYG1hdGNoLiR7aX1gKTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnNuYXBzaG90KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVtLnNjaGVtYS4kX3ZhbGlkYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBzY2hlbWE6IGl0ZW0uc2NoZW1hLCByZXBvcnRzOiByZXN1bHQuZXJyb3JzIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb25kaXRpb25hbFxuXG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGl0ZW0ucmVmID8gaXRlbS5yZWYucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKSA6IHZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdGVzdHMgPSBpdGVtLmlzID8gW2l0ZW1dIDogaXRlbS5zd2l0Y2g7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGVzdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ID0gdGVzdHNbal07XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpcywgdGhlbiwgb3RoZXJ3aXNlIH0gPSB0ZXN0O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBgbWF0Y2guJHtpfSR7aXRlbS5zd2l0Y2ggPyAnLicgKyBqIDogJyd9YDtcbiAgICAgICAgICAgICAgICBpZiAoIWlzLiRfbWF0Y2goaW5wdXQsIHN0YXRlLm5lc3QoaXMsIGAke2lkfS5pc2ApLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyd2lzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyd2lzZS4kX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZS5uZXN0KG90aGVyd2lzZSwgYCR7aWR9Lm90aGVyd2lzZWApLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhlbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhlbi4kX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZS5uZXN0KHRoZW4sIGAke2lkfS50aGVuYCksIHByZWZzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmVycm9ycyhlcnJvcnMsIGhlbHBlcnMpO1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGNvbmRpdGlvbmFsOiB7XG4gICAgICAgICAgICBtZXRob2QoY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2ZsYWdzLl9lbmRlZFN3aXRjaCwgJ1VucmVhY2hhYmxlIGNvbmRpdGlvbicpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghdGhpcy5fZmxhZ3MubWF0Y2gsICdDYW5ub3QgY29tYmluZSBtYXRjaCBtb2RlJywgdGhpcy5fZmxhZ3MubWF0Y2gsICd3aXRoIGNvbmRpdGlvbmFsIHJ1bGUnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQob3B0aW9ucy5icmVhayA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHVzZSBicmVhayBvcHRpb24gd2l0aCBhbHRlcm5hdGl2ZXMgY29uZGl0aW9uYWwnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gQ29tcGlsZS53aGVuKG9iaiwgY29uZGl0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kaXRpb25zID0gbWF0Y2guaXMgPyBbbWF0Y2hdIDogbWF0Y2guc3dpdGNoO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb25kaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRoZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3RoZXJ3aXNlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai4kX3NldEZsYWcoJ19lbmRlZFN3aXRjaCcsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5tYXRjaGVzLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF0Y2g6IHtcbiAgICAgICAgICAgIG1ldGhvZChtb2RlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWydhbnknLCAnb25lJywgJ2FsbCddLmluY2x1ZGVzKG1vZGUpLCAnSW52YWxpZCBhbHRlcm5hdGl2ZXMgbWF0Y2ggbW9kZScsIG1vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgIT09ICdhbnknKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgdGhpcy4kX3Rlcm1zLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydChtYXRjaC5zY2hlbWEsICdDYW5ub3QgY29tYmluZSBtYXRjaCBtb2RlJywgbW9kZSwgJ3dpdGggY29uZGl0aW9uYWwgcnVsZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnbWF0Y2gnLCBtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0cnk6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoc2NoZW1hcy5sZW5ndGgsICdNaXNzaW5nIGFsdGVybmF0aXZlIHNjaGVtYXMnKTtcbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChzY2hlbWFzLCAndHJ5Jyk7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2ZsYWdzLl9lbmRlZFN3aXRjaCwgJ1VucmVhY2hhYmxlIGNvbmRpdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHNjaGVtYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMubWF0Y2hlcy5wdXNoKHsgc2NoZW1hOiBvYmouJF9jb21waWxlKHNjaGVtYSkgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvdmVycmlkZXM6IHtcblxuICAgICAgICBsYWJlbChuYW1lKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9wYXJlbnQoJ2xhYmVsJywgbmFtZSk7XG4gICAgICAgICAgICBjb25zdCBlYWNoID0gKGl0ZW0sIHNvdXJjZSkgPT4gKHNvdXJjZS5wYXRoWzBdICE9PSAnaXMnID8gaXRlbS5sYWJlbChuYW1lKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICByZXR1cm4gb2JqLiRfbW9kaWZ5KHsgZWFjaCwgcmVmOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWJ1aWxkKHNjaGVtYSkge1xuXG4gICAgICAgIC8vIEZsYWcgd2hlbiBhbiBhbHRlcm5hdGl2ZSB0eXBlIGlzIGFuIGFycmF5XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChpdGVtKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEoaXRlbSkgJiZcbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPT09ICdhcnJheScpIHtcblxuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3NldEZsYWcoJ19hcnJheUl0ZW1zJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NoZW1hLiRfbW9kaWZ5KHsgZWFjaCB9KTtcbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgZGVzYy5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hLCByZWYsIGlzLCBub3QsIHRoZW4sIG90aGVyd2lzZSB9ID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai50cnkoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25kaXRpb25hbChyZWYsIHsgaXMsIHRoZW4sIG5vdCwgb3RoZXJ3aXNlLCBzd2l0Y2g6IG1hdGNoLnN3aXRjaCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25kaXRpb25hbChpcywgeyB0aGVuLCBvdGhlcndpc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5hbGwnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBtYXRjaCBhbGwgb2YgdGhlIHJlcXVpcmVkIHR5cGVzJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5hbnknOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdHlwZXMnLFxuICAgICAgICAnYWx0ZXJuYXRpdmVzLm1hdGNoJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBhbGxvd2VkIHR5cGVzJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5vbmUnOiAne3sjbGFiZWx9fSBtYXRjaGVzIG1vcmUgdGhhbiBvbmUgYWxsb3dlZCB0eXBlJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy50eXBlcyc6ICd7eyNsYWJlbH19IG11c3QgYmUgb25lIG9mIHt7I3R5cGVzfX0nXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuZXJyb3JzID0gZnVuY3Rpb24gKGZhaWx1cmVzLCB7IGVycm9yLCBzdGF0ZSB9KSB7XG5cbiAgICAvLyBOb3RoaW5nIG1hdGNoZWQgZHVlIHRvIHR5cGUgY3JpdGVyaWEgcnVsZXNcblxuICAgIGlmICghZmFpbHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5hbnknKSB9O1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSBlcnJvclxuXG4gICAgaWYgKGZhaWx1cmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGZhaWx1cmVzWzBdLnJlcG9ydHMgfTtcbiAgICB9XG5cbiAgICAvLyBBbmFseXplIHJlYXNvbnNcblxuICAgIGNvbnN0IHZhbGlkcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBjb21wbGV4ID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHsgcmVwb3J0cywgc2NoZW1hIH0gb2YgZmFpbHVyZXMpIHtcblxuICAgICAgICAvLyBNdWx0aXBsZSBlcnJvcnMgKCFhYm9ydEVhcmx5KVxuXG4gICAgICAgIGlmIChyZXBvcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDdXN0b20gZXJyb3JcblxuICAgICAgICBjb25zdCByZXBvcnQgPSByZXBvcnRzWzBdO1xuICAgICAgICBpZiAocmVwb3J0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRlcm5hbCBvYmplY3Qgb3IgYXJyYXkgZXJyb3JcblxuICAgICAgICBpZiAocmVwb3J0LnN0YXRlLnBhdGgubGVuZ3RoICE9PSBzdGF0ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29tcGxleC5wdXNoKHsgdHlwZTogc2NoZW1hLnR5cGUsIHJlcG9ydCB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRzXG5cbiAgICAgICAgaWYgKHJlcG9ydC5jb2RlID09PSAnYW55Lm9ubHknKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbGlkIG9mIHJlcG9ydC5sb2NhbC52YWxpZHMpIHtcbiAgICAgICAgICAgICAgICB2YWxpZHMuYWRkKHZhbGlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYXNlIHR5cGVcblxuICAgICAgICBjb25zdCBbdHlwZSwgY29kZV0gPSByZXBvcnQuY29kZS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoY29kZSAhPT0gJ2Jhc2UnKSB7XG4gICAgICAgICAgICBjb21wbGV4LnB1c2goeyB0eXBlOiBzY2hlbWEudHlwZSwgcmVwb3J0IH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YWxpZHMuYWRkKHR5cGUpO1xuICAgIH1cblxuICAgIC8vIEFsbCBlcnJvcnMgYXJlIGJhc2UgdHlwZXMgb3IgdmFsaWRzXG5cbiAgICBpZiAoIWNvbXBsZXgubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy50eXBlcycsIHsgdHlwZXM6IFsuLi52YWxpZHNdIH0pIH07XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIGNvbXBsZXggZXJyb3JcblxuICAgIGlmIChjb21wbGV4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGNvbXBsZXhbMF0ucmVwb3J0IH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy51bm1hdGNoZWQoZmFpbHVyZXMsIGVycm9yKTtcbn07XG5cblxuaW50ZXJuYWxzLnVubWF0Y2hlZCA9IGZ1bmN0aW9uIChmYWlsdXJlcywgZXJyb3IpIHtcblxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBmYWlsdXJlcykge1xuICAgICAgICBlcnJvcnMucHVzaCguLi5mYWlsdXJlLnJlcG9ydHMpO1xuICAgIH1cblxuICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5tYXRjaCcsIEVycm9ycy5kZXRhaWxzKGVycm9ycywgeyBvdmVycmlkZTogZmFsc2UgfSkpIH07XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/types/alternatives.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/types/any.js":
/*!*******************************************!*\
  !*** ./node_modules/joi/lib/types/any.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\n\nconst Base = __webpack_require__(/*! ../base */ \"./node_modules/joi/lib/base.js\");\nconst Common = __webpack_require__(/*! ../common */ \"./node_modules/joi/lib/common.js\");\nconst Messages = __webpack_require__(/*! ../messages */ \"./node_modules/joi/lib/messages.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = Base.extend({\n\n    type: 'any',\n\n    flags: {\n\n        only: { default: false }\n    },\n\n    terms: {\n\n        alterations: { init: null },\n        examples: { init: null },\n        externals: { init: null },\n        metas: { init: [] },\n        notes: { init: [] },\n        shared: { init: null },\n        tags: { init: [] },\n        whens: { init: null }\n    },\n\n    rules: {\n\n        custom: {\n            method(method, description) {\n\n                Assert(typeof method === 'function', 'Method must be a function');\n                Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');\n\n                return this.$_addRule({ name: 'custom', args: { method, description } });\n            },\n            validate(value, helpers, { method }) {\n\n                try {\n                    return method(value, helpers);\n                }\n                catch (err) {\n                    return helpers.error('any.custom', { error: err });\n                }\n            },\n            args: ['method', 'description'],\n            multi: true\n        },\n\n        messages: {\n            method(messages) {\n\n                return this.prefs({ messages });\n            }\n        },\n\n        shared: {\n            method(schema) {\n\n                Assert(Common.isSchema(schema) && schema._flags.id, 'Schema must be a schema with an id');\n\n                const obj = this.clone();\n                obj.$_terms.shared = obj.$_terms.shared || [];\n                obj.$_terms.shared.push(schema);\n                obj.$_mutateRegister(schema);\n                return obj;\n            }\n        },\n\n        warning: {\n            method(code, local) {\n\n                Assert(code && typeof code === 'string', 'Invalid warning code');\n\n                return this.$_addRule({ name: 'warning', args: { code, local }, warn: true });\n            },\n            validate(value, helpers, { code, local }) {\n\n                return helpers.error(code, local);\n            },\n            args: ['code', 'local'],\n            multi: true\n        }\n    },\n\n    modifiers: {\n\n        keep(rule, enabled = true) {\n\n            rule.keep = enabled;\n        },\n\n        message(rule, message) {\n\n            rule.message = Messages.compile(message);\n        },\n\n        warn(rule, enabled = true) {\n\n            rule.warn = enabled;\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            for (const key in desc) {\n                const values = desc[key];\n\n                if (['examples', 'externals', 'metas', 'notes', 'tags'].includes(key)) {\n                    for (const value of values) {\n                        obj = obj[key.slice(0, -1)](value);\n                    }\n\n                    continue;\n                }\n\n                if (key === 'alterations') {\n                    const alter = {};\n                    for (const { target, adjuster } of values) {\n                        alter[target] = adjuster;\n                    }\n\n                    obj = obj.alter(alter);\n                    continue;\n                }\n\n                if (key === 'whens') {\n                    for (const value of values) {\n                        const { ref, is, not, then, otherwise, concat } = value;\n                        if (concat) {\n                            obj = obj.concat(concat);\n                        }\n                        else if (ref) {\n                            obj = obj.when(ref, { is, not, then, otherwise, switch: value.switch, break: value.break });\n                        }\n                        else {\n                            obj = obj.when(is, { then, otherwise, break: value.break });\n                        }\n                    }\n\n                    continue;\n                }\n\n                if (key === 'shared') {\n                    for (const value of values) {\n                        obj = obj.shared(value);\n                    }\n                }\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'any.custom': '{{#label}} failed custom validation because {{#error.message}}',\n        'any.default': '{{#label}} threw an error when running default method',\n        'any.failover': '{{#label}} threw an error when running failover method',\n        'any.invalid': '{{#label}} contains an invalid value',\n        'any.only': '{{#label}} must be {if(#valids.length == 1, \"\", \"one of \")}{{#valids}}',\n        'any.ref': '{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}',\n        'any.required': '{{#label}} is required',\n        'any.unknown': '{{#label}} is not allowed'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hbnkuanM/ZWNkMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0RBQXVCOztBQUU5QyxhQUFhLG1CQUFPLENBQUMsK0NBQVM7QUFDOUIsZUFBZSxtQkFBTyxDQUFDLG1EQUFXO0FBQ2xDLGlCQUFpQixtQkFBTyxDQUFDLHVEQUFhOzs7QUFHdEM7OztBQUdBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7QUFDZixLQUFLOztBQUVMOztBQUVBLHNCQUFzQixhQUFhO0FBQ25DLG1CQUFtQixhQUFhO0FBQ2hDLG9CQUFvQixhQUFhO0FBQ2pDLGdCQUFnQixXQUFXO0FBQzNCLGdCQUFnQixXQUFXO0FBQzNCLGlCQUFpQixhQUFhO0FBQzlCLGVBQWUsV0FBVztBQUMxQixnQkFBZ0I7QUFDaEIsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLHdCQUF3QixzQkFBc0IsRUFBRTtBQUN2RixhQUFhO0FBQ2Isc0NBQXNDLFNBQVM7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGFBQWE7QUFDckU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQSxtQ0FBbUMsV0FBVztBQUM5QztBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUEsdUNBQXVDLHlCQUF5QixjQUFjLGNBQWM7QUFDNUYsYUFBYTtBQUNiLHNDQUFzQyxjQUFjOztBQUVwRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0Isd0NBQXdDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHFFQUFxRTtBQUN0SDtBQUNBO0FBQ0EsZ0RBQWdELHNDQUFzQztBQUN0RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EseUJBQXlCLFFBQVEsb0NBQW9DLGdCQUFnQjtBQUNyRiwwQkFBMEIsUUFBUTtBQUNsQywyQkFBMkIsUUFBUTtBQUNuQywwQkFBMEIsUUFBUTtBQUNsQyx1QkFBdUIsUUFBUSxVQUFVLHlDQUF5QyxTQUFTO0FBQzNGLHNCQUFzQixRQUFRLEdBQUcsTUFBTSxjQUFjLE9BQU8sU0FBUyxTQUFTO0FBQzlFLDJCQUEyQixRQUFRO0FBQ25DLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2FueS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEJhc2UgPSByZXF1aXJlKCcuLi9iYXNlJyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IE1lc3NhZ2VzID0gcmVxdWlyZSgnLi4vbWVzc2FnZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2UuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdhbnknLFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICBvbmx5OiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBhbHRlcmF0aW9uczogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIGV4YW1wbGVzOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgZXh0ZXJuYWxzOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgbWV0YXM6IHsgaW5pdDogW10gfSxcbiAgICAgICAgbm90ZXM6IHsgaW5pdDogW10gfSxcbiAgICAgICAgc2hhcmVkOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgdGFnczogeyBpbml0OiBbXSB9LFxuICAgICAgICB3aGVuczogeyBpbml0OiBudWxsIH1cbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBjdXN0b206IHtcbiAgICAgICAgICAgIG1ldGhvZChtZXRob2QsIGRlc2NyaXB0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJywgJ01ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQoZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCB8fCBkZXNjcmlwdGlvbiAmJiB0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdzdHJpbmcnLCAnRGVzY3JpcHRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdjdXN0b20nLCBhcmdzOiB7IG1ldGhvZCwgZGVzY3JpcHRpb24gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBtZXRob2QgfSkge1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2FueS5jdXN0b20nLCB7IGVycm9yOiBlcnIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnbWV0aG9kJywgJ2Rlc2NyaXB0aW9uJ10sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICBtZXRob2QobWVzc2FnZXMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByZWZzKHsgbWVzc2FnZXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hhcmVkOiB7XG4gICAgICAgICAgICBtZXRob2Qoc2NoZW1hKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSkgJiYgc2NoZW1hLl9mbGFncy5pZCwgJ1NjaGVtYSBtdXN0IGJlIGEgc2NoZW1hIHdpdGggYW4gaWQnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5zaGFyZWQgPSBvYmouJF90ZXJtcy5zaGFyZWQgfHwgW107XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMuc2hhcmVkLnB1c2goc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2FybmluZzoge1xuICAgICAgICAgICAgbWV0aG9kKGNvZGUsIGxvY2FsKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoY29kZSAmJiB0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycsICdJbnZhbGlkIHdhcm5pbmcgY29kZScpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3dhcm5pbmcnLCBhcmdzOiB7IGNvZGUsIGxvY2FsIH0sIHdhcm46IHRydWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgY29kZSwgbG9jYWwgfSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoY29kZSwgbG9jYWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnY29kZScsICdsb2NhbCddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtb2RpZmllcnM6IHtcblxuICAgICAgICBrZWVwKHJ1bGUsIGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgIHJ1bGUua2VlcCA9IGVuYWJsZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVzc2FnZShydWxlLCBtZXNzYWdlKSB7XG5cbiAgICAgICAgICAgIHJ1bGUubWVzc2FnZSA9IE1lc3NhZ2VzLmNvbXBpbGUobWVzc2FnZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2FybihydWxlLCBlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICBydWxlLndhcm4gPSBlbmFibGVkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlc2MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBkZXNjW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoWydleGFtcGxlcycsICdleHRlcm5hbHMnLCAnbWV0YXMnLCAnbm90ZXMnLCAndGFncyddLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9ialtrZXkuc2xpY2UoMCwgLTEpXSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnYWx0ZXJhdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsdGVyID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YXJnZXQsIGFkanVzdGVyIH0gb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRlclt0YXJnZXRdID0gYWRqdXN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmouYWx0ZXIoYWx0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnd2hlbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlZiwgaXMsIG5vdCwgdGhlbiwgb3RoZXJ3aXNlLCBjb25jYXQgfSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmNhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25jYXQoY29uY2F0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai53aGVuKHJlZiwgeyBpcywgbm90LCB0aGVuLCBvdGhlcndpc2UsIHN3aXRjaDogdmFsdWUuc3dpdGNoLCBicmVhazogdmFsdWUuYnJlYWsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoud2hlbihpcywgeyB0aGVuLCBvdGhlcndpc2UsIGJyZWFrOiB2YWx1ZS5icmVhayB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdzaGFyZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmouc2hhcmVkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnYW55LmN1c3RvbSc6ICd7eyNsYWJlbH19IGZhaWxlZCBjdXN0b20gdmFsaWRhdGlvbiBiZWNhdXNlIHt7I2Vycm9yLm1lc3NhZ2V9fScsXG4gICAgICAgICdhbnkuZGVmYXVsdCc6ICd7eyNsYWJlbH19IHRocmV3IGFuIGVycm9yIHdoZW4gcnVubmluZyBkZWZhdWx0IG1ldGhvZCcsXG4gICAgICAgICdhbnkuZmFpbG92ZXInOiAne3sjbGFiZWx9fSB0aHJldyBhbiBlcnJvciB3aGVuIHJ1bm5pbmcgZmFpbG92ZXIgbWV0aG9kJyxcbiAgICAgICAgJ2FueS5pbnZhbGlkJzogJ3t7I2xhYmVsfX0gY29udGFpbnMgYW4gaW52YWxpZCB2YWx1ZScsXG4gICAgICAgICdhbnkub25seSc6ICd7eyNsYWJlbH19IG11c3QgYmUge2lmKCN2YWxpZHMubGVuZ3RoID09IDEsIFwiXCIsIFwib25lIG9mIFwiKX17eyN2YWxpZHN9fScsXG4gICAgICAgICdhbnkucmVmJzogJ3t7I2xhYmVsfX0ge3sjYXJnfX0gcmVmZXJlbmNlcyB7ezojcmVmfX0gd2hpY2gge3sjcmVhc29ufX0nLFxuICAgICAgICAnYW55LnJlcXVpcmVkJzogJ3t7I2xhYmVsfX0gaXMgcmVxdWlyZWQnLFxuICAgICAgICAnYW55LnVua25vd24nOiAne3sjbGFiZWx9fSBpcyBub3QgYWxsb3dlZCdcbiAgICB9XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/types/any.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/types/array.js":
/*!*********************************************!*\
  !*** ./node_modules/joi/lib/types/array.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ \"@hapi/hoek/lib/deepEqual\");\nconst Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ \"@hapi/hoek/lib/reach\");\n\nconst Any = __webpack_require__(/*! ./any */ \"./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ../compile */ \"./node_modules/joi/lib/compile.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'array',\n\n    flags: {\n\n        single: { default: false },\n        sparse: { default: false }\n    },\n\n    terms: {\n\n        items: { init: [], manifest: 'schema' },\n        ordered: { init: [], manifest: 'schema' },\n\n        _exclusions: { init: [] },\n        _inclusions: { init: [] },\n        _requireds: { init: [] }\n    },\n\n    coerce: {\n        from: 'object',\n        method(value, { schema, state, prefs }) {\n\n            if (!Array.isArray(value)) {\n                return;\n            }\n\n            const sort = schema.$_getRule('sort');\n            if (!sort) {\n                return;\n            }\n\n            return internals.sort(schema, value, sort.args.options, state, prefs);\n        }\n    },\n\n    validate(value, { schema, error }) {\n\n        if (!Array.isArray(value)) {\n            if (schema._flags.single) {\n                const single = [value];\n                single[Common.symbols.arraySingle] = true;\n                return { value: single };\n            }\n\n            return { errors: error('array.base') };\n        }\n\n        if (!schema.$_getRule('items') &&\n            !schema.$_terms.externals) {\n\n            return;\n        }\n\n        return { value: value.slice() };        // Clone the array so that we don't modify the original\n    },\n\n    rules: {\n\n        has: {\n            method(schema) {\n\n                schema = this.$_compile(schema, { appendPath: true });\n                const obj = this.$_addRule({ name: 'has', args: { schema } });\n                obj.$_mutateRegister(schema);\n                return obj;\n            },\n            validate(value, { state, prefs, error }, { schema: has }) {\n\n                const ancestors = [value, ...state.ancestors];\n                for (let i = 0; i < value.length; ++i) {\n                    const localState = state.localize([...state.path, i], ancestors, has);\n                    if (has.$_match(value[i], localState, prefs)) {\n                        return value;\n                    }\n                }\n\n                const patternLabel = has._flags.label;\n                if (patternLabel) {\n                    return error('array.hasKnown', { patternLabel });\n                }\n\n                return error('array.hasUnknown', null);\n            },\n            multi: true\n        },\n\n        items: {\n            method(...schemas) {\n\n                Common.verifyFlat(schemas, 'items');\n\n                const obj = this.$_addRule('items');\n\n                for (let i = 0; i < schemas.length; ++i) {\n                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });\n                    obj.$_terms.items.push(type);\n                }\n\n                return obj.$_mutateRebuild();\n            },\n            validate(value, { schema, error, state, prefs, errorsArray }) {\n\n                const requireds = schema.$_terms._requireds.slice();\n                const ordereds = schema.$_terms.ordered.slice();\n                const inclusions = [...schema.$_terms._inclusions, ...requireds];\n\n                const wasArray = !value[Common.symbols.arraySingle];\n                delete value[Common.symbols.arraySingle];\n\n                const errors = errorsArray();\n\n                let il = value.length;\n                for (let i = 0; i < il; ++i) {\n                    const item = value[i];\n\n                    let errored = false;\n                    let isValid = false;\n\n                    const key = wasArray ? i : new Number(i);       // eslint-disable-line no-new-wrappers\n                    const path = [...state.path, key];\n\n                    // Sparse\n\n                    if (!schema._flags.sparse &&\n                        item === undefined) {\n\n                        errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n\n                        ordereds.shift();\n                        continue;\n                    }\n\n                    // Exclusions\n\n                    const ancestors = [value, ...state.ancestors];\n\n                    for (const exclusion of schema.$_terms._exclusions) {\n                        if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, { presence: 'ignore' })) {\n                            continue;\n                        }\n\n                        errors.push(error('array.excludes', { pos: i, value: item }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n\n                        errored = true;\n                        ordereds.shift();\n                        break;\n                    }\n\n                    if (errored) {\n                        continue;\n                    }\n\n                    // Ordered\n\n                    if (schema.$_terms.ordered.length) {\n                        if (ordereds.length) {\n                            const ordered = ordereds.shift();\n                            const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);\n                            if (!res.errors) {\n                                if (ordered._flags.result === 'strip') {\n                                    internals.fastSplice(value, i);\n                                    --i;\n                                    --il;\n                                }\n                                else if (!schema._flags.sparse && res.value === undefined) {\n                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                                    if (prefs.abortEarly) {\n                                        return errors;\n                                    }\n\n                                    continue;\n                                }\n                                else {\n                                    value[i] = res.value;\n                                }\n                            }\n                            else {\n                                errors.push(...res.errors);\n                                if (prefs.abortEarly) {\n                                    return errors;\n                                }\n                            }\n\n                            continue;\n                        }\n                        else if (!schema.$_terms.items.length) {\n                            errors.push(error('array.orderedLength', { pos: i, limit: schema.$_terms.ordered.length }));\n                            if (prefs.abortEarly) {\n                                return errors;\n                            }\n\n                            break;      // No reason to continue since there are no other rules to validate other than array.orderedLength\n                        }\n                    }\n\n                    // Requireds\n\n                    const requiredChecks = [];\n                    let jl = requireds.length;\n                    for (let j = 0; j < jl; ++j) {\n                        const localState = state.localize(path, ancestors, requireds[j]);\n                        localState.snapshot();\n\n                        const res = requireds[j].$_validate(item, localState, prefs);\n                        requiredChecks[j] = res;\n\n                        if (!res.errors) {\n                            value[i] = res.value;\n                            isValid = true;\n                            internals.fastSplice(requireds, j);\n                            --j;\n                            --jl;\n\n                            if (!schema._flags.sparse &&\n                                res.value === undefined) {\n\n                                errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                                if (prefs.abortEarly) {\n                                    return errors;\n                                }\n                            }\n\n                            break;\n                        }\n\n                        localState.restore();\n                    }\n\n                    if (isValid) {\n                        continue;\n                    }\n\n                    // Inclusions\n\n                    const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;\n\n                    jl = inclusions.length;\n                    for (const inclusion of inclusions) {\n\n                        // Avoid re-running requireds that already didn't match in the previous loop\n\n                        let res;\n                        const previousCheck = requireds.indexOf(inclusion);\n                        if (previousCheck !== -1) {\n                            res = requiredChecks[previousCheck];\n                        }\n                        else {\n                            const localState = state.localize(path, ancestors, inclusion);\n                            localState.snapshot();\n\n                            res = inclusion.$_validate(item, localState, prefs);\n                            if (!res.errors) {\n                                if (inclusion._flags.result === 'strip') {\n                                    internals.fastSplice(value, i);\n                                    --i;\n                                    --il;\n                                }\n                                else if (!schema._flags.sparse &&\n                                    res.value === undefined) {\n\n                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                                    errored = true;\n                                }\n                                else {\n                                    value[i] = res.value;\n                                }\n\n                                isValid = true;\n                                break;\n                            }\n\n                            localState.restore();\n                        }\n\n                        // Return the actual error if only one inclusion defined\n\n                        if (jl === 1) {\n                            if (stripUnknown) {\n                                internals.fastSplice(value, i);\n                                --i;\n                                --il;\n                                isValid = true;\n                                break;\n                            }\n\n                            errors.push(...res.errors);\n                            if (prefs.abortEarly) {\n                                return errors;\n                            }\n\n                            errored = true;\n                            break;\n                        }\n                    }\n\n                    if (errored) {\n                        continue;\n                    }\n\n                    if (schema.$_terms._inclusions.length &&\n                        !isValid) {\n\n                        if (stripUnknown) {\n                            internals.fastSplice(value, i);\n                            --i;\n                            --il;\n                            continue;\n                        }\n\n                        errors.push(error('array.includes', { pos: i, value: item }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n                    }\n                }\n\n                if (requireds.length) {\n                    internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);\n                }\n\n                if (ordereds.length) {\n                    internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);\n\n                    if (!errors.length) {\n                        internals.fillDefault(ordereds, value, state, prefs);\n                    }\n                }\n\n                return errors.length ? errors : value;\n            },\n\n            priority: true,\n            manifest: false\n        },\n\n        length: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });\n            },\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(value.length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('array.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                }\n            ]\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });\n            }\n        },\n\n        ordered: {\n            method(...schemas) {\n\n                Common.verifyFlat(schemas, 'ordered');\n\n                const obj = this.$_addRule('items');\n\n                for (let i = 0; i < schemas.length; ++i) {\n                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });\n                    internals.validateSingle(type, obj);\n\n                    obj.$_mutateRegister(type);\n                    obj.$_terms.ordered.push(type);\n                }\n\n                return obj.$_mutateRebuild();\n            }\n        },\n\n        single: {\n            method(enabled) {\n\n                const value = enabled === undefined ? true : !!enabled;\n                Assert(!value || !this._flags._arrayItems, 'Cannot specify single rule when array has array items');\n\n                return this.$_setFlag('single', value);\n            }\n        },\n\n        sort: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['by', 'order']);\n\n                const settings = {\n                    order: options.order || 'ascending'\n                };\n\n                if (options.by) {\n                    settings.by = Compile.ref(options.by, { ancestor: 0 });\n                    Assert(!settings.by.ancestor, 'Cannot sort by ancestor');\n                }\n\n                return this.$_addRule({ name: 'sort', args: { options: settings } });\n            },\n            validate(value, { error, state, prefs, schema }, { options }) {\n\n                const { value: sorted, errors } = internals.sort(schema, value, options, state, prefs);\n                if (errors) {\n                    return errors;\n                }\n\n                for (let i = 0; i < value.length; ++i) {\n                    if (value[i] !== sorted[i]) {\n                        return error('array.sort', { order: options.order, by: options.by ? options.by.key : 'value' });\n                    }\n                }\n\n                return value;\n            },\n            convert: true\n        },\n\n        sparse: {\n            method(enabled) {\n\n                const value = enabled === undefined ? true : !!enabled;\n\n                if (this._flags.sparse === value) {\n                    return this;\n                }\n\n                const obj = value ? this.clone() : this.$_addRule('items');\n                return obj.$_setFlag('sparse', value, { clone: false });\n            }\n        },\n\n        unique: {\n            method(comparator, options = {}) {\n\n                Assert(!comparator || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');\n                Common.assertOptions(options, ['ignoreUndefined', 'separator']);\n\n                const rule = { name: 'unique', args: { options, comparator } };\n\n                if (comparator) {\n                    if (typeof comparator === 'string') {\n                        const separator = Common.default(options.separator, '.');\n                        rule.path = separator ? comparator.split(separator) : [comparator];\n                    }\n                    else {\n                        rule.comparator = comparator;\n                    }\n                }\n\n                return this.$_addRule(rule);\n            },\n            validate(value, { state, error, schema }, { comparator: raw, options }, { comparator, path }) {\n\n                const found = {\n                    string: Object.create(null),\n                    number: Object.create(null),\n                    undefined: Object.create(null),\n                    boolean: Object.create(null),\n                    object: new Map(),\n                    function: new Map(),\n                    custom: new Map()\n                };\n\n                const compare = comparator || DeepEqual;\n                const ignoreUndefined = options.ignoreUndefined;\n\n                for (let i = 0; i < value.length; ++i) {\n                    const item = path ? Reach(value[i], path) : value[i];\n                    const records = comparator ? found.custom : found[typeof item];\n                    Assert(records, 'Failed to find unique map container for type', typeof item);\n\n                    if (records instanceof Map) {\n                        const entries = records.entries();\n                        let current;\n                        while (!(current = entries.next()).done) {\n                            if (compare(current.value[0], item)) {\n                                const localState = state.localize([...state.path, i], [value, ...state.ancestors]);\n                                const context = {\n                                    pos: i,\n                                    value: value[i],\n                                    dupePos: current.value[1],\n                                    dupeValue: value[current.value[1]]\n                                };\n\n                                if (path) {\n                                    context.path = raw;\n                                }\n\n                                return error('array.unique', context, localState);\n                            }\n                        }\n\n                        records.set(item, i);\n                    }\n                    else {\n                        if ((!ignoreUndefined || item !== undefined) &&\n                            records[item] !== undefined) {\n\n                            const context = {\n                                pos: i,\n                                value: value[i],\n                                dupePos: records[item],\n                                dupeValue: value[records[item]]\n                            };\n\n                            if (path) {\n                                context.path = raw;\n                            }\n\n                            const localState = state.localize([...state.path, i], [value, ...state.ancestors]);\n                            return error('array.unique', context, localState);\n                        }\n\n                        records[item] = i;\n                    }\n                }\n\n                return value;\n            },\n            args: ['comparator', 'options'],\n            multi: true\n        }\n    },\n\n    cast: {\n        set: {\n            from: Array.isArray,\n            to(value, helpers) {\n\n                return new Set(value);\n            }\n        }\n    },\n\n    rebuild(schema) {\n\n        schema.$_terms._inclusions = [];\n        schema.$_terms._exclusions = [];\n        schema.$_terms._requireds = [];\n\n        for (const type of schema.$_terms.items) {\n            internals.validateSingle(type, schema);\n\n            if (type._flags.presence === 'required') {\n                schema.$_terms._requireds.push(type);\n            }\n            else if (type._flags.presence === 'forbidden') {\n                schema.$_terms._exclusions.push(type);\n            }\n            else {\n                schema.$_terms._inclusions.push(type);\n            }\n        }\n\n        for (const type of schema.$_terms.ordered) {\n            internals.validateSingle(type, schema);\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.items) {\n                obj = obj.items(...desc.items);\n            }\n\n            if (desc.ordered) {\n                obj = obj.ordered(...desc.ordered);\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'array.base': '{{#label}} must be an array',\n        'array.excludes': '{{#label}} contains an excluded value',\n        'array.hasKnown': '{{#label}} does not contain at least one required match for type {:#patternLabel}',\n        'array.hasUnknown': '{{#label}} does not contain at least one required match',\n        'array.includes': '{{#label}} does not match any of the allowed types',\n        'array.includesRequiredBoth': '{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)',\n        'array.includesRequiredKnowns': '{{#label}} does not contain {{#knownMisses}}',\n        'array.includesRequiredUnknowns': '{{#label}} does not contain {{#unknownMisses}} required value(s)',\n        'array.length': '{{#label}} must contain {{#limit}} items',\n        'array.max': '{{#label}} must contain less than or equal to {{#limit}} items',\n        'array.min': '{{#label}} must contain at least {{#limit}} items',\n        'array.orderedLength': '{{#label}} must contain at most {{#limit}} items',\n        'array.sort': '{{#label}} must be sorted in {#order} order by {{#by}}',\n        'array.sort.mismatching': '{{#label}} cannot be sorted due to mismatching types',\n        'array.sort.unsupported': '{{#label}} cannot be sorted due to unsupported type {#type}',\n        'array.sparse': '{{#label}} must not be a sparse array item',\n        'array.unique': '{{#label}} contains a duplicate value'\n    }\n});\n\n\n// Helpers\n\ninternals.fillMissedErrors = function (schema, errors, requireds, value, state, prefs) {\n\n    const knownMisses = [];\n    let unknownMisses = 0;\n    for (const required of requireds) {\n        const label = required._flags.label;\n        if (label) {\n            knownMisses.push(label);\n        }\n        else {\n            ++unknownMisses;\n        }\n    }\n\n    if (knownMisses.length) {\n        if (unknownMisses) {\n            errors.push(schema.$_createError('array.includesRequiredBoth', value, { knownMisses, unknownMisses }, state, prefs));\n        }\n        else {\n            errors.push(schema.$_createError('array.includesRequiredKnowns', value, { knownMisses }, state, prefs));\n        }\n    }\n    else {\n        errors.push(schema.$_createError('array.includesRequiredUnknowns', value, { unknownMisses }, state, prefs));\n    }\n};\n\n\ninternals.fillOrderedErrors = function (schema, errors, ordereds, value, state, prefs) {\n\n    const requiredOrdereds = [];\n\n    for (const ordered of ordereds) {\n        if (ordered._flags.presence === 'required') {\n            requiredOrdereds.push(ordered);\n        }\n    }\n\n    if (requiredOrdereds.length) {\n        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);\n    }\n};\n\n\ninternals.fillDefault = function (ordereds, value, state, prefs) {\n\n    const overrides = [];\n    let trailingUndefined = true;\n\n    for (let i = ordereds.length - 1; i >= 0; --i) {\n        const ordered = ordereds[i];\n        const ancestors = [value, ...state.ancestors];\n        const override = ordered.$_validate(undefined, state.localize(state.path, ancestors, ordered), prefs).value;\n\n        if (trailingUndefined) {\n            if (override === undefined) {\n                continue;\n            }\n\n            trailingUndefined = false;\n        }\n\n        overrides.unshift(override);\n    }\n\n    if (overrides.length) {\n        value.push(...overrides);\n    }\n};\n\n\ninternals.fastSplice = function (arr, i) {\n\n    let pos = i;\n    while (pos < arr.length) {\n        arr[pos++] = arr[pos];\n    }\n\n    --arr.length;\n};\n\n\ninternals.validateSingle = function (type, obj) {\n\n    if (type.type === 'array' ||\n        type._flags._arrayItems) {\n\n        Assert(!obj._flags.single, 'Cannot specify array item with single rule enabled');\n        obj.$_setFlag('_arrayItems', true, { clone: false });\n    }\n};\n\n\ninternals.sort = function (schema, value, settings, state, prefs) {\n\n    const order = settings.order === 'ascending' ? 1 : -1;\n    const aFirst = -1 * order;\n    const bFirst = order;\n\n    const sort = (a, b) => {\n\n        let compare = internals.compare(a, b, aFirst, bFirst);\n        if (compare !== null) {\n            return compare;\n        }\n\n        if (settings.by) {\n            a = settings.by.resolve(a, state, prefs);\n            b = settings.by.resolve(b, state, prefs);\n        }\n\n        compare = internals.compare(a, b, aFirst, bFirst);\n        if (compare !== null) {\n            return compare;\n        }\n\n        const type = typeof a;\n        if (type !== typeof b) {\n            throw schema.$_createError('array.sort.mismatching', value, null, state, prefs);\n        }\n\n        if (type !== 'number' &&\n            type !== 'string') {\n\n            throw schema.$_createError('array.sort.unsupported', value, { type }, state, prefs);\n        }\n\n        if (type === 'number') {\n            return (a - b) * order;\n        }\n\n        return a < b ? aFirst : bFirst;\n    };\n\n    try {\n        return { value: value.slice().sort(sort) };\n    }\n    catch (err) {\n        return { errors: err };\n    }\n};\n\n\ninternals.compare = function (a, b, aFirst, bFirst) {\n\n    if (a === b) {\n        return 0;\n    }\n\n    if (a === undefined) {\n        return 1;           // Always last regardless of sort order\n    }\n\n    if (b === undefined) {\n        return -1;           // Always last regardless of sort order\n    }\n\n    if (a === null) {\n        return bFirst;\n    }\n\n    if (b === null) {\n        return aFirst;\n    }\n\n    return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hcnJheS5qcz83Yzk0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxvREFBdUI7QUFDOUMsa0JBQWtCLG1CQUFPLENBQUMsMERBQTBCO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQyxrREFBc0I7O0FBRTVDLFlBQVksbUJBQU8sQ0FBQyxrREFBTztBQUMzQixlQUFlLG1CQUFPLENBQUMsbURBQVc7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMscURBQVk7OztBQUdwQzs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQyxpQkFBaUI7QUFDakIsS0FBSzs7QUFFTDs7QUFFQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGtCQUFrQiwrQkFBK0I7O0FBRWpELHNCQUFzQixXQUFXO0FBQ2pDLHNCQUFzQixXQUFXO0FBQ2pDLHFCQUFxQjtBQUNyQixLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUwscUJBQXFCLGdCQUFnQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUEsb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQSxpREFBaUQsbUJBQW1CO0FBQ3BFLDRDQUE0QyxxQkFBcUIsU0FBUyxFQUFFO0FBQzVFO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNkJBQTZCLHNCQUFzQixHQUFHLGNBQWM7O0FBRXBFO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0QsZUFBZTtBQUNuRTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0Isb0JBQW9CO0FBQ25ELDBGQUEwRixlQUFlO0FBQ3pHO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsNkJBQTZCLDJDQUEyQzs7QUFFeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrQkFBK0IsUUFBUTtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBLDZEQUE2RDtBQUM3RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJEQUEyRCxzQ0FBc0M7QUFDakc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHlHQUF5RyxxQkFBcUI7QUFDOUg7QUFDQTs7QUFFQSw2REFBNkQsc0JBQXNCO0FBQ25GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxzQ0FBc0M7QUFDN0c7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsK0NBQStDO0FBQ3JIO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFtRSxzQ0FBc0M7QUFDekc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVFQUF1RSxzQ0FBc0M7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQsc0JBQXNCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsdUNBQXVDLHdCQUF3QixRQUFRLGlCQUFpQjtBQUN4RixhQUFhO0FBQ2Isc0NBQXNDLFFBQVEsR0FBRyx1QkFBdUI7O0FBRXhFO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsMkJBQTJCO0FBQ2xGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsUUFBUSxrQkFBa0I7QUFDeEc7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsdUNBQXVDLHVDQUF1QyxRQUFRLGtCQUFrQjtBQUN4RztBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0Isb0JBQW9CO0FBQ25ELDBGQUEwRixlQUFlO0FBQ3pHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSwrQkFBK0I7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7O0FBRUEsdUNBQXVDLHNCQUFzQixvQkFBb0IsRUFBRTtBQUNuRixhQUFhO0FBQ2IsNkJBQTZCLDhCQUE4QixHQUFHLFVBQVU7O0FBRXhFLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBOztBQUVBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQSxvREFBb0Qsa0VBQWtFO0FBQ3RIO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELGVBQWU7QUFDdEU7QUFDQSxTQUFTOztBQUVUO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBOztBQUVBLDhCQUE4Qix3QkFBd0Isc0JBQXNCOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsNkJBQTZCLHVCQUF1QixHQUFHLDJCQUEyQixHQUFHLG1CQUFtQjs7QUFFeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRLHdEQUF3RCxlQUFlO0FBQzVHLCtCQUErQixRQUFRO0FBQ3ZDLDZCQUE2QixRQUFRO0FBQ3JDLHlDQUF5QyxRQUFRLG9CQUFvQixjQUFjLE9BQU8sZ0JBQWdCO0FBQzFHLDJDQUEyQyxRQUFRLG9CQUFvQixjQUFjO0FBQ3JGLDZDQUE2QyxRQUFRLG9CQUFvQixnQkFBZ0I7QUFDekYsMkJBQTJCLFFBQVEsZ0JBQWdCLFFBQVE7QUFDM0Qsd0JBQXdCLFFBQVEsc0NBQXNDLFFBQVE7QUFDOUUsd0JBQXdCLFFBQVEseUJBQXlCLFFBQVE7QUFDakUsa0NBQWtDLFFBQVEsd0JBQXdCLFFBQVE7QUFDMUUseUJBQXlCLFFBQVEsb0JBQW9CLE9BQU8sWUFBWSxLQUFLO0FBQzdFLHFDQUFxQyxRQUFRO0FBQzdDLHFDQUFxQyxRQUFRLDJDQUEyQyxNQUFNO0FBQzlGLDJCQUEyQixRQUFRO0FBQ25DLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUZBQW1GLDZCQUE2QjtBQUNoSDtBQUNBO0FBQ0EscUZBQXFGLGNBQWM7QUFDbkc7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLGdCQUFnQjtBQUNuRztBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5RUFBeUUsT0FBTztBQUNoRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hcnJheS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBEZWVwRXF1YWwgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9kZWVwRXF1YWwnKTtcbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvcmVhY2gnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgQ29tcGlsZSA9IHJlcXVpcmUoJy4uL2NvbXBpbGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2FycmF5JyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgc2luZ2xlOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgIHNwYXJzZTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgaXRlbXM6IHsgaW5pdDogW10sIG1hbmlmZXN0OiAnc2NoZW1hJyB9LFxuICAgICAgICBvcmRlcmVkOiB7IGluaXQ6IFtdLCBtYW5pZmVzdDogJ3NjaGVtYScgfSxcblxuICAgICAgICBfZXhjbHVzaW9uczogeyBpbml0OiBbXSB9LFxuICAgICAgICBfaW5jbHVzaW9uczogeyBpbml0OiBbXSB9LFxuICAgICAgICBfcmVxdWlyZWRzOiB7IGluaXQ6IFtdIH1cbiAgICB9LFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206ICdvYmplY3QnLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hLCBzdGF0ZSwgcHJlZnMgfSkge1xuXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzb3J0ID0gc2NoZW1hLiRfZ2V0UnVsZSgnc29ydCcpO1xuICAgICAgICAgICAgaWYgKCFzb3J0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnNvcnQoc2NoZW1hLCB2YWx1ZSwgc29ydC5hcmdzLm9wdGlvbnMsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3Muc2luZ2xlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2luZ2xlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICBzaW5nbGVbQ29tbW9uLnN5bWJvbHMuYXJyYXlTaW5nbGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogc2luZ2xlIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FycmF5LmJhc2UnKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzY2hlbWEuJF9nZXRSdWxlKCdpdGVtcycpICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMuZXh0ZXJuYWxzKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZS5zbGljZSgpIH07ICAgICAgICAvLyBDbG9uZSB0aGUgYXJyYXkgc28gdGhhdCB3ZSBkb24ndCBtb2RpZnkgdGhlIG9yaWdpbmFsXG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgaGFzOiB7XG4gICAgICAgICAgICBtZXRob2Qoc2NoZW1hKSB7XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLiRfY29tcGlsZShzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdoYXMnLCBhcmdzOiB7IHNjaGVtYSB9IH0pO1xuICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzdGF0ZSwgcHJlZnMsIGVycm9yIH0sIHsgc2NoZW1hOiBoYXMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBpXSwgYW5jZXN0b3JzLCBoYXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzLiRfbWF0Y2godmFsdWVbaV0sIGxvY2FsU3RhdGUsIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybkxhYmVsID0gaGFzLl9mbGFncy5sYWJlbDtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybkxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkuaGFzS25vd24nLCB7IHBhdHRlcm5MYWJlbCB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5Lmhhc1Vua25vd24nLCBudWxsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4uc2NoZW1hcykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQoc2NoZW1hcywgJ2l0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfYWRkUnVsZSgnaXRlbXMnKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gQ29tbW9uLnRyeVdpdGhQYXRoKCgpID0+IHRoaXMuJF9jb21waWxlKHNjaGVtYXNbaV0pLCBpLCB7IGFwcGVuZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMuaXRlbXMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IsIHN0YXRlLCBwcmVmcywgZXJyb3JzQXJyYXkgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRzID0gc2NoZW1hLiRfdGVybXMuX3JlcXVpcmVkcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyZWRzID0gc2NoZW1hLiRfdGVybXMub3JkZXJlZC5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluY2x1c2lvbnMgPSBbLi4uc2NoZW1hLiRfdGVybXMuX2luY2x1c2lvbnMsIC4uLnJlcXVpcmVkc107XG5cbiAgICAgICAgICAgICAgICBjb25zdCB3YXNBcnJheSA9ICF2YWx1ZVtDb21tb24uc3ltYm9scy5hcnJheVNpbmdsZV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW0NvbW1vbi5zeW1ib2xzLmFycmF5U2luZ2xlXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGVycm9yc0FycmF5KCk7XG5cbiAgICAgICAgICAgICAgICBsZXQgaWwgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3JlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHdhc0FycmF5ID8gaSA6IG5ldyBOdW1iZXIoaSk7ICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBbLi4uc3RhdGUucGF0aCwga2V5XTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTcGFyc2VcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVtYS5fZmxhZ3Muc3BhcnNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LnNwYXJzZScsIHsga2V5LCBwYXRoLCBwb3M6IGksIHZhbHVlOiB1bmRlZmluZWQgfSwgc3RhdGUubG9jYWxpemUocGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhjbHVzaW9uc1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV4Y2x1c2lvbiBvZiBzY2hlbWEuJF90ZXJtcy5fZXhjbHVzaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGNsdXNpb24uJF9tYXRjaChpdGVtLCBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIGV4Y2x1c2lvbiksIHByZWZzLCB7IHByZXNlbmNlOiAnaWdub3JlJyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuZXhjbHVkZXMnLCB7IHBvczogaSwgdmFsdWU6IGl0ZW0gfSwgc3RhdGUubG9jYWxpemUocGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBPcmRlcmVkXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLm9yZGVyZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXJlZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJlZCA9IG9yZGVyZWRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gb3JkZXJlZC4kX3ZhbGlkYXRlKGl0ZW0sIHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgb3JkZXJlZCksIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcy5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyZWQuX2ZsYWdzLnJlc3VsdCA9PT0gJ3N0cmlwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UodmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghc2NoZW1hLl9mbGFncy5zcGFyc2UgJiYgcmVzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5zcGFyc2UnLCB7IGtleSwgcGF0aCwgcG9zOiBpLCB2YWx1ZTogdW5kZWZpbmVkIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbaV0gPSByZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlcy5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNjaGVtYS4kX3Rlcm1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5vcmRlcmVkTGVuZ3RoJywgeyBwb3M6IGksIGxpbWl0OiBzY2hlbWEuJF90ZXJtcy5vcmRlcmVkLmxlbmd0aCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgICAvLyBObyByZWFzb24gdG8gY29udGludWUgc2luY2UgdGhlcmUgYXJlIG5vIG90aGVyIHJ1bGVzIHRvIHZhbGlkYXRlIG90aGVyIHRoYW4gYXJyYXkub3JkZXJlZExlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVxdWlyZWRzXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRDaGVja3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGpsID0gcmVxdWlyZWRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBqbDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUocGF0aCwgYW5jZXN0b3JzLCByZXF1aXJlZHNbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5zbmFwc2hvdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSByZXF1aXJlZHNbal0uJF92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZENoZWNrc1tqXSA9IHJlcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbaV0gPSByZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UocmVxdWlyZWRzLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1qbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hLl9mbGFncy5zcGFyc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluY2x1c2lvbnNcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpcFVua25vd24gPSBwcmVmcy5zdHJpcFVua25vd24gJiYgISFwcmVmcy5zdHJpcFVua25vd24uYXJyYXlzIHx8IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGpsID0gaW5jbHVzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5jbHVzaW9uIG9mIGluY2x1c2lvbnMpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgcmUtcnVubmluZyByZXF1aXJlZHMgdGhhdCBhbHJlYWR5IGRpZG4ndCBtYXRjaCBpbiB0aGUgcHJldmlvdXMgbG9vcFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDaGVjayA9IHJlcXVpcmVkcy5pbmRleE9mKGluY2x1c2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNDaGVjayAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXF1aXJlZENoZWNrc1twcmV2aW91c0NoZWNrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIGluY2x1c2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5zbmFwc2hvdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gaW5jbHVzaW9uLiRfdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVzaW9uLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNjaGVtYS5fZmxhZ3Muc3BhcnNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IHJlcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBhY3R1YWwgZXJyb3IgaWYgb25seSBvbmUgaW5jbHVzaW9uIGRlZmluZWRcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpsID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmlwVW5rbm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZSh2YWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlcy5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMuX2luY2x1c2lvbnMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNWYWxpZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaXBVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UodmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuaW5jbHVkZXMnLCB7IHBvczogaSwgdmFsdWU6IGl0ZW0gfSwgc3RhdGUubG9jYWxpemUocGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5maWxsTWlzc2VkRXJyb3JzKHNjaGVtYSwgZXJyb3JzLCByZXF1aXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcmRlcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZpbGxPcmRlcmVkRXJyb3JzKHNjaGVtYSwgZXJyb3JzLCBvcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmlsbERlZmF1bHQob3JkZXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPyBlcnJvcnMgOiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlLFxuICAgICAgICAgICAgbWFuaWZlc3Q6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPScgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUodmFsdWUubGVuZ3RoLCBsaW1pdCwgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignYXJyYXkuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiBDb21tb24ubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluJywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz49JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvcmRlcmVkOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4uc2NoZW1hcykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQoc2NoZW1hcywgJ29yZGVyZWQnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9hZGRSdWxlKCdpdGVtcycpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWFzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBDb21tb24udHJ5V2l0aFBhdGgoKCkgPT4gdGhpcy4kX2NvbXBpbGUoc2NoZW1hc1tpXSksIGksIHsgYXBwZW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGVTaW5nbGUodHlwZSwgb2JqKTtcblxuICAgICAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3Rlcih0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMub3JkZXJlZC5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2luZ2xlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFlbmFibGVkO1xuICAgICAgICAgICAgICAgIEFzc2VydCghdmFsdWUgfHwgIXRoaXMuX2ZsYWdzLl9hcnJheUl0ZW1zLCAnQ2Fubm90IHNwZWNpZnkgc2luZ2xlIHJ1bGUgd2hlbiBhcnJheSBoYXMgYXJyYXkgaXRlbXMnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnc2luZ2xlJywgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNvcnQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYnknLCAnb3JkZXInXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IG9wdGlvbnMub3JkZXIgfHwgJ2FzY2VuZGluZydcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYnkgPSBDb21waWxlLnJlZihvcHRpb25zLmJ5LCB7IGFuY2VzdG9yOiAwIH0pO1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIXNldHRpbmdzLmJ5LmFuY2VzdG9yLCAnQ2Fubm90IHNvcnQgYnkgYW5jZXN0b3InKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnc29ydCcsIGFyZ3M6IHsgb3B0aW9uczogc2V0dGluZ3MgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciwgc3RhdGUsIHByZWZzLCBzY2hlbWEgfSwgeyBvcHRpb25zIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWU6IHNvcnRlZCwgZXJyb3JzIH0gPSBpbnRlcm5hbHMuc29ydChzY2hlbWEsIHZhbHVlLCBvcHRpb25zLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtpXSAhPT0gc29ydGVkW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5LnNvcnQnLCB7IG9yZGVyOiBvcHRpb25zLm9yZGVyLCBieTogb3B0aW9ucy5ieSA/IG9wdGlvbnMuYnkua2V5IDogJ3ZhbHVlJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb252ZXJ0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3BhcnNlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFlbmFibGVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnNwYXJzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdmFsdWUgPyB0aGlzLmNsb25lKCkgOiB0aGlzLiRfYWRkUnVsZSgnaXRlbXMnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfc2V0RmxhZygnc3BhcnNlJywgdmFsdWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuaXF1ZToge1xuICAgICAgICAgICAgbWV0aG9kKGNvbXBhcmF0b3IsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFjb21wYXJhdG9yIHx8IHR5cGVvZiBjb21wYXJhdG9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjb21wYXJhdG9yID09PSAnc3RyaW5nJywgJ2NvbXBhcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydpZ25vcmVVbmRlZmluZWQnLCAnc2VwYXJhdG9yJ10pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcnVsZSA9IHsgbmFtZTogJ3VuaXF1ZScsIGFyZ3M6IHsgb3B0aW9ucywgY29tcGFyYXRvciB9IH07XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSBDb21tb24uZGVmYXVsdChvcHRpb25zLnNlcGFyYXRvciwgJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUucGF0aCA9IHNlcGFyYXRvciA/IGNvbXBhcmF0b3Iuc3BsaXQoc2VwYXJhdG9yKSA6IFtjb21wYXJhdG9yXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUocnVsZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgc3RhdGUsIGVycm9yLCBzY2hlbWEgfSwgeyBjb21wYXJhdG9yOiByYXcsIG9wdGlvbnMgfSwgeyBjb21wYXJhdG9yLCBwYXRoIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kID0ge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmc6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIG51bWJlcjogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBib29sZWFuOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tOiBuZXcgTWFwKClcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGFyZSA9IGNvbXBhcmF0b3IgfHwgRGVlcEVxdWFsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlnbm9yZVVuZGVmaW5lZCA9IG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gcGF0aCA/IFJlYWNoKHZhbHVlW2ldLCBwYXRoKSA6IHZhbHVlW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRzID0gY29tcGFyYXRvciA/IGZvdW5kLmN1c3RvbSA6IGZvdW5kW3R5cGVvZiBpdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHJlY29yZHMsICdGYWlsZWQgdG8gZmluZCB1bmlxdWUgbWFwIGNvbnRhaW5lciBmb3IgdHlwZScsIHR5cGVvZiBpdGVtKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkcyBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IHJlY29yZHMuZW50cmllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIShjdXJyZW50ID0gZW50cmllcy5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShjdXJyZW50LnZhbHVlWzBdLCBpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGldLCBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVBvczogY3VycmVudC52YWx1ZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVWYWx1ZTogdmFsdWVbY3VycmVudC52YWx1ZVsxXV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wYXRoID0gcmF3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdhcnJheS51bmlxdWUnLCBjb250ZXh0LCBsb2NhbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZHMuc2V0KGl0ZW0sIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCghaWdub3JlVW5kZWZpbmVkIHx8IGl0ZW0gIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzW2l0ZW1dICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlUG9zOiByZWNvcmRzW2l0ZW1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlVmFsdWU6IHZhbHVlW3JlY29yZHNbaXRlbV1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucGF0aCA9IHJhdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGldLCBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkudW5pcXVlJywgY29udGV4dCwgbG9jYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZHNbaXRlbV0gPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnY29tcGFyYXRvcicsICdvcHRpb25zJ10sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgc2V0OiB7XG4gICAgICAgICAgICBmcm9tOiBBcnJheS5pc0FycmF5LFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2V0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWJ1aWxkKHNjaGVtYSkge1xuXG4gICAgICAgIHNjaGVtYS4kX3Rlcm1zLl9pbmNsdXNpb25zID0gW107XG4gICAgICAgIHNjaGVtYS4kX3Rlcm1zLl9leGNsdXNpb25zID0gW107XG4gICAgICAgIHNjaGVtYS4kX3Rlcm1zLl9yZXF1aXJlZHMgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygc2NoZW1hLiRfdGVybXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGludGVybmFscy52YWxpZGF0ZVNpbmdsZSh0eXBlLCBzY2hlbWEpO1xuXG4gICAgICAgICAgICBpZiAodHlwZS5fZmxhZ3MucHJlc2VuY2UgPT09ICdyZXF1aXJlZCcpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEuJF90ZXJtcy5fcmVxdWlyZWRzLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlLl9mbGFncy5wcmVzZW5jZSA9PT0gJ2ZvcmJpZGRlbicpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEuJF90ZXJtcy5fZXhjbHVzaW9ucy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMuX2luY2x1c2lvbnMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBzY2hlbWEuJF90ZXJtcy5vcmRlcmVkKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGVTaW5nbGUodHlwZSwgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5pdGVtcykge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9iai5pdGVtcyguLi5kZXNjLml0ZW1zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2Mub3JkZXJlZCkge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9iai5vcmRlcmVkKC4uLmRlc2Mub3JkZXJlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2FycmF5LmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGFuIGFycmF5JyxcbiAgICAgICAgJ2FycmF5LmV4Y2x1ZGVzJzogJ3t7I2xhYmVsfX0gY29udGFpbnMgYW4gZXhjbHVkZWQgdmFsdWUnLFxuICAgICAgICAnYXJyYXkuaGFzS25vd24nOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBjb250YWluIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBtYXRjaCBmb3IgdHlwZSB7OiNwYXR0ZXJuTGFiZWx9JyxcbiAgICAgICAgJ2FycmF5Lmhhc1Vua25vd24nOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBjb250YWluIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBtYXRjaCcsXG4gICAgICAgICdhcnJheS5pbmNsdWRlcyc6ICd7eyNsYWJlbH19IGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgYWxsb3dlZCB0eXBlcycsXG4gICAgICAgICdhcnJheS5pbmNsdWRlc1JlcXVpcmVkQm90aCc6ICd7eyNsYWJlbH19IGRvZXMgbm90IGNvbnRhaW4ge3sja25vd25NaXNzZXN9fSBhbmQge3sjdW5rbm93bk1pc3Nlc319IG90aGVyIHJlcXVpcmVkIHZhbHVlKHMpJyxcbiAgICAgICAgJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRLbm93bnMnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBjb250YWluIHt7I2tub3duTWlzc2VzfX0nLFxuICAgICAgICAnYXJyYXkuaW5jbHVkZXNSZXF1aXJlZFVua25vd25zJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiB7eyN1bmtub3duTWlzc2VzfX0gcmVxdWlyZWQgdmFsdWUocyknLFxuICAgICAgICAnYXJyYXkubGVuZ3RoJzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIHt7I2xpbWl0fX0gaXRlbXMnLFxuICAgICAgICAnYXJyYXkubWF4JzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19IGl0ZW1zJyxcbiAgICAgICAgJ2FycmF5Lm1pbic6ICd7eyNsYWJlbH19IG11c3QgY29udGFpbiBhdCBsZWFzdCB7eyNsaW1pdH19IGl0ZW1zJyxcbiAgICAgICAgJ2FycmF5Lm9yZGVyZWRMZW5ndGgnOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4gYXQgbW9zdCB7eyNsaW1pdH19IGl0ZW1zJyxcbiAgICAgICAgJ2FycmF5LnNvcnQnOiAne3sjbGFiZWx9fSBtdXN0IGJlIHNvcnRlZCBpbiB7I29yZGVyfSBvcmRlciBieSB7eyNieX19JyxcbiAgICAgICAgJ2FycmF5LnNvcnQubWlzbWF0Y2hpbmcnOiAne3sjbGFiZWx9fSBjYW5ub3QgYmUgc29ydGVkIGR1ZSB0byBtaXNtYXRjaGluZyB0eXBlcycsXG4gICAgICAgICdhcnJheS5zb3J0LnVuc3VwcG9ydGVkJzogJ3t7I2xhYmVsfX0gY2Fubm90IGJlIHNvcnRlZCBkdWUgdG8gdW5zdXBwb3J0ZWQgdHlwZSB7I3R5cGV9JyxcbiAgICAgICAgJ2FycmF5LnNwYXJzZSc6ICd7eyNsYWJlbH19IG11c3Qgbm90IGJlIGEgc3BhcnNlIGFycmF5IGl0ZW0nLFxuICAgICAgICAnYXJyYXkudW5pcXVlJzogJ3t7I2xhYmVsfX0gY29udGFpbnMgYSBkdXBsaWNhdGUgdmFsdWUnXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuZmlsbE1pc3NlZEVycm9ycyA9IGZ1bmN0aW9uIChzY2hlbWEsIGVycm9ycywgcmVxdWlyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBjb25zdCBrbm93bk1pc3NlcyA9IFtdO1xuICAgIGxldCB1bmtub3duTWlzc2VzID0gMDtcbiAgICBmb3IgKGNvbnN0IHJlcXVpcmVkIG9mIHJlcXVpcmVkcykge1xuICAgICAgICBjb25zdCBsYWJlbCA9IHJlcXVpcmVkLl9mbGFncy5sYWJlbDtcbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICBrbm93bk1pc3Nlcy5wdXNoKGxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICsrdW5rbm93bk1pc3NlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrbm93bk1pc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHVua25vd25NaXNzZXMpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkQm90aCcsIHZhbHVlLCB7IGtub3duTWlzc2VzLCB1bmtub3duTWlzc2VzIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRLbm93bnMnLCB2YWx1ZSwgeyBrbm93bk1pc3NlcyB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRVbmtub3ducycsIHZhbHVlLCB7IHVua25vd25NaXNzZXMgfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuZmlsbE9yZGVyZWRFcnJvcnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBlcnJvcnMsIG9yZGVyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBjb25zdCByZXF1aXJlZE9yZGVyZWRzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IG9yZGVyZWQgb2Ygb3JkZXJlZHMpIHtcbiAgICAgICAgaWYgKG9yZGVyZWQuX2ZsYWdzLnByZXNlbmNlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICByZXF1aXJlZE9yZGVyZWRzLnB1c2gob3JkZXJlZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVxdWlyZWRPcmRlcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgaW50ZXJuYWxzLmZpbGxNaXNzZWRFcnJvcnMoc2NoZW1hLCBlcnJvcnMsIHJlcXVpcmVkT3JkZXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmZpbGxEZWZhdWx0ID0gZnVuY3Rpb24gKG9yZGVyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBjb25zdCBvdmVycmlkZXMgPSBbXTtcbiAgICBsZXQgdHJhaWxpbmdVbmRlZmluZWQgPSB0cnVlO1xuXG4gICAgZm9yIChsZXQgaSA9IG9yZGVyZWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IG9yZGVyZWQgPSBvcmRlcmVkc1tpXTtcbiAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdO1xuICAgICAgICBjb25zdCBvdmVycmlkZSA9IG9yZGVyZWQuJF92YWxpZGF0ZSh1bmRlZmluZWQsIHN0YXRlLmxvY2FsaXplKHN0YXRlLnBhdGgsIGFuY2VzdG9ycywgb3JkZXJlZCksIHByZWZzKS52YWx1ZTtcblxuICAgICAgICBpZiAodHJhaWxpbmdVbmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyYWlsaW5nVW5kZWZpbmVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvdmVycmlkZXMudW5zaGlmdChvdmVycmlkZSk7XG4gICAgfVxuXG4gICAgaWYgKG92ZXJyaWRlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUucHVzaCguLi5vdmVycmlkZXMpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmZhc3RTcGxpY2UgPSBmdW5jdGlvbiAoYXJyLCBpKSB7XG5cbiAgICBsZXQgcG9zID0gaTtcbiAgICB3aGlsZSAocG9zIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICBhcnJbcG9zKytdID0gYXJyW3Bvc107XG4gICAgfVxuXG4gICAgLS1hcnIubGVuZ3RoO1xufTtcblxuXG5pbnRlcm5hbHMudmFsaWRhdGVTaW5nbGUgPSBmdW5jdGlvbiAodHlwZSwgb2JqKSB7XG5cbiAgICBpZiAodHlwZS50eXBlID09PSAnYXJyYXknIHx8XG4gICAgICAgIHR5cGUuX2ZsYWdzLl9hcnJheUl0ZW1zKSB7XG5cbiAgICAgICAgQXNzZXJ0KCFvYmouX2ZsYWdzLnNpbmdsZSwgJ0Nhbm5vdCBzcGVjaWZ5IGFycmF5IGl0ZW0gd2l0aCBzaW5nbGUgcnVsZSBlbmFibGVkJyk7XG4gICAgICAgIG9iai4kX3NldEZsYWcoJ19hcnJheUl0ZW1zJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuc29ydCA9IGZ1bmN0aW9uIChzY2hlbWEsIHZhbHVlLCBzZXR0aW5ncywgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBjb25zdCBvcmRlciA9IHNldHRpbmdzLm9yZGVyID09PSAnYXNjZW5kaW5nJyA/IDEgOiAtMTtcbiAgICBjb25zdCBhRmlyc3QgPSAtMSAqIG9yZGVyO1xuICAgIGNvbnN0IGJGaXJzdCA9IG9yZGVyO1xuXG4gICAgY29uc3Qgc29ydCA9IChhLCBiKSA9PiB7XG5cbiAgICAgICAgbGV0IGNvbXBhcmUgPSBpbnRlcm5hbHMuY29tcGFyZShhLCBiLCBhRmlyc3QsIGJGaXJzdCk7XG4gICAgICAgIGlmIChjb21wYXJlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5ieSkge1xuICAgICAgICAgICAgYSA9IHNldHRpbmdzLmJ5LnJlc29sdmUoYSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgIGIgPSBzZXR0aW5ncy5ieS5yZXNvbHZlKGIsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wYXJlID0gaW50ZXJuYWxzLmNvbXBhcmUoYSwgYiwgYUZpcnN0LCBiRmlyc3QpO1xuICAgICAgICBpZiAoY29tcGFyZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIGE7XG4gICAgICAgIGlmICh0eXBlICE9PSB0eXBlb2YgYikge1xuICAgICAgICAgICAgdGhyb3cgc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FycmF5LnNvcnQubWlzbWF0Y2hpbmcnLCB2YWx1ZSwgbnVsbCwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgdGhyb3cgc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FycmF5LnNvcnQudW5zdXBwb3J0ZWQnLCB2YWx1ZSwgeyB0eXBlIH0sIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiAoYSAtIGIpICogb3JkZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYSA8IGIgPyBhRmlyc3QgOiBiRmlyc3Q7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZS5zbGljZSgpLnNvcnQoc29ydCkgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVyciB9O1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYiwgYUZpcnN0LCBiRmlyc3QpIHtcblxuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDE7ICAgICAgICAgICAvLyBBbHdheXMgbGFzdCByZWdhcmRsZXNzIG9mIHNvcnQgb3JkZXJcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMTsgICAgICAgICAgIC8vIEFsd2F5cyBsYXN0IHJlZ2FyZGxlc3Mgb2Ygc29ydCBvcmRlclxuICAgIH1cblxuICAgIGlmIChhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiRmlyc3Q7XG4gICAgfVxuXG4gICAgaWYgKGIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGFGaXJzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/types/array.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/types/binary.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/binary.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\n\nconst Any = __webpack_require__(/*! ./any */ \"./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"./node_modules/joi/lib/common.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'binary',\n\n    coerce: {\n        from: 'string',\n        method(value, { schema }) {\n\n            try {\n                return { value: Buffer.from(value, schema._flags.encoding) };\n            }\n            catch (ignoreErr) { }\n        }\n    },\n\n    validate(value, { error }) {\n\n        if (!Buffer.isBuffer(value)) {\n            return { value, errors: error('binary.base') };\n        }\n    },\n\n    rules: {\n        encoding: {\n            method(encoding) {\n\n                Assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\n                return this.$_setFlag('encoding', encoding);\n            }\n        },\n\n        length: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'length', method: 'length', args: { limit }, operator: '=' });\n            },\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(value.length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('binary.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                }\n            ]\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });\n            }\n        }\n    },\n\n    cast: {\n        string: {\n            from: (value) => Buffer.isBuffer(value),\n            to(value, helpers) {\n\n                return value.toString();\n            }\n        }\n    },\n\n    messages: {\n        'binary.base': '{{#label}} must be a buffer or a string',\n        'binary.length': '{{#label}} must be {{#limit}} bytes',\n        'binary.max': '{{#label}} must be less than or equal to {{#limit}} bytes',\n        'binary.min': '{{#label}} must be at least {{#limit}} bytes'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9iaW5hcnkuanM/YmNjNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0RBQXVCOztBQUU5QyxZQUFZLG1CQUFPLENBQUMsa0RBQU87QUFDM0IsZUFBZSxtQkFBTyxDQUFDLG1EQUFXOzs7QUFHbEM7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUzs7QUFFaEM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxLQUFLOztBQUVMLHFCQUFxQixRQUFROztBQUU3QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsdUNBQXVDLDBDQUEwQyxRQUFRLGlCQUFpQjtBQUMxRyxhQUFhO0FBQ2Isc0NBQXNDLFFBQVEsR0FBRyx1QkFBdUI7O0FBRXhFO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0QsMkJBQTJCO0FBQ25GLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsUUFBUSxrQkFBa0I7QUFDeEc7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsdUNBQXVDLHVDQUF1QyxRQUFRLGtCQUFrQjtBQUN4RztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEMsNEJBQTRCLFFBQVEsV0FBVyxRQUFRO0FBQ3ZELHlCQUF5QixRQUFRLGlDQUFpQyxRQUFRO0FBQzFFLHlCQUF5QixRQUFRLG9CQUFvQixRQUFRO0FBQzdEO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2JpbmFyeS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2JpbmFyeScsXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogJ3N0cmluZycsXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEgfSkge1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBCdWZmZXIuZnJvbSh2YWx1ZSwgc2NoZW1hLl9mbGFncy5lbmNvZGluZykgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVFcnIpIHsgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0pIHtcblxuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdiaW5hcnkuYmFzZScpIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcbiAgICAgICAgZW5jb2Rpbmc6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KEJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSwgJ0ludmFsaWQgZW5jb2Rpbmc6JywgZW5jb2RpbmcpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdlbmNvZGluZycsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2xlbmd0aCcsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc9JyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZSh2YWx1ZS5sZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdiaW5hcnkuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiBDb21tb24ubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluJywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz49JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIHN0cmluZzoge1xuICAgICAgICAgICAgZnJvbTogKHZhbHVlKSA9PiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdiaW5hcnkuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBidWZmZXIgb3IgYSBzdHJpbmcnLFxuICAgICAgICAnYmluYXJ5Lmxlbmd0aCc6ICd7eyNsYWJlbH19IG11c3QgYmUge3sjbGltaXR9fSBieXRlcycsXG4gICAgICAgICdiaW5hcnkubWF4JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fSBieXRlcycsXG4gICAgICAgICdiaW5hcnkubWluJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhdCBsZWFzdCB7eyNsaW1pdH19IGJ5dGVzJ1xuICAgIH1cbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/types/binary.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/types/boolean.js":
/*!***********************************************!*\
  !*** ./node_modules/joi/lib/types/boolean.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\n\nconst Any = __webpack_require__(/*! ./any */ \"./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"./node_modules/joi/lib/common.js\");\nconst Values = __webpack_require__(/*! ../values */ \"./node_modules/joi/lib/values.js\");\n\n\nconst internals = {};\n\n\ninternals.isBool = function (value) {\n\n    return typeof value === 'boolean';\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'boolean',\n\n    flags: {\n\n        sensitive: { default: false }\n    },\n\n    terms: {\n\n        falsy: {\n            init: null,\n            manifest: 'values'\n        },\n\n        truthy: {\n            init: null,\n            manifest: 'values'\n        }\n    },\n\n    coerce(value, { schema }) {\n\n        if (typeof value === 'boolean') {\n            return;\n        }\n\n        if (typeof value === 'string') {\n            const normalized = schema._flags.sensitive ? value : value.toLowerCase();\n            value = normalized === 'true' ? true : (normalized === 'false' ? false : value);\n        }\n\n        if (typeof value !== 'boolean') {\n            value = schema.$_terms.truthy && schema.$_terms.truthy.has(value, null, null, !schema._flags.sensitive) ||\n                (schema.$_terms.falsy && schema.$_terms.falsy.has(value, null, null, !schema._flags.sensitive) ? false : value);\n        }\n\n        return { value };\n    },\n\n    validate(value, { error }) {\n\n        if (typeof value !== 'boolean') {\n            return { value, errors: error('boolean.base') };\n        }\n    },\n\n    rules: {\n        truthy: {\n            method(...values) {\n\n                Common.verifyFlat(values, 'truthy');\n\n                const obj = this.clone();\n                obj.$_terms.truthy = obj.$_terms.truthy || new Values();\n\n                for (let i = 0; i < values.length; ++i) {\n                    const value = values[i];\n\n                    Assert(value !== undefined, 'Cannot call truthy with undefined');\n                    obj.$_terms.truthy.add(value);\n                }\n\n                return obj;\n            }\n        },\n\n        falsy: {\n            method(...values) {\n\n                Common.verifyFlat(values, 'falsy');\n\n                const obj = this.clone();\n                obj.$_terms.falsy = obj.$_terms.falsy || new Values();\n\n                for (let i = 0; i < values.length; ++i) {\n                    const value = values[i];\n\n                    Assert(value !== undefined, 'Cannot call falsy with undefined');\n                    obj.$_terms.falsy.add(value);\n                }\n\n                return obj;\n            }\n        },\n\n        sensitive: {\n            method(enabled = true) {\n\n                return this.$_setFlag('sensitive', enabled);\n            }\n        }\n    },\n\n    cast: {\n        number: {\n            from: internals.isBool,\n            to(value, helpers) {\n\n                return value ? 1 : 0;\n            }\n        },\n        string: {\n            from: internals.isBool,\n            to(value, helpers) {\n\n                return value ? 'true' : 'false';\n            }\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.truthy) {\n                obj = obj.truthy(...desc.truthy);\n            }\n\n            if (desc.falsy) {\n                obj = obj.falsy(...desc.falsy);\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'boolean.base': '{{#label}} must be a boolean'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9ib29sZWFuLmpzPzU5YTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLG9EQUF1Qjs7QUFFOUMsWUFBWSxtQkFBTyxDQUFDLGtEQUFPO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxtREFBVztBQUNsQyxlQUFlLG1CQUFPLENBQUMsbURBQVc7OztBQUdsQzs7O0FBR0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsbUJBQW1CLFNBQVM7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsS0FBSzs7QUFFTCxxQkFBcUIsUUFBUTs7QUFFN0I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQixtQkFBbUI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwrQkFBK0IsbUJBQW1CO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvYm9vbGVhbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IFZhbHVlcyA9IHJlcXVpcmUoJy4uL3ZhbHVlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5pc0Jvb2wgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdib29sZWFuJyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgc2Vuc2l0aXZlOiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBmYWxzeToge1xuICAgICAgICAgICAgaW5pdDogbnVsbCxcbiAgICAgICAgICAgIG1hbmlmZXN0OiAndmFsdWVzJ1xuICAgICAgICB9LFxuXG4gICAgICAgIHRydXRoeToge1xuICAgICAgICAgICAgaW5pdDogbnVsbCxcbiAgICAgICAgICAgIG1hbmlmZXN0OiAndmFsdWVzJ1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvZXJjZSh2YWx1ZSwgeyBzY2hlbWEgfSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBzY2hlbWEuX2ZsYWdzLnNlbnNpdGl2ZSA/IHZhbHVlIDogdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhbHVlID0gbm9ybWFsaXplZCA9PT0gJ3RydWUnID8gdHJ1ZSA6IChub3JtYWxpemVkID09PSAnZmFsc2UnID8gZmFsc2UgOiB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc2NoZW1hLiRfdGVybXMudHJ1dGh5ICYmIHNjaGVtYS4kX3Rlcm1zLnRydXRoeS5oYXModmFsdWUsIG51bGwsIG51bGwsICFzY2hlbWEuX2ZsYWdzLnNlbnNpdGl2ZSkgfHxcbiAgICAgICAgICAgICAgICAoc2NoZW1hLiRfdGVybXMuZmFsc3kgJiYgc2NoZW1hLiRfdGVybXMuZmFsc3kuaGFzKHZhbHVlLCBudWxsLCBudWxsLCAhc2NoZW1hLl9mbGFncy5zZW5zaXRpdmUpID8gZmFsc2UgOiB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignYm9vbGVhbi5iYXNlJykgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICB0cnV0aHk6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi52YWx1ZXMpIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHZhbHVlcywgJ3RydXRoeScpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnRydXRoeSA9IG9iai4kX3Rlcm1zLnRydXRoeSB8fCBuZXcgVmFsdWVzKCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjYWxsIHRydXRoeSB3aXRoIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy50cnV0aHkuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZhbHN5OiB7XG4gICAgICAgICAgICBtZXRob2QoLi4udmFsdWVzKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsICdmYWxzeScpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmZhbHN5ID0gb2JqLiRfdGVybXMuZmFsc3kgfHwgbmV3IFZhbHVlcygpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCBmYWxzeSB3aXRoIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5mYWxzeS5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2Vuc2l0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnc2Vuc2l0aXZlJywgZW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBudW1iZXI6IHtcbiAgICAgICAgICAgIGZyb206IGludGVybmFscy5pc0Jvb2wsXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZzoge1xuICAgICAgICAgICAgZnJvbTogaW50ZXJuYWxzLmlzQm9vbCxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnRydXRoeSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9iai50cnV0aHkoLi4uZGVzYy50cnV0aHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5mYWxzeSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9iai5mYWxzeSguLi5kZXNjLmZhbHN5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnYm9vbGVhbi5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIGJvb2xlYW4nXG4gICAgfVxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/types/boolean.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/types/date.js":
/*!********************************************!*\
  !*** ./node_modules/joi/lib/types/date.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\n\nconst Any = __webpack_require__(/*! ./any */ \"./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"./node_modules/joi/lib/common.js\");\nconst Template = __webpack_require__(/*! ../template */ \"./node_modules/joi/lib/template.js\");\n\n\nconst internals = {};\n\n\ninternals.isDate = function (value) {\n\n    return value instanceof Date;\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'date',\n\n    coerce: {\n        from: ['number', 'string'],\n        method(value, { schema }) {\n\n            return { value: internals.parse(value, schema._flags.format) || value };\n        }\n    },\n\n    validate(value, { schema, error, prefs }) {\n\n        if (value instanceof Date &&\n            !isNaN(value.getTime())) {\n\n            return;\n        }\n\n        const format = schema._flags.format;\n\n        if (!prefs.convert ||\n            !format ||\n            typeof value !== 'string') {\n\n            return { value, errors: error('date.base') };\n        }\n\n        return { value, errors: error('date.format', { format }) };\n    },\n\n    rules: {\n\n        compare: {\n            method: false,\n            validate(value, helpers, { date }, { name, operator, args }) {\n\n                const to = date === 'now' ? Date.now() : date.getTime();\n                if (Common.compare(value.getTime(), to, operator)) {\n                    return value;\n                }\n\n                return helpers.error('date.' + name, { limit: args.date, value });\n            },\n            args: [\n                {\n                    name: 'date',\n                    ref: true,\n                    normalize: (date) => {\n\n                        return date === 'now' ? date : internals.parse(date);\n                    },\n                    assert: (date) => date !== null,\n                    message: 'must have a valid date format'\n                }\n            ]\n        },\n\n        format: {\n            method(format) {\n\n                Assert(['iso', 'javascript', 'unix'].includes(format), 'Unknown date format', format);\n\n                return this.$_setFlag('format', format);\n            }\n        },\n\n        greater: {\n            method(date) {\n\n                return this.$_addRule({ name: 'greater', method: 'compare', args: { date }, operator: '>' });\n            }\n        },\n\n        iso: {\n            method() {\n\n                return this.format('iso');\n            }\n        },\n\n        less: {\n            method(date) {\n\n                return this.$_addRule({ name: 'less', method: 'compare', args: { date }, operator: '<' });\n            }\n        },\n\n        max: {\n            method(date) {\n\n                return this.$_addRule({ name: 'max', method: 'compare', args: { date }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(date) {\n\n                return this.$_addRule({ name: 'min', method: 'compare', args: { date }, operator: '>=' });\n            }\n        },\n\n        timestamp: {\n            method(type = 'javascript') {\n\n                Assert(['javascript', 'unix'].includes(type), '\"type\" must be one of \"javascript, unix\"');\n\n                return this.format(type);\n            }\n        }\n    },\n\n    cast: {\n        number: {\n            from: internals.isDate,\n            to(value, helpers) {\n\n                return value.getTime();\n            }\n        },\n        string: {\n            from: internals.isDate,\n            to(value, { prefs }) {\n\n                return Template.date(value, prefs);\n            }\n        }\n    },\n\n    messages: {\n        'date.base': '{{#label}} must be a valid date',\n        'date.format': '{{#label}} must be in {msg(\"date.format.\" + #format) || #format} format',\n        'date.greater': '{{#label}} must be greater than {{:#limit}}',\n        'date.less': '{{#label}} must be less than {{:#limit}}',\n        'date.max': '{{#label}} must be less than or equal to {{:#limit}}',\n        'date.min': '{{#label}} must be greater than or equal to {{:#limit}}',\n\n        // Messages used in date.format\n\n        'date.format.iso': 'ISO 8601 date',\n        'date.format.javascript': 'timestamp or number of milliseconds',\n        'date.format.unix': 'timestamp or number of seconds'\n    }\n});\n\n\n// Helpers\n\ninternals.parse = function (value, format) {\n\n    if (value instanceof Date) {\n        return value;\n    }\n\n    if (typeof value !== 'string' &&\n        (isNaN(value) || !isFinite(value))) {\n\n        return null;\n    }\n\n    if (/^\\s*$/.test(value)) {\n        return null;\n    }\n\n    // ISO\n\n    if (format === 'iso') {\n        if (!Common.isIsoDate(value)) {\n            return null;\n        }\n\n        return internals.date(value.toString());\n    }\n\n    // Normalize number string\n\n    const original = value;\n    if (typeof value === 'string' &&\n        /^[+-]?\\d+(\\.\\d+)?$/.test(value)) {\n\n        value = parseFloat(value);\n    }\n\n    // Timestamp\n\n    if (format) {\n        if (format === 'javascript') {\n            return internals.date(1 * value);        // Casting to number\n        }\n\n        if (format === 'unix') {\n            return internals.date(1000 * value);\n        }\n\n        if (typeof original === 'string') {\n            return null;\n        }\n    }\n\n    // Plain\n\n    return internals.date(value);\n};\n\n\ninternals.date = function (value) {\n\n    const date = new Date(value);\n    if (!isNaN(date.getTime())) {\n        return date;\n    }\n\n    return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9kYXRlLmpzPzkxMDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLG9EQUF1Qjs7QUFFOUMsWUFBWSxtQkFBTyxDQUFDLGtEQUFPO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxtREFBVztBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyx1REFBYTs7O0FBR3RDOzs7QUFHQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7O0FBRWhDLG9CQUFvQjtBQUNwQjtBQUNBLEtBQUs7O0FBRUwscUJBQXFCLHVCQUF1Qjs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7O0FBRUEsZ0JBQWdCLHNDQUFzQyxTQUFTO0FBQy9ELEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxPQUFPLEdBQUcsdUJBQXVCOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0QsMEJBQTBCO0FBQ2hGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsdUNBQXVDLDRDQUE0QyxPQUFPLGlCQUFpQjtBQUMzRztBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLHVDQUF1Qyx5Q0FBeUMsT0FBTyxpQkFBaUI7QUFDeEc7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsdUNBQXVDLHdDQUF3QyxPQUFPLGtCQUFrQjtBQUN4RztBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQSx1Q0FBdUMsd0NBQXdDLE9BQU8sa0JBQWtCO0FBQ3hHO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQywwQkFBMEIsUUFBUSxhQUFhLHlDQUF5QztBQUN4RiwyQkFBMkIsUUFBUSx3QkFBd0IsU0FBUztBQUNwRSx3QkFBd0IsUUFBUSxxQkFBcUIsU0FBUztBQUM5RCx1QkFBdUIsUUFBUSxpQ0FBaUMsU0FBUztBQUN6RSx1QkFBdUIsUUFBUSxvQ0FBb0MsU0FBUzs7QUFFNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9kYXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5pc0RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGU7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnZGF0ZScsXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogWydudW1iZXInLCAnc3RyaW5nJ10sXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEgfSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaW50ZXJuYWxzLnBhcnNlKHZhbHVlLCBzY2hlbWEuX2ZsYWdzLmZvcm1hdCkgfHwgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJlxuICAgICAgICAgICAgIWlzTmFOKHZhbHVlLmdldFRpbWUoKSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9ybWF0ID0gc2NoZW1hLl9mbGFncy5mb3JtYXQ7XG5cbiAgICAgICAgaWYgKCFwcmVmcy5jb252ZXJ0IHx8XG4gICAgICAgICAgICAhZm9ybWF0IHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdkYXRlLmJhc2UnKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ2RhdGUuZm9ybWF0JywgeyBmb3JtYXQgfSkgfTtcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBjb21wYXJlOiB7XG4gICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgZGF0ZSB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gZGF0ZSA9PT0gJ25vdycgPyBEYXRlLm5vdygpIDogZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKHZhbHVlLmdldFRpbWUoKSwgdG8sIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2RhdGUuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MuZGF0ZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2RhdGUnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZTogKGRhdGUpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGUgPT09ICdub3cnID8gZGF0ZSA6IGludGVybmFscy5wYXJzZShkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiAoZGF0ZSkgPT4gZGF0ZSAhPT0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgaGF2ZSBhIHZhbGlkIGRhdGUgZm9ybWF0J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChmb3JtYXQpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2lzbycsICdqYXZhc2NyaXB0JywgJ3VuaXgnXS5pbmNsdWRlcyhmb3JtYXQpLCAnVW5rbm93biBkYXRlIGZvcm1hdCcsIGZvcm1hdCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Zvcm1hdCcsIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ3JlYXRlcjoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdncmVhdGVyJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgZGF0ZSB9LCBvcGVyYXRvcjogJz4nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzbzoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KCdpc28nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsZXNzOiB7XG4gICAgICAgICAgICBtZXRob2QoZGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2xlc3MnLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBkYXRlIH0sIG9wZXJhdG9yOiAnPCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QoZGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGRhdGUgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QoZGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbicsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGRhdGUgfSwgb3BlcmF0b3I6ICc+PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdGltZXN0YW1wOiB7XG4gICAgICAgICAgICBtZXRob2QodHlwZSA9ICdqYXZhc2NyaXB0Jykge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KFsnamF2YXNjcmlwdCcsICd1bml4J10uaW5jbHVkZXModHlwZSksICdcInR5cGVcIiBtdXN0IGJlIG9uZSBvZiBcImphdmFzY3JpcHQsIHVuaXhcIicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgbnVtYmVyOiB7XG4gICAgICAgICAgICBmcm9tOiBpbnRlcm5hbHMuaXNEYXRlLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZzoge1xuICAgICAgICAgICAgZnJvbTogaW50ZXJuYWxzLmlzRGF0ZSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCB7IHByZWZzIH0pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZS5kYXRlKHZhbHVlLCBwcmVmcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2RhdGUuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBkYXRlJyxcbiAgICAgICAgJ2RhdGUuZm9ybWF0JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBpbiB7bXNnKFwiZGF0ZS5mb3JtYXQuXCIgKyAjZm9ybWF0KSB8fCAjZm9ybWF0fSBmb3JtYXQnLFxuICAgICAgICAnZGF0ZS5ncmVhdGVyJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBncmVhdGVyIHRoYW4ge3s6I2xpbWl0fX0nLFxuICAgICAgICAnZGF0ZS5sZXNzJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBsZXNzIHRoYW4ge3s6I2xpbWl0fX0nLFxuICAgICAgICAnZGF0ZS5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7ezojbGltaXR9fScsXG4gICAgICAgICdkYXRlLm1pbic6ICd7eyNsYWJlbH19IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHt7OiNsaW1pdH19JyxcblxuICAgICAgICAvLyBNZXNzYWdlcyB1c2VkIGluIGRhdGUuZm9ybWF0XG5cbiAgICAgICAgJ2RhdGUuZm9ybWF0Lmlzbyc6ICdJU08gODYwMSBkYXRlJyxcbiAgICAgICAgJ2RhdGUuZm9ybWF0LmphdmFzY3JpcHQnOiAndGltZXN0YW1wIG9yIG51bWJlciBvZiBtaWxsaXNlY29uZHMnLFxuICAgICAgICAnZGF0ZS5mb3JtYXQudW5peCc6ICd0aW1lc3RhbXAgb3IgbnVtYmVyIG9mIHNlY29uZHMnXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMucGFyc2UgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdCkge1xuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICgvXlxccyokLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJU09cblxuICAgIGlmIChmb3JtYXQgPT09ICdpc28nKSB7XG4gICAgICAgIGlmICghQ29tbW9uLmlzSXNvRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5kYXRlKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBudW1iZXIgc3RyaW5nXG5cbiAgICBjb25zdCBvcmlnaW5hbCA9IHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIC9eWystXT9cXGQrKFxcLlxcZCspPyQvLnRlc3QodmFsdWUpKSB7XG5cbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBUaW1lc3RhbXBcblxuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2phdmFzY3JpcHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRhdGUoMSAqIHZhbHVlKTsgICAgICAgIC8vIENhc3RpbmcgdG8gbnVtYmVyXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9ybWF0ID09PSAndW5peCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZSgxMDAwICogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGxhaW5cblxuICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZSh2YWx1ZSk7XG59O1xuXG5cbmludGVybmFscy5kYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIGlmICghaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/types/date.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/types/function.js":
/*!************************************************!*\
  !*** ./node_modules/joi/lib/types/function.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\n\nconst Keys = __webpack_require__(/*! ./keys */ \"./node_modules/joi/lib/types/keys.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = Keys.extend({\n\n    type: 'function',\n\n    properties: {\n        typeof: 'function'\n    },\n\n    rules: {\n        arity: {\n            method(n) {\n\n                Assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');\n\n                return this.$_addRule({ name: 'arity', args: { n } });\n            },\n            validate(value, helpers, { n }) {\n\n                if (value.length === n) {\n                    return value;\n                }\n\n                return helpers.error('function.arity', { n });\n            }\n        },\n\n        class: {\n            method() {\n\n                return this.$_addRule('class');\n            },\n            validate(value, helpers) {\n\n                if ((/^\\s*class\\s/).test(value.toString())) {\n                    return value;\n                }\n\n                return helpers.error('function.class', { value });\n            }\n        },\n\n        minArity: {\n            method(n) {\n\n                Assert(Number.isSafeInteger(n) && n > 0, 'n must be a strict positive integer');\n\n                return this.$_addRule({ name: 'minArity', args: { n } });\n            },\n            validate(value, helpers, { n }) {\n\n                if (value.length >= n) {\n                    return value;\n                }\n\n                return helpers.error('function.minArity', { n });\n            }\n        },\n\n        maxArity: {\n            method(n) {\n\n                Assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');\n\n                return this.$_addRule({ name: 'maxArity', args: { n } });\n            },\n            validate(value, helpers, { n }) {\n\n                if (value.length <= n) {\n                    return value;\n                }\n\n                return helpers.error('function.maxArity', { n });\n            }\n        }\n    },\n\n    messages: {\n        'function.arity': '{{#label}} must have an arity of {{#n}}',\n        'function.class': '{{#label}} must be a class',\n        'function.maxArity': '{{#label}} must have an arity lesser or equal to {{#n}}',\n        'function.minArity': '{{#label}} must have an arity greater or equal to {{#n}}'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9mdW5jdGlvbi5qcz8yZWY5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxvREFBdUI7O0FBRTlDLGFBQWEsbUJBQU8sQ0FBQyxvREFBUTs7O0FBRzdCOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUNBQXVDLHVCQUF1QixJQUFJLEVBQUU7QUFDcEUsYUFBYTtBQUNiLHNDQUFzQyxJQUFJOztBQUUxQztBQUNBO0FBQ0E7O0FBRUEsd0RBQXdELElBQUk7QUFDNUQ7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBLHVDQUF1QywwQkFBMEIsSUFBSSxFQUFFO0FBQ3ZFLGFBQWE7QUFDYixzQ0FBc0MsSUFBSTs7QUFFMUM7QUFDQTtBQUNBOztBQUVBLDJEQUEyRCxJQUFJO0FBQy9EO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBLHVDQUF1QywwQkFBMEIsSUFBSSxFQUFFO0FBQ3ZFLGFBQWE7QUFDYixzQ0FBc0MsSUFBSTs7QUFFMUM7QUFDQTtBQUNBOztBQUVBLDJEQUEyRCxJQUFJO0FBQy9EO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsNkJBQTZCLFFBQVEseUJBQXlCLElBQUk7QUFDbEUsNkJBQTZCLFFBQVE7QUFDckMsZ0NBQWdDLFFBQVEseUNBQXlDLElBQUk7QUFDckYsZ0NBQWdDLFFBQVEsMENBQTBDLElBQUk7QUFDdEY7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvZnVuY3Rpb24uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBLZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBLZXlzLmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICB0eXBlb2Y6ICdmdW5jdGlvbidcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcbiAgICAgICAgYXJpdHk6IHtcbiAgICAgICAgICAgIG1ldGhvZChuKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobikgJiYgbiA+PSAwLCAnbiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2FyaXR5JywgYXJnczogeyBuIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbiB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignZnVuY3Rpb24uYXJpdHknLCB7IG4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnY2xhc3MnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKCgvXlxccypjbGFzc1xccy8pLnRlc3QodmFsdWUudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdmdW5jdGlvbi5jbGFzcycsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluQXJpdHk6IHtcbiAgICAgICAgICAgIG1ldGhvZChuKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobikgJiYgbiA+IDAsICduIG11c3QgYmUgYSBzdHJpY3QgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbkFyaXR5JywgYXJnczogeyBuIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbiB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdmdW5jdGlvbi5taW5Bcml0eScsIHsgbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXhBcml0eToge1xuICAgICAgICAgICAgbWV0aG9kKG4pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID49IDAsICduIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWF4QXJpdHknLCBhcmdzOiB7IG4gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBuIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2Z1bmN0aW9uLm1heEFyaXR5JywgeyBuIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdmdW5jdGlvbi5hcml0eSc6ICd7eyNsYWJlbH19IG11c3QgaGF2ZSBhbiBhcml0eSBvZiB7eyNufX0nLFxuICAgICAgICAnZnVuY3Rpb24uY2xhc3MnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgY2xhc3MnLFxuICAgICAgICAnZnVuY3Rpb24ubWF4QXJpdHknOiAne3sjbGFiZWx9fSBtdXN0IGhhdmUgYW4gYXJpdHkgbGVzc2VyIG9yIGVxdWFsIHRvIHt7I259fScsXG4gICAgICAgICdmdW5jdGlvbi5taW5Bcml0eSc6ICd7eyNsYWJlbH19IG11c3QgaGF2ZSBhbiBhcml0eSBncmVhdGVyIG9yIGVxdWFsIHRvIHt7I259fSdcbiAgICB9XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/types/function.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/types/keys.js":
/*!********************************************!*\
  !*** ./node_modules/joi/lib/types/keys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst ApplyToDefaults = __webpack_require__(/*! @hapi/hoek/lib/applyToDefaults */ \"@hapi/hoek/lib/applyToDefaults\");\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"@hapi/hoek/lib/clone\");\nconst Topo = __webpack_require__(/*! @hapi/topo */ \"@hapi/topo\");\n\nconst Any = __webpack_require__(/*! ./any */ \"./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ../compile */ \"./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"./node_modules/joi/lib/errors.js\");\nconst Ref = __webpack_require__(/*! ../ref */ \"./node_modules/joi/lib/ref.js\");\nconst Template = __webpack_require__(/*! ../template */ \"./node_modules/joi/lib/template.js\");\n\n\nconst internals = {\n    renameDefaults: {\n        alias: false,                   // Keep old value in place\n        multiple: false,                // Allow renaming multiple keys into the same target\n        override: false                 // Overrides an existing key\n    }\n};\n\n\nmodule.exports = Any.extend({\n\n    type: '_keys',\n\n    properties: {\n\n        typeof: 'object'\n    },\n\n    flags: {\n\n        unknown: { default: false }\n    },\n\n    terms: {\n\n        dependencies: { init: null },\n        keys: { init: null, manifest: { mapped: { from: 'schema', to: 'key' } } },\n        patterns: { init: null },\n        renames: { init: null }\n    },\n\n    args(schema, keys) {\n\n        return schema.keys(keys);\n    },\n\n    validate(value, { schema, error, state, prefs }) {\n\n        if (!value ||\n            typeof value !== schema.$_property('typeof') ||\n            Array.isArray(value)) {\n\n            return { value, errors: error('object.base', { type: schema.$_property('typeof') }) };\n        }\n\n        // Skip if there are no other rules to test\n\n        if (!schema.$_terms.renames &&\n            !schema.$_terms.dependencies &&\n            !schema.$_terms.keys &&                       // null allows any keys\n            !schema.$_terms.patterns &&\n            !schema.$_terms.externals) {\n\n            return;\n        }\n\n        // Shallow clone value\n\n        value = internals.clone(value, prefs);\n        const errors = [];\n\n        // Rename keys\n\n        if (schema.$_terms.renames &&\n            !internals.rename(schema, value, state, prefs, errors)) {\n\n            return { value, errors };\n        }\n\n        // Anything allowed\n\n        if (!schema.$_terms.keys &&                       // null allows any keys\n            !schema.$_terms.patterns &&\n            !schema.$_terms.dependencies) {\n\n            return { value, errors };\n        }\n\n        // Defined keys\n\n        const unprocessed = new Set(Object.keys(value));\n\n        if (schema.$_terms.keys) {\n            const ancestors = [value, ...state.ancestors];\n\n            for (const child of schema.$_terms.keys) {\n                const key = child.key;\n                const item = value[key];\n\n                unprocessed.delete(key);\n\n                const localState = state.localize([...state.path, key], ancestors, child);\n                const result = child.schema.$_validate(item, localState, prefs);\n\n                if (result.errors) {\n                    if (prefs.abortEarly) {\n                        return { value, errors: result.errors };\n                    }\n\n                    if (result.value !== undefined) {\n                        value[key] = result.value;\n                    }\n\n                    errors.push(...result.errors);\n                }\n                else if (child.schema._flags.result === 'strip' ||\n                    result.value === undefined && item !== undefined) {\n\n                    delete value[key];\n                }\n                else if (result.value !== undefined) {\n                    value[key] = result.value;\n                }\n            }\n        }\n\n        // Unknown keys\n\n        if (unprocessed.size ||\n            schema._flags._hasPatternMatch) {\n\n            const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);\n            if (early) {\n                return early;\n            }\n        }\n\n        // Validate dependencies\n\n        if (schema.$_terms.dependencies) {\n            for (const dep of schema.$_terms.dependencies) {\n                if (dep.key &&\n                    dep.key.resolve(value, state, prefs, null, { shadow: false }) === undefined) {\n\n                    continue;\n                }\n\n                const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);\n                if (failed) {\n                    const report = schema.$_createError(failed.code, value, failed.context, state, prefs);\n                    if (prefs.abortEarly) {\n                        return { value, errors: report };\n                    }\n\n                    errors.push(report);\n                }\n            }\n        }\n\n        return { value, errors };\n    },\n\n    rules: {\n\n        and: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'and');\n\n                return internals.dependency(this, 'and', null, peers);\n            }\n        },\n\n        append: {\n            method(schema) {\n\n                if (schema === null ||\n                    schema === undefined ||\n                    Object.keys(schema).length === 0) {\n\n                    return this;\n                }\n\n                return this.keys(schema);\n            }\n        },\n\n        assert: {\n            method(subject, schema, message) {\n\n                if (!Template.isTemplate(subject)) {\n                    subject = Compile.ref(subject);\n                }\n\n                Assert(message === undefined || typeof message === 'string', 'Message must be a string');\n\n                schema = this.$_compile(schema, { appendPath: true });\n\n                const obj = this.$_addRule({ name: 'assert', args: { subject, schema, message } });\n                obj.$_mutateRegister(subject);\n                obj.$_mutateRegister(schema);\n                return obj;\n            },\n            validate(value, { error, prefs, state }, { subject, schema, message }) {\n\n                const about = subject.resolve(value, state, prefs);\n                const path = Ref.isRef(subject) ? subject.absolute(state) : [];\n                if (schema.$_match(about, state.localize(path, [value, ...state.ancestors], schema), prefs)) {\n                    return value;\n                }\n\n                return error('object.assert', { subject, message });\n            },\n            args: ['subject', 'schema', 'message'],\n            multi: true\n        },\n\n        instance: {\n            method(constructor, name) {\n\n                Assert(typeof constructor === 'function', 'constructor must be a function');\n\n                name = name || constructor.name;\n\n                return this.$_addRule({ name: 'instance', args: { constructor, name } });\n            },\n            validate(value, helpers, { constructor, name }) {\n\n                if (value instanceof constructor) {\n                    return value;\n                }\n\n                return helpers.error('object.instance', { type: name, value });\n            },\n            args: ['constructor', 'name']\n        },\n\n        keys: {\n            method(schema) {\n\n                Assert(schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n                Assert(!Common.isSchema(schema), 'Object schema cannot be a joi schema');\n\n                const obj = this.clone();\n\n                if (!schema) {                                      // Allow all\n                    obj.$_terms.keys = null;\n                }\n                else if (!Object.keys(schema).length) {             // Allow none\n                    obj.$_terms.keys = new internals.Keys();\n                }\n                else {\n                    obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys();\n                    for (const key in schema) {\n                        Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);\n                    }\n                }\n\n                return obj.$_mutateRebuild();\n            }\n        },\n\n        length: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });\n            },\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(Object.keys(value).length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('object.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                }\n            ]\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });\n            }\n        },\n\n        nand: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'nand');\n\n                return internals.dependency(this, 'nand', null, peers);\n            }\n        },\n\n        or: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'or');\n\n                return internals.dependency(this, 'or', null, peers);\n            }\n        },\n\n        oxor: {\n            method(...peers /*, [options] */) {\n\n                return internals.dependency(this, 'oxor', null, peers);\n            }\n        },\n\n        pattern: {\n            method(pattern, schema, options = {}) {\n\n                const isRegExp = pattern instanceof RegExp;\n                if (!isRegExp) {\n                    pattern = this.$_compile(pattern, { appendPath: true });\n                }\n\n                Assert(schema !== undefined, 'Invalid rule');\n                Common.assertOptions(options, ['fallthrough', 'matches']);\n\n                if (isRegExp) {\n                    Assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n                }\n\n                schema = this.$_compile(schema, { appendPath: true });\n\n                const obj = this.clone();\n                obj.$_terms.patterns = obj.$_terms.patterns || [];\n                const config = { [isRegExp ? 'regex' : 'schema']: pattern, rule: schema };\n                if (options.matches) {\n                    config.matches = this.$_compile(options.matches);\n                    if (config.matches.type !== 'array') {\n                        config.matches = config.matches.$_root.array().items(config.matches);\n                    }\n\n                    obj.$_mutateRegister(config.matches);\n                    obj.$_setFlag('_hasPatternMatch', true, { clone: false });\n                }\n\n                if (options.fallthrough) {\n                    config.fallthrough = true;\n                }\n\n                obj.$_terms.patterns.push(config);\n                obj.$_mutateRegister(schema);\n                return obj;\n            }\n        },\n\n        ref: {\n            method() {\n\n                return this.$_addRule('ref');\n            },\n            validate(value, helpers) {\n\n                if (Ref.isRef(value)) {\n                    return value;\n                }\n\n                return helpers.error('object.refType', { value });\n            }\n        },\n\n        regex: {\n            method() {\n\n                return this.$_addRule('regex');\n            },\n            validate(value, helpers) {\n\n                if (value instanceof RegExp) {\n                    return value;\n                }\n\n                return helpers.error('object.regex', { value });\n            }\n        },\n\n        rename: {\n            method(from, to, options = {}) {\n\n                Assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n                Assert(typeof to === 'string' || to instanceof Template, 'Invalid rename to argument');\n                Assert(to !== from, 'Cannot rename key to same name:', from);\n\n                Common.assertOptions(options, ['alias', 'ignoreUndefined', 'override', 'multiple']);\n\n                const obj = this.clone();\n\n                obj.$_terms.renames = obj.$_terms.renames || [];\n                for (const rename of obj.$_terms.renames) {\n                    Assert(rename.from !== from, 'Cannot rename the same key multiple times');\n                }\n\n                if (to instanceof Template) {\n                    obj.$_mutateRegister(to);\n                }\n\n                obj.$_terms.renames.push({\n                    from,\n                    to,\n                    options: ApplyToDefaults(internals.renameDefaults, options)\n                });\n\n                return obj;\n            }\n        },\n\n        schema: {\n            method(type = 'any') {\n\n                return this.$_addRule({ name: 'schema', args: { type } });\n            },\n            validate(value, helpers, { type }) {\n\n                if (Common.isSchema(value) &&\n                    (type === 'any' || value.type === type)) {\n\n                    return value;\n                }\n\n                return helpers.error('object.schema', { type });\n            }\n        },\n\n        unknown: {\n            method(allow) {\n\n                return this.$_setFlag('unknown', allow !== false);\n            }\n        },\n\n        with: {\n            method(key, peers, options = {}) {\n\n                return internals.dependency(this, 'with', key, peers, options);\n            }\n        },\n\n        without: {\n            method(key, peers, options = {}) {\n\n                return internals.dependency(this, 'without', key, peers, options);\n            }\n        },\n\n        xor: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'xor');\n\n                return internals.dependency(this, 'xor', null, peers);\n            }\n        }\n    },\n\n    overrides: {\n\n        default(value, options) {\n\n            if (value === undefined) {\n                value = Common.symbols.deepDefault;\n            }\n\n            return this.$_parent('default', value, options);\n        }\n    },\n\n    rebuild(schema) {\n\n        if (schema.$_terms.keys) {\n            const topo = new Topo.Sorter();\n            for (const child of schema.$_terms.keys) {\n                Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);\n            }\n\n            schema.$_terms.keys = new internals.Keys(...topo.nodes);\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.keys) {\n                obj = obj.keys(desc.keys);\n            }\n\n            if (desc.dependencies) {\n                for (const { rel, key = null, peers, options } of desc.dependencies) {\n                    obj = internals.dependency(obj, rel, key, peers, options);\n                }\n            }\n\n            if (desc.patterns) {\n                for (const { regex, schema, rule, fallthrough, matches } of desc.patterns) {\n                    obj = obj.pattern(regex || schema, rule, { fallthrough, matches });\n                }\n            }\n\n            if (desc.renames) {\n                for (const { from, to, options } of desc.renames) {\n                    obj = obj.rename(from, to, options);\n                }\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'object.and': '{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}',\n        'object.assert': '{{#label}} is invalid because {if(#subject.key, `\"` + #subject.key + `\" failed to ` + (#message || \"pass the assertion test\"), #message || \"the assertion failed\")}',\n        'object.base': '{{#label}} must be of type {{#type}}',\n        'object.instance': '{{#label}} must be an instance of {{:#type}}',\n        'object.length': '{{#label}} must have {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        'object.max': '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        'object.min': '{{#label}} must have at least {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        'object.missing': '{{#label}} must contain at least one of {{#peersWithLabels}}',\n        'object.nand': '{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}',\n        'object.oxor': '{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}',\n        'object.pattern.match': '{{#label}} keys failed to match pattern requirements',\n        'object.refType': '{{#label}} must be a Joi reference',\n        'object.regex': '{{#label}} must be a RegExp object',\n        'object.rename.multiple': '{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}',\n        'object.rename.override': '{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists',\n        'object.schema': '{{#label}} must be a Joi schema of {{#type}} type',\n        'object.unknown': '{{#label}} is not allowed',\n        'object.with': '{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}',\n        'object.without': '{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}',\n        'object.xor': '{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}'\n    }\n});\n\n\n// Helpers\n\ninternals.clone = function (value, prefs) {\n\n    // Object\n\n    if (typeof value === 'object') {\n        if (prefs.nonEnumerables) {\n            return Clone(value, { shallow: true });\n        }\n\n        const clone = Object.create(Object.getPrototypeOf(value));\n        Object.assign(clone, value);\n        return clone;\n    }\n\n    // Function\n\n    const clone = function (...args) {\n\n        return value.apply(this, args);\n    };\n\n    clone.prototype = Clone(value.prototype);\n    Object.defineProperty(clone, 'name', { value: value.name, writable: false });\n    Object.defineProperty(clone, 'length', { value: value.length, writable: false });\n    Object.assign(clone, value);\n    return clone;\n};\n\n\ninternals.dependency = function (schema, rel, key, peers, options) {\n\n    Assert(key === null || typeof key === 'string', rel, 'key must be a strings');\n\n    // Extract options from peers array\n\n    if (!options) {\n        options = peers.length > 1 && typeof peers[peers.length - 1] === 'object' ? peers.pop() : {};\n    }\n\n    Common.assertOptions(options, ['separator']);\n\n    peers = [].concat(peers);\n\n    // Cast peer paths\n\n    const separator = Common.default(options.separator, '.');\n    const paths = [];\n    for (const peer of peers) {\n        Assert(typeof peer === 'string', rel, 'peers must be strings');\n        paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));\n    }\n\n    // Cast key\n\n    if (key !== null) {\n        key = Compile.ref(key, { separator, ancestor: 0, prefix: false });\n    }\n\n    // Add rule\n\n    const obj = schema.clone();\n    obj.$_terms.dependencies = obj.$_terms.dependencies || [];\n    obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));\n    return obj;\n};\n\n\ninternals.dependencies = {\n\n    and(schema, dep, value, state, prefs) {\n\n        const missing = [];\n        const present = [];\n        const count = dep.peers.length;\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) === undefined) {\n                missing.push(peer.key);\n            }\n            else {\n                present.push(peer.key);\n            }\n        }\n\n        if (missing.length !== count &&\n            present.length !== count) {\n\n            return {\n                code: 'object.and',\n                context: {\n                    present,\n                    presentWithLabels: internals.keysToLabels(schema, present),\n                    missing,\n                    missingWithLabels: internals.keysToLabels(schema, missing)\n                }\n            };\n        }\n    },\n\n    nand(schema, dep, value, state, prefs) {\n\n        const present = [];\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                present.push(peer.key);\n            }\n        }\n\n        if (present.length !== dep.peers.length) {\n            return;\n        }\n\n        const main = dep.paths[0];\n        const values = dep.paths.slice(1);\n        return {\n            code: 'object.nand',\n            context: {\n                main,\n                mainWithLabel: internals.keysToLabels(schema, main),\n                peers: values,\n                peersWithLabels: internals.keysToLabels(schema, values)\n            }\n        };\n    },\n\n    or(schema, dep, value, state, prefs) {\n\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                return;\n            }\n        }\n\n        return {\n            code: 'object.missing',\n            context: {\n                peers: dep.paths,\n                peersWithLabels: internals.keysToLabels(schema, dep.paths)\n            }\n        };\n    },\n\n    oxor(schema, dep, value, state, prefs) {\n\n        const present = [];\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                present.push(peer.key);\n            }\n        }\n\n        if (!present.length ||\n            present.length === 1) {\n\n            return;\n        }\n\n        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };\n        context.present = present;\n        context.presentWithLabels = internals.keysToLabels(schema, present);\n        return { code: 'object.oxor', context };\n    },\n\n    with(schema, dep, value, state, prefs) {\n\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) === undefined) {\n                return {\n                    code: 'object.with',\n                    context: {\n                        main: dep.key.key,\n                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),\n                        peer: peer.key,\n                        peerWithLabel: internals.keysToLabels(schema, peer.key)\n                    }\n                };\n            }\n        }\n    },\n\n    without(schema, dep, value, state, prefs) {\n\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                return {\n                    code: 'object.without',\n                    context: {\n                        main: dep.key.key,\n                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),\n                        peer: peer.key,\n                        peerWithLabel: internals.keysToLabels(schema, peer.key)\n                    }\n                };\n            }\n        }\n    },\n\n    xor(schema, dep, value, state, prefs) {\n\n        const present = [];\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                present.push(peer.key);\n            }\n        }\n\n        if (present.length === 1) {\n            return;\n        }\n\n        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };\n        if (present.length === 0) {\n            return { code: 'object.missing', context };\n        }\n\n        context.present = present;\n        context.presentWithLabels = internals.keysToLabels(schema, present);\n        return { code: 'object.xor', context };\n    }\n};\n\n\ninternals.keysToLabels = function (schema, keys) {\n\n    if (Array.isArray(keys)) {\n        return keys.map((key) => schema.$_mapLabels(key));\n    }\n\n    return schema.$_mapLabels(keys);\n};\n\n\ninternals.rename = function (schema, value, state, prefs, errors) {\n\n    const renamed = {};\n    for (const rename of schema.$_terms.renames) {\n        const matches = [];\n        const pattern = typeof rename.from !== 'string';\n\n        if (!pattern) {\n            if (Object.prototype.hasOwnProperty.call(value, rename.from) &&\n                (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {\n\n                matches.push(rename);\n            }\n        }\n        else {\n            for (const from in value) {\n                if (value[from] === undefined &&\n                    rename.options.ignoreUndefined) {\n\n                    continue;\n                }\n\n                if (from === rename.to) {\n                    continue;\n                }\n\n                const match = rename.from.exec(from);\n                if (!match) {\n                    continue;\n                }\n\n                matches.push({ from, to: rename.to, match });\n            }\n        }\n\n        for (const match of matches) {\n            const from = match.from;\n            let to = match.to;\n            if (to instanceof Template) {\n                to = to.render(value, state, prefs, match.match);\n            }\n\n            if (from === to) {\n                continue;\n            }\n\n            if (!rename.options.multiple &&\n                renamed[to]) {\n\n                errors.push(schema.$_createError('object.rename.multiple', value, { from, to, pattern }, state, prefs));\n                if (prefs.abortEarly) {\n                    return false;\n                }\n            }\n\n            if (Object.prototype.hasOwnProperty.call(value, to) &&\n                !rename.options.override &&\n                !renamed[to]) {\n\n                errors.push(schema.$_createError('object.rename.override', value, { from, to, pattern }, state, prefs));\n                if (prefs.abortEarly) {\n                    return false;\n                }\n            }\n\n            if (value[from] === undefined) {\n                delete value[to];\n            }\n            else {\n                value[to] = value[from];\n            }\n\n            renamed[to] = true;\n\n            if (!rename.options.alias) {\n                delete value[from];\n            }\n        }\n    }\n\n    return true;\n};\n\n\ninternals.unknown = function (schema, value, unprocessed, errors, state, prefs) {\n\n    if (schema.$_terms.patterns) {\n        let hasMatches = false;\n        const matches = schema.$_terms.patterns.map((pattern) => {\n\n            if (pattern.matches) {\n                hasMatches = true;\n                return [];\n            }\n        });\n\n        const ancestors = [value, ...state.ancestors];\n\n        for (const key of unprocessed) {\n            const item = value[key];\n            const path = [...state.path, key];\n\n            for (let i = 0; i < schema.$_terms.patterns.length; ++i) {\n                const pattern = schema.$_terms.patterns[i];\n                if (pattern.regex) {\n                    const match = pattern.regex.test(key);\n                    state.mainstay.tracer.debug(state, 'rule', `pattern.${i}`, match ? 'pass' : 'error');\n                    if (!match) {\n                        continue;\n                    }\n                }\n                else {\n                    if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {\n                        continue;\n                    }\n                }\n\n                unprocessed.delete(key);\n\n                const localState = state.localize(path, ancestors, { schema: pattern.rule, key });\n                const result = pattern.rule.$_validate(item, localState, prefs);\n                if (result.errors) {\n                    if (prefs.abortEarly) {\n                        return { value, errors: result.errors };\n                    }\n\n                    errors.push(...result.errors);\n                }\n\n                if (pattern.matches) {\n                    matches[i].push(key);\n                }\n\n                value[key] = result.value;\n                if (!pattern.fallthrough) {\n                    break;\n                }\n            }\n        }\n\n        // Validate pattern matches rules\n\n        if (hasMatches) {\n            for (let i = 0; i < matches.length; ++i) {\n                const match = matches[i];\n                if (!match) {\n                    continue;\n                }\n\n                const stpm = schema.$_terms.patterns[i].matches;\n                const localState = state.localize(state.path, ancestors, stpm);\n                const result = stpm.$_validate(match, localState, prefs);\n                if (result.errors) {\n                    const details = Errors.details(result.errors, { override: false });\n                    details.matches = match;\n                    const report = schema.$_createError('object.pattern.match', value, details, state, prefs);\n                    if (prefs.abortEarly) {\n                        return { value, errors: report };\n                    }\n\n                    errors.push(report);\n                }\n            }\n        }\n    }\n\n    if (!unprocessed.size ||\n        !schema.$_terms.keys && !schema.$_terms.patterns) {     // If no keys or patterns specified, unknown keys allowed\n\n        return;\n    }\n\n    if (prefs.stripUnknown && !schema._flags.unknown ||\n        prefs.skipFunctions) {\n\n        const stripUnknown = prefs.stripUnknown ? (prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects) : false;\n\n        for (const key of unprocessed) {\n            if (stripUnknown) {\n                delete value[key];\n                unprocessed.delete(key);\n            }\n            else if (typeof value[key] === 'function') {\n                unprocessed.delete(key);\n            }\n        }\n    }\n\n    const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);\n    if (forbidUnknown) {\n        for (const unprocessedKey of unprocessed) {\n            const localState = state.localize([...state.path, unprocessedKey], []);\n            const report = schema.$_createError('object.unknown', value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });\n            if (prefs.abortEarly) {\n                return { value, errors: report };\n            }\n\n            errors.push(report);\n        }\n    }\n};\n\n\ninternals.Dependency = class {\n\n    constructor(rel, key, peers, paths) {\n\n        this.rel = rel;\n        this.key = key;\n        this.peers = peers;\n        this.paths = paths;\n    }\n\n    describe() {\n\n        const desc = {\n            rel: this.rel,\n            peers: this.paths\n        };\n\n        if (this.key !== null) {\n            desc.key = this.key.key;\n        }\n\n        if (this.peers[0].separator !== '.') {\n            desc.options = { separator: this.peers[0].separator };\n        }\n\n        return desc;\n    }\n};\n\n\ninternals.Keys = class extends Array {\n\n    concat(source) {\n\n        const result = this.slice();\n\n        const keys = new Map();\n        for (let i = 0; i < result.length; ++i) {\n            keys.set(result[i].key, i);\n        }\n\n        for (const item of source) {\n            const key = item.key;\n            const pos = keys.get(key);\n            if (pos !== undefined) {\n                result[pos] = { key, schema: result[pos].schema.concat(item.schema) };\n            }\n            else {\n                result.push(item);\n            }\n        }\n\n        return result;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9rZXlzLmpzPzEzM2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsd0JBQXdCLG1CQUFPLENBQUMsc0VBQWdDO0FBQ2hFLGVBQWUsbUJBQU8sQ0FBQyxvREFBdUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLGtEQUFzQjtBQUM1QyxhQUFhLG1CQUFPLENBQUMsOEJBQVk7O0FBRWpDLFlBQVksbUJBQU8sQ0FBQyxrREFBTztBQUMzQixlQUFlLG1CQUFPLENBQUMsbURBQVc7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMscURBQVk7QUFDcEMsZUFBZSxtQkFBTyxDQUFDLG1EQUFXO0FBQ2xDLFlBQVksbUJBQU8sQ0FBQyw2Q0FBUTtBQUM1QixpQkFBaUIsbUJBQU8sQ0FBQyx1REFBYTs7O0FBR3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsa0JBQWtCO0FBQ2xCLEtBQUs7O0FBRUw7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEMsZUFBZSx3QkFBd0IsVUFBVSw0QkFBNEIsRUFBRSxFQUFFO0FBQ2pGLG1CQUFtQixhQUFhO0FBQ2hDLGtCQUFrQjtBQUNsQixLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTCxxQkFBcUIsOEJBQThCOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHNDQUFzQyxvQ0FBb0M7QUFDOUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FB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QUVBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9rZXlzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBcHBseVRvRGVmYXVsdHMgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hcHBseVRvRGVmYXVsdHMnKTtcbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgVG9wbyA9IHJlcXVpcmUoJ0BoYXBpL3RvcG8nKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgQ29tcGlsZSA9IHJlcXVpcmUoJy4uL2NvbXBpbGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi4vcmVmJyk7XG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHJlbmFtZURlZmF1bHRzOiB7XG4gICAgICAgIGFsaWFzOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBvbGQgdmFsdWUgaW4gcGxhY2VcbiAgICAgICAgbXVsdGlwbGU6IGZhbHNlLCAgICAgICAgICAgICAgICAvLyBBbGxvdyByZW5hbWluZyBtdWx0aXBsZSBrZXlzIGludG8gdGhlIHNhbWUgdGFyZ2V0XG4gICAgICAgIG92ZXJyaWRlOiBmYWxzZSAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGVzIGFuIGV4aXN0aW5nIGtleVxuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdfa2V5cycsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgICAgdHlwZW9mOiAnb2JqZWN0J1xuICAgIH0sXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHVua25vd246IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGRlcGVuZGVuY2llczogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIGtleXM6IHsgaW5pdDogbnVsbCwgbWFuaWZlc3Q6IHsgbWFwcGVkOiB7IGZyb206ICdzY2hlbWEnLCB0bzogJ2tleScgfSB9IH0sXG4gICAgICAgIHBhdHRlcm5zOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgcmVuYW1lczogeyBpbml0OiBudWxsIH1cbiAgICB9LFxuXG4gICAgYXJncyhzY2hlbWEsIGtleXMpIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hLmtleXMoa2V5cyk7XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IsIHN0YXRlLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgaWYgKCF2YWx1ZSB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSBzY2hlbWEuJF9wcm9wZXJ0eSgndHlwZW9mJykgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdvYmplY3QuYmFzZScsIHsgdHlwZTogc2NoZW1hLiRfcHJvcGVydHkoJ3R5cGVvZicpIH0pIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTa2lwIGlmIHRoZXJlIGFyZSBubyBvdGhlciBydWxlcyB0byB0ZXN0XG5cbiAgICAgICAgaWYgKCFzY2hlbWEuJF90ZXJtcy5yZW5hbWVzICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMuZGVwZW5kZW5jaWVzICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMua2V5cyAmJiAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVsbCBhbGxvd3MgYW55IGtleXNcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucyAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmV4dGVybmFscykge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaGFsbG93IGNsb25lIHZhbHVlXG5cbiAgICAgICAgdmFsdWUgPSBpbnRlcm5hbHMuY2xvbmUodmFsdWUsIHByZWZzKTtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgICAgICAgLy8gUmVuYW1lIGtleXNcblxuICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMucmVuYW1lcyAmJlxuICAgICAgICAgICAgIWludGVybmFscy5yZW5hbWUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzLCBlcnJvcnMpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFueXRoaW5nIGFsbG93ZWRcblxuICAgICAgICBpZiAoIXNjaGVtYS4kX3Rlcm1zLmtleXMgJiYgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bGwgYWxsb3dzIGFueSBrZXlzXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMucGF0dGVybnMgJiZcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5kZXBlbmRlbmNpZXMpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9ycyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lZCBrZXlzXG5cbiAgICAgICAgY29uc3QgdW5wcm9jZXNzZWQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHZhbHVlKSk7XG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLmtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBzY2hlbWEuJF90ZXJtcy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGtleV0sIGFuY2VzdG9ycywgY2hpbGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoaWxkLnNjaGVtYS4kX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIHByZWZzKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXN1bHQuZXJyb3JzIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQuc2NoZW1hLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcgfHxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID09PSB1bmRlZmluZWQgJiYgaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5rbm93biBrZXlzXG5cbiAgICAgICAgaWYgKHVucHJvY2Vzc2VkLnNpemUgfHxcbiAgICAgICAgICAgIHNjaGVtYS5fZmxhZ3MuX2hhc1BhdHRlcm5NYXRjaCkge1xuXG4gICAgICAgICAgICBjb25zdCBlYXJseSA9IGludGVybmFscy51bmtub3duKHNjaGVtYSwgdmFsdWUsIHVucHJvY2Vzc2VkLCBlcnJvcnMsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBpZiAoZWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFybHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBkZXBlbmRlbmNpZXNcblxuICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcCBvZiBzY2hlbWEuJF90ZXJtcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwLmtleSAmJlxuICAgICAgICAgICAgICAgICAgICBkZXAua2V5LnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsZWQgPSBpbnRlcm5hbHMuZGVwZW5kZW5jaWVzW2RlcC5yZWxdKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAoZmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKGZhaWxlZC5jb2RlLCB2YWx1ZSwgZmFpbGVkLmNvbnRleHQsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXBvcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9ycyB9O1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGFuZDoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHBlZXJzLCAnYW5kJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ2FuZCcsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhcHBlbmQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChzY2hlbWEpIHtcblxuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXNzZXJ0OiB7XG4gICAgICAgICAgICBtZXRob2Qoc3ViamVjdCwgc2NoZW1hLCBtZXNzYWdlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIVRlbXBsYXRlLmlzVGVtcGxhdGUoc3ViamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdCA9IENvbXBpbGUucmVmKHN1YmplY3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChtZXNzYWdlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnLCAnTWVzc2FnZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLiRfY29tcGlsZShzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2Fzc2VydCcsIGFyZ3M6IHsgc3ViamVjdCwgc2NoZW1hLCBtZXNzYWdlIH0gfSk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc3ViamVjdCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yLCBwcmVmcywgc3RhdGUgfSwgeyBzdWJqZWN0LCBzY2hlbWEsIG1lc3NhZ2UgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYWJvdXQgPSBzdWJqZWN0LnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IFJlZi5pc1JlZihzdWJqZWN0KSA/IHN1YmplY3QuYWJzb2x1dGUoc3RhdGUpIDogW107XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS4kX21hdGNoKGFib3V0LCBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc10sIHNjaGVtYSksIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdvYmplY3QuYXNzZXJ0JywgeyBzdWJqZWN0LCBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnc3ViamVjdCcsICdzY2hlbWEnLCAnbWVzc2FnZSddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBpbnN0YW5jZToge1xuICAgICAgICAgICAgbWV0aG9kKGNvbnN0cnVjdG9yLCBuYW1lKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nLCAnY29uc3RydWN0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2luc3RhbmNlJywgYXJnczogeyBjb25zdHJ1Y3RvciwgbmFtZSB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGNvbnN0cnVjdG9yLCBuYW1lIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignb2JqZWN0Lmluc3RhbmNlJywgeyB0eXBlOiBuYW1lLCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2NvbnN0cnVjdG9yJywgJ25hbWUnXVxuICAgICAgICB9LFxuXG4gICAgICAgIGtleXM6IHtcbiAgICAgICAgICAgIG1ldGhvZChzY2hlbWEpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChzY2hlbWEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygc2NoZW1hID09PSAnb2JqZWN0JywgJ09iamVjdCBzY2hlbWEgbXVzdCBiZSBhIHZhbGlkIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSksICdPYmplY3Qgc2NoZW1hIGNhbm5vdCBiZSBhIGpvaSBzY2hlbWEnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGlmICghc2NoZW1hKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBhbGxcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMua2V5cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCkgeyAgICAgICAgICAgICAvLyBBbGxvdyBub25lXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmtleXMgPSBuZXcgaW50ZXJuYWxzLktleXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmtleXMgPSBvYmouJF90ZXJtcy5rZXlzID8gb2JqLiRfdGVybXMua2V5cy5maWx0ZXIoKGNoaWxkKSA9PiAhc2NoZW1hLmhhc093blByb3BlcnR5KGNoaWxkLmtleSkpIDogbmV3IGludGVybmFscy5LZXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ29tbW9uLnRyeVdpdGhQYXRoKCgpID0+IG9iai4kX3Rlcm1zLmtleXMucHVzaCh7IGtleSwgc2NoZW1hOiB0aGlzLiRfY29tcGlsZShzY2hlbWFba2V5XSkgfSksIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz0nIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3QuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiBDb21tb24ubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluJywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz49JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBuYW5kOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4ucGVlcnMgLyosIFtvcHRpb25zXSAqLykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQocGVlcnMsICduYW5kJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ25hbmQnLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3I6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChwZWVycywgJ29yJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ29yJywgbnVsbCwgcGVlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG94b3I6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ294b3InLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF0dGVybjoge1xuICAgICAgICAgICAgbWV0aG9kKHBhdHRlcm4sIHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlZ0V4cCA9IHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1JlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy4kX2NvbXBpbGUocGF0dGVybiwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChzY2hlbWEgIT09IHVuZGVmaW5lZCwgJ0ludmFsaWQgcnVsZScpO1xuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnZmFsbHRocm91Z2gnLCAnbWF0Y2hlcyddKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc1JlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIXBhdHRlcm4uZmxhZ3MuaW5jbHVkZXMoJ2cnKSAmJiAhcGF0dGVybi5mbGFncy5pbmNsdWRlcygneScpLCAncGF0dGVybiBzaG91bGQgbm90IHVzZSBnbG9iYWwgb3Igc3RpY2t5IG1vZGUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLiRfY29tcGlsZShzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5wYXR0ZXJucyA9IG9iai4kX3Rlcm1zLnBhdHRlcm5zIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHsgW2lzUmVnRXhwID8gJ3JlZ2V4JyA6ICdzY2hlbWEnXTogcGF0dGVybiwgcnVsZTogc2NoZW1hIH07XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcubWF0Y2hlcyA9IHRoaXMuJF9jb21waWxlKG9wdGlvbnMubWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubWF0Y2hlcy50eXBlICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcubWF0Y2hlcyA9IGNvbmZpZy5tYXRjaGVzLiRfcm9vdC5hcnJheSgpLml0ZW1zKGNvbmZpZy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKGNvbmZpZy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfc2V0RmxhZygnX2hhc1BhdHRlcm5NYXRjaCcsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZhbGx0aHJvdWdoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5mYWxsdGhyb3VnaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucGF0dGVybnMucHVzaChjb25maWcpO1xuICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZWY6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgncmVmJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChSZWYuaXNSZWYodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignb2JqZWN0LnJlZlR5cGUnLCB7IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ3JlZ2V4Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ29iamVjdC5yZWdleCcsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuYW1lOiB7XG4gICAgICAgICAgICBtZXRob2QoZnJvbSwgdG8sIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyB8fCBmcm9tIGluc3RhbmNlb2YgUmVnRXhwLCAnUmVuYW1lIG1pc3NpbmcgdGhlIGZyb20gYXJndW1lbnQnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHRvID09PSAnc3RyaW5nJyB8fCB0byBpbnN0YW5jZW9mIFRlbXBsYXRlLCAnSW52YWxpZCByZW5hbWUgdG8gYXJndW1lbnQnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodG8gIT09IGZyb20sICdDYW5ub3QgcmVuYW1lIGtleSB0byBzYW1lIG5hbWU6JywgZnJvbSk7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsaWFzJywgJ2lnbm9yZVVuZGVmaW5lZCcsICdvdmVycmlkZScsICdtdWx0aXBsZSddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlbmFtZXMgPSBvYmouJF90ZXJtcy5yZW5hbWVzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVuYW1lIG9mIG9iai4kX3Rlcm1zLnJlbmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHJlbmFtZS5mcm9tICE9PSBmcm9tLCAnQ2Fubm90IHJlbmFtZSB0aGUgc2FtZSBrZXkgbXVsdGlwbGUgdGltZXMnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodG8gaW5zdGFuY2VvZiBUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3Rlcih0byk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucmVuYW1lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IEFwcGx5VG9EZWZhdWx0cyhpbnRlcm5hbHMucmVuYW1lRGVmYXVsdHMsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgbWV0aG9kKHR5cGUgPSAnYW55Jykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3NjaGVtYScsIGFyZ3M6IHsgdHlwZSB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IHR5cGUgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5pc1NjaGVtYSh2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT09ICdhbnknIHx8IHZhbHVlLnR5cGUgPT09IHR5cGUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3Quc2NoZW1hJywgeyB0eXBlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVua25vd246IHtcbiAgICAgICAgICAgIG1ldGhvZChhbGxvdykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCd1bmtub3duJywgYWxsb3cgIT09IGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3aXRoOiB7XG4gICAgICAgICAgICBtZXRob2Qoa2V5LCBwZWVycywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ3dpdGgnLCBrZXksIHBlZXJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3aXRob3V0OiB7XG4gICAgICAgICAgICBtZXRob2Qoa2V5LCBwZWVycywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ3dpdGhvdXQnLCBrZXksIHBlZXJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB4b3I6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChwZWVycywgJ3hvcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kZXBlbmRlbmN5KHRoaXMsICd4b3InLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb3ZlcnJpZGVzOiB7XG5cbiAgICAgICAgZGVmYXVsdCh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gQ29tbW9uLnN5bWJvbHMuZGVlcERlZmF1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRfcGFyZW50KCdkZWZhdWx0JywgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlYnVpbGQoc2NoZW1hKSB7XG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLmtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcG8gPSBuZXcgVG9wby5Tb3J0ZXIoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygc2NoZW1hLiRfdGVybXMua2V5cykge1xuICAgICAgICAgICAgICAgIENvbW1vbi50cnlXaXRoUGF0aCgoKSA9PiB0b3BvLmFkZChjaGlsZCwgeyBhZnRlcjogY2hpbGQuc2NoZW1hLiRfcm9vdFJlZmVyZW5jZXMoKSwgZ3JvdXA6IGNoaWxkLmtleSB9KSwgY2hpbGQua2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMua2V5cyA9IG5ldyBpbnRlcm5hbHMuS2V5cyguLi50b3BvLm5vZGVzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLmtleXMoZGVzYy5rZXlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlbCwga2V5ID0gbnVsbCwgcGVlcnMsIG9wdGlvbnMgfSBvZiBkZXNjLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBpbnRlcm5hbHMuZGVwZW5kZW5jeShvYmosIHJlbCwga2V5LCBwZWVycywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5wYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyByZWdleCwgc2NoZW1hLCBydWxlLCBmYWxsdGhyb3VnaCwgbWF0Y2hlcyB9IG9mIGRlc2MucGF0dGVybnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLnBhdHRlcm4ocmVnZXggfHwgc2NoZW1hLCBydWxlLCB7IGZhbGx0aHJvdWdoLCBtYXRjaGVzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MucmVuYW1lcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBmcm9tLCB0bywgb3B0aW9ucyB9IG9mIGRlc2MucmVuYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoucmVuYW1lKGZyb20sIHRvLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ29iamVjdC5hbmQnOiAne3sjbGFiZWx9fSBjb250YWlucyB7eyNwcmVzZW50V2l0aExhYmVsc319IHdpdGhvdXQgaXRzIHJlcXVpcmVkIHBlZXJzIHt7I21pc3NpbmdXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0LmFzc2VydCc6ICd7eyNsYWJlbH19IGlzIGludmFsaWQgYmVjYXVzZSB7aWYoI3N1YmplY3Qua2V5LCBgXCJgICsgI3N1YmplY3Qua2V5ICsgYFwiIGZhaWxlZCB0byBgICsgKCNtZXNzYWdlIHx8IFwicGFzcyB0aGUgYXNzZXJ0aW9uIHRlc3RcIiksICNtZXNzYWdlIHx8IFwidGhlIGFzc2VydGlvbiBmYWlsZWRcIil9JyxcbiAgICAgICAgJ29iamVjdC5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBvZiB0eXBlIHt7I3R5cGV9fScsXG4gICAgICAgICdvYmplY3QuaW5zdGFuY2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHt7OiN0eXBlfX0nLFxuICAgICAgICAnb2JqZWN0Lmxlbmd0aCc6ICd7eyNsYWJlbH19IG11c3QgaGF2ZSB7eyNsaW1pdH19IGtleXtpZigjbGltaXQgPT0gMSwgXCJcIiwgXCJzXCIpfScsXG4gICAgICAgICdvYmplY3QubWF4JzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19IGtleXtpZigjbGltaXQgPT0gMSwgXCJcIiwgXCJzXCIpfScsXG4gICAgICAgICdvYmplY3QubWluJzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGF0IGxlYXN0IHt7I2xpbWl0fX0ga2V5e2lmKCNsaW1pdCA9PSAxLCBcIlwiLCBcInNcIil9JyxcbiAgICAgICAgJ29iamVjdC5taXNzaW5nJzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBvZiB7eyNwZWVyc1dpdGhMYWJlbHN9fScsXG4gICAgICAgICdvYmplY3QubmFuZCc6ICd7ezojbWFpbldpdGhMYWJlbH19IG11c3Qgbm90IGV4aXN0IHNpbXVsdGFuZW91c2x5IHdpdGgge3sjcGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0Lm94b3InOiAne3sjbGFiZWx9fSBjb250YWlucyBhIGNvbmZsaWN0IGJldHdlZW4gb3B0aW9uYWwgZXhjbHVzaXZlIHBlZXJzIHt7I3BlZXJzV2l0aExhYmVsc319JyxcbiAgICAgICAgJ29iamVjdC5wYXR0ZXJuLm1hdGNoJzogJ3t7I2xhYmVsfX0ga2V5cyBmYWlsZWQgdG8gbWF0Y2ggcGF0dGVybiByZXF1aXJlbWVudHMnLFxuICAgICAgICAnb2JqZWN0LnJlZlR5cGUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgSm9pIHJlZmVyZW5jZScsXG4gICAgICAgICdvYmplY3QucmVnZXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgUmVnRXhwIG9iamVjdCcsXG4gICAgICAgICdvYmplY3QucmVuYW1lLm11bHRpcGxlJzogJ3t7I2xhYmVsfX0gY2Fubm90IHJlbmFtZSB7ezojZnJvbX19IGJlY2F1c2UgbXVsdGlwbGUgcmVuYW1lcyBhcmUgZGlzYWJsZWQgYW5kIGFub3RoZXIga2V5IHdhcyBhbHJlYWR5IHJlbmFtZWQgdG8ge3s6I3RvfX0nLFxuICAgICAgICAnb2JqZWN0LnJlbmFtZS5vdmVycmlkZSc6ICd7eyNsYWJlbH19IGNhbm5vdCByZW5hbWUge3s6I2Zyb219fSBiZWNhdXNlIG92ZXJyaWRlIGlzIGRpc2FibGVkIGFuZCB0YXJnZXQge3s6I3RvfX0gZXhpc3RzJyxcbiAgICAgICAgJ29iamVjdC5zY2hlbWEnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgSm9pIHNjaGVtYSBvZiB7eyN0eXBlfX0gdHlwZScsXG4gICAgICAgICdvYmplY3QudW5rbm93bic6ICd7eyNsYWJlbH19IGlzIG5vdCBhbGxvd2VkJyxcbiAgICAgICAgJ29iamVjdC53aXRoJzogJ3t7OiNtYWluV2l0aExhYmVsfX0gbWlzc2luZyByZXF1aXJlZCBwZWVyIHt7OiNwZWVyV2l0aExhYmVsfX0nLFxuICAgICAgICAnb2JqZWN0LndpdGhvdXQnOiAne3s6I21haW5XaXRoTGFiZWx9fSBjb25mbGljdCB3aXRoIGZvcmJpZGRlbiBwZWVyIHt7OiNwZWVyV2l0aExhYmVsfX0nLFxuICAgICAgICAnb2JqZWN0Lnhvcic6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGEgY29uZmxpY3QgYmV0d2VlbiBleGNsdXNpdmUgcGVlcnMge3sjcGVlcnNXaXRoTGFiZWxzfX0nXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuY2xvbmUgPSBmdW5jdGlvbiAodmFsdWUsIHByZWZzKSB7XG5cbiAgICAvLyBPYmplY3RcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChwcmVmcy5ub25FbnVtZXJhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuIENsb25lKHZhbHVlLCB7IHNoYWxsb3c6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY2xvbmUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIC8vIEZ1bmN0aW9uXG5cbiAgICBjb25zdCBjbG9uZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjbG9uZS5wcm90b3R5cGUgPSBDbG9uZSh2YWx1ZS5wcm90b3R5cGUpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9uZSwgJ25hbWUnLCB7IHZhbHVlOiB2YWx1ZS5uYW1lLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb25lLCAnbGVuZ3RoJywgeyB2YWx1ZTogdmFsdWUubGVuZ3RoLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihjbG9uZSwgdmFsdWUpO1xuICAgIHJldHVybiBjbG9uZTtcbn07XG5cblxuaW50ZXJuYWxzLmRlcGVuZGVuY3kgPSBmdW5jdGlvbiAoc2NoZW1hLCByZWwsIGtleSwgcGVlcnMsIG9wdGlvbnMpIHtcblxuICAgIEFzc2VydChrZXkgPT09IG51bGwgfHwgdHlwZW9mIGtleSA9PT0gJ3N0cmluZycsIHJlbCwgJ2tleSBtdXN0IGJlIGEgc3RyaW5ncycpO1xuXG4gICAgLy8gRXh0cmFjdCBvcHRpb25zIGZyb20gcGVlcnMgYXJyYXlcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gcGVlcnMubGVuZ3RoID4gMSAmJiB0eXBlb2YgcGVlcnNbcGVlcnMubGVuZ3RoIC0gMV0gPT09ICdvYmplY3QnID8gcGVlcnMucG9wKCkgOiB7fTtcbiAgICB9XG5cbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ3NlcGFyYXRvciddKTtcblxuICAgIHBlZXJzID0gW10uY29uY2F0KHBlZXJzKTtcblxuICAgIC8vIENhc3QgcGVlciBwYXRoc1xuXG4gICAgY29uc3Qgc2VwYXJhdG9yID0gQ29tbW9uLmRlZmF1bHQob3B0aW9ucy5zZXBhcmF0b3IsICcuJyk7XG4gICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBlZXIgb2YgcGVlcnMpIHtcbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBwZWVyID09PSAnc3RyaW5nJywgcmVsLCAncGVlcnMgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgICAgIHBhdGhzLnB1c2goQ29tcGlsZS5yZWYocGVlciwgeyBzZXBhcmF0b3IsIGFuY2VzdG9yOiAwLCBwcmVmaXg6IGZhbHNlIH0pKTtcbiAgICB9XG5cbiAgICAvLyBDYXN0IGtleVxuXG4gICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICBrZXkgPSBDb21waWxlLnJlZihrZXksIHsgc2VwYXJhdG9yLCBhbmNlc3RvcjogMCwgcHJlZml4OiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcnVsZVxuXG4gICAgY29uc3Qgb2JqID0gc2NoZW1hLmNsb25lKCk7XG4gICAgb2JqLiRfdGVybXMuZGVwZW5kZW5jaWVzID0gb2JqLiRfdGVybXMuZGVwZW5kZW5jaWVzIHx8IFtdO1xuICAgIG9iai4kX3Rlcm1zLmRlcGVuZGVuY2llcy5wdXNoKG5ldyBpbnRlcm5hbHMuRGVwZW5kZW5jeShyZWwsIGtleSwgcGF0aHMsIHBlZXJzKSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuaW50ZXJuYWxzLmRlcGVuZGVuY2llcyA9IHtcblxuICAgIGFuZChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgICAgICBjb25zdCBjb3VudCA9IGRlcC5wZWVycy5sZW5ndGg7XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCAhPT0gY291bnQgJiZcbiAgICAgICAgICAgIHByZXNlbnQubGVuZ3RoICE9PSBjb3VudCkge1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGU6ICdvYmplY3QuYW5kJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlbnRXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCksXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmcsXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmdXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgbWlzc2luZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG5hbmQoc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBwcmVzZW50ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwcmVzZW50LnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXNlbnQubGVuZ3RoICE9PSBkZXAucGVlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYWluID0gZGVwLnBhdGhzWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBkZXAucGF0aHMuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiAnb2JqZWN0Lm5hbmQnLFxuICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgIG1haW4sXG4gICAgICAgICAgICAgICAgbWFpbldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIG1haW4pLFxuICAgICAgICAgICAgICAgIHBlZXJzOiB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgdmFsdWVzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBvcihzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogJ29iamVjdC5taXNzaW5nJyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICBwZWVyczogZGVwLnBhdGhzLFxuICAgICAgICAgICAgICAgIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIGRlcC5wYXRocylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgb3hvcihzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IHByZXNlbnQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByZXNlbnQucHVzaChwZWVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByZXNlbnQubGVuZ3RoIHx8XG4gICAgICAgICAgICBwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZXh0ID0geyBwZWVyczogZGVwLnBhdGhzLCBwZWVyc1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAucGF0aHMpIH07XG4gICAgICAgIGNvbnRleHQucHJlc2VudCA9IHByZXNlbnQ7XG4gICAgICAgIGNvbnRleHQucHJlc2VudFdpdGhMYWJlbHMgPSBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCk7XG4gICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3Qub3hvcicsIGNvbnRleHQgfTtcbiAgICB9LFxuXG4gICAgd2l0aChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAnb2JqZWN0LndpdGgnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBkZXAua2V5LmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5XaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAua2V5LmtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyOiBwZWVyLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJXaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBwZWVyLmtleSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd2l0aG91dChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAnb2JqZWN0LndpdGhvdXQnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBkZXAua2V5LmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5XaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAua2V5LmtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyOiBwZWVyLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJXaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBwZWVyLmtleSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgeG9yKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGV4dCA9IHsgcGVlcnM6IGRlcC5wYXRocywgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgZGVwLnBhdGhzKSB9O1xuICAgICAgICBpZiAocHJlc2VudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3QubWlzc2luZycsIGNvbnRleHQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQucHJlc2VudCA9IHByZXNlbnQ7XG4gICAgICAgIGNvbnRleHQucHJlc2VudFdpdGhMYWJlbHMgPSBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCk7XG4gICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3QueG9yJywgY29udGV4dCB9O1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmtleXNUb0xhYmVscyA9IGZ1bmN0aW9uIChzY2hlbWEsIGtleXMpIHtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgIHJldHVybiBrZXlzLm1hcCgoa2V5KSA9PiBzY2hlbWEuJF9tYXBMYWJlbHMoa2V5KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS4kX21hcExhYmVscyhrZXlzKTtcbn07XG5cblxuaW50ZXJuYWxzLnJlbmFtZSA9IGZ1bmN0aW9uIChzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGVycm9ycykge1xuXG4gICAgY29uc3QgcmVuYW1lZCA9IHt9O1xuICAgIGZvciAoY29uc3QgcmVuYW1lIG9mIHNjaGVtYS4kX3Rlcm1zLnJlbmFtZXMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gdHlwZW9mIHJlbmFtZS5mcm9tICE9PSAnc3RyaW5nJztcblxuICAgICAgICBpZiAoIXBhdHRlcm4pIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHJlbmFtZS5mcm9tKSAmJlxuICAgICAgICAgICAgICAgICh2YWx1ZVtyZW5hbWUuZnJvbV0gIT09IHVuZGVmaW5lZCB8fCAhcmVuYW1lLm9wdGlvbnMuaWdub3JlVW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHJlbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyb20gaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbZnJvbV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICByZW5hbWUub3B0aW9ucy5pZ25vcmVVbmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PT0gcmVuYW1lLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVuYW1lLmZyb20uZXhlYyhmcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaCh7IGZyb20sIHRvOiByZW5hbWUudG8sIG1hdGNoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tID0gbWF0Y2guZnJvbTtcbiAgICAgICAgICAgIGxldCB0byA9IG1hdGNoLnRvO1xuICAgICAgICAgICAgaWYgKHRvIGluc3RhbmNlb2YgVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICB0byA9IHRvLnJlbmRlcih2YWx1ZSwgc3RhdGUsIHByZWZzLCBtYXRjaC5tYXRjaCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlbmFtZS5vcHRpb25zLm11bHRpcGxlICYmXG4gICAgICAgICAgICAgICAgcmVuYW1lZFt0b10pIHtcblxuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdvYmplY3QucmVuYW1lLm11bHRpcGxlJywgdmFsdWUsIHsgZnJvbSwgdG8sIHBhdHRlcm4gfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgdG8pICYmXG4gICAgICAgICAgICAgICAgIXJlbmFtZS5vcHRpb25zLm92ZXJyaWRlICYmXG4gICAgICAgICAgICAgICAgIXJlbmFtZWRbdG9dKSB7XG5cbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignb2JqZWN0LnJlbmFtZS5vdmVycmlkZScsIHZhbHVlLCB7IGZyb20sIHRvLCBwYXR0ZXJuIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZVtmcm9tXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW3RvXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlW3RvXSA9IHZhbHVlW2Zyb21dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5hbWVkW3RvXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghcmVuYW1lLm9wdGlvbnMuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVbZnJvbV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuaW50ZXJuYWxzLnVua25vd24gPSBmdW5jdGlvbiAoc2NoZW1hLCB2YWx1ZSwgdW5wcm9jZXNzZWQsIGVycm9ycywgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBpZiAoc2NoZW1hLiRfdGVybXMucGF0dGVybnMpIHtcbiAgICAgICAgbGV0IGhhc01hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zLm1hcCgocGF0dGVybikgPT4ge1xuXG4gICAgICAgICAgICBpZiAocGF0dGVybi5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgaGFzTWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc107XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IFsuLi5zdGF0ZS5wYXRoLCBrZXldO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuLnJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcGF0dGVybi5yZWdleC50ZXN0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5kZWJ1ZyhzdGF0ZSwgJ3J1bGUnLCBgcGF0dGVybi4ke2l9YCwgbWF0Y2ggPyAncGFzcycgOiAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGF0dGVybi5zY2hlbWEuJF9tYXRjaChrZXksIHN0YXRlLm5lc3QocGF0dGVybi5zY2hlbWEsIGBwYXR0ZXJuLiR7aX1gKSwgcHJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgeyBzY2hlbWE6IHBhdHRlcm4ucnVsZSwga2V5IH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhdHRlcm4ucnVsZS4kX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmVzdWx0LmVycm9ycyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4ubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzW2ldLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghcGF0dGVybi5mYWxsdGhyb3VnaCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBwYXR0ZXJuIG1hdGNoZXMgcnVsZXNcblxuICAgICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RwbSA9IHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zW2ldLm1hdGNoZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKHN0YXRlLnBhdGgsIGFuY2VzdG9ycywgc3RwbSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3RwbS4kX3ZhbGlkYXRlKG1hdGNoLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGV0YWlscyA9IEVycm9ycy5kZXRhaWxzKHJlc3VsdC5lcnJvcnMsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLm1hdGNoZXMgPSBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ29iamVjdC5wYXR0ZXJuLm1hdGNoJywgdmFsdWUsIGRldGFpbHMsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXBvcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1bnByb2Nlc3NlZC5zaXplIHx8XG4gICAgICAgICFzY2hlbWEuJF90ZXJtcy5rZXlzICYmICFzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucykgeyAgICAgLy8gSWYgbm8ga2V5cyBvciBwYXR0ZXJucyBzcGVjaWZpZWQsIHVua25vd24ga2V5cyBhbGxvd2VkXG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcmVmcy5zdHJpcFVua25vd24gJiYgIXNjaGVtYS5fZmxhZ3MudW5rbm93biB8fFxuICAgICAgICBwcmVmcy5za2lwRnVuY3Rpb25zKSB7XG5cbiAgICAgICAgY29uc3Qgc3RyaXBVbmtub3duID0gcHJlZnMuc3RyaXBVbmtub3duID8gKHByZWZzLnN0cmlwVW5rbm93biA9PT0gdHJ1ZSA/IHRydWUgOiAhIXByZWZzLnN0cmlwVW5rbm93bi5vYmplY3RzKSA6IGZhbHNlO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBpZiAoc3RyaXBVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWVba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZm9yYmlkVW5rbm93biA9ICFDb21tb24uZGVmYXVsdChzY2hlbWEuX2ZsYWdzLnVua25vd24sIHByZWZzLmFsbG93VW5rbm93bik7XG4gICAgaWYgKGZvcmJpZFVua25vd24pIHtcbiAgICAgICAgZm9yIChjb25zdCB1bnByb2Nlc3NlZEtleSBvZiB1bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCB1bnByb2Nlc3NlZEtleV0sIFtdKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdvYmplY3QudW5rbm93bicsIHZhbHVlW3VucHJvY2Vzc2VkS2V5XSwgeyBjaGlsZDogdW5wcm9jZXNzZWRLZXkgfSwgbG9jYWxTdGF0ZSwgcHJlZnMsIHsgZmxhZ3M6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXBvcnQgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLkRlcGVuZGVuY3kgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWwsIGtleSwgcGVlcnMsIHBhdGhzKSB7XG5cbiAgICAgICAgdGhpcy5yZWwgPSByZWw7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnBlZXJzID0gcGVlcnM7XG4gICAgICAgIHRoaXMucGF0aHMgPSBwYXRocztcbiAgICB9XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBjb25zdCBkZXNjID0ge1xuICAgICAgICAgICAgcmVsOiB0aGlzLnJlbCxcbiAgICAgICAgICAgIHBlZXJzOiB0aGlzLnBhdGhzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMua2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkZXNjLmtleSA9IHRoaXMua2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBlZXJzWzBdLnNlcGFyYXRvciAhPT0gJy4nKSB7XG4gICAgICAgICAgICBkZXNjLm9wdGlvbnMgPSB7IHNlcGFyYXRvcjogdGhpcy5wZWVyc1swXS5zZXBhcmF0b3IgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLktleXMgPSBjbGFzcyBleHRlbmRzIEFycmF5IHtcblxuICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNsaWNlKCk7XG5cbiAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGtleXMuc2V0KHJlc3VsdFtpXS5rZXksIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gaXRlbS5rZXk7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBrZXlzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Bvc10gPSB7IGtleSwgc2NoZW1hOiByZXN1bHRbcG9zXS5zY2hlbWEuY29uY2F0KGl0ZW0uc2NoZW1hKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/types/keys.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/types/link.js":
/*!********************************************!*\
  !*** ./node_modules/joi/lib/types/link.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\n\nconst Any = __webpack_require__(/*! ./any */ \"./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ../compile */ \"./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"./node_modules/joi/lib/errors.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'link',\n\n    properties: {\n        schemaChain: true\n    },\n\n    terms: {\n\n        link: { init: null, manifest: 'single', register: false }\n    },\n\n    args(schema, ref) {\n\n        return schema.ref(ref);\n    },\n\n    validate(value, { schema, state, prefs }) {\n\n        Assert(schema.$_terms.link, 'Uninitialized link schema');\n\n        const linked = internals.generate(schema, value, state, prefs);\n        const ref = schema.$_terms.link[0].ref;\n        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);\n    },\n\n    generate(schema, value, state, prefs) {\n\n        return internals.generate(schema, value, state, prefs);\n    },\n\n    rules: {\n\n        ref: {\n            method(ref) {\n\n                Assert(!this.$_terms.link, 'Cannot reinitialize schema');\n\n                ref = Compile.ref(ref);\n\n                Assert(ref.type === 'value' || ref.type === 'local', 'Invalid reference type:', ref.type);\n                Assert(ref.type === 'local' || ref.ancestor === 'root' || ref.ancestor > 0, 'Link cannot reference itself');\n\n                const obj = this.clone();\n                obj.$_terms.link = [{ ref }];\n                return obj;\n            }\n        },\n\n        relative: {\n            method(enabled = true) {\n\n                return this.$_setFlag('relative', enabled);\n            }\n        }\n    },\n\n    overrides: {\n\n        concat(source) {\n\n            Assert(this.$_terms.link, 'Uninitialized link schema');\n            Assert(Common.isSchema(source), 'Invalid schema object');\n            Assert(source.type !== 'link', 'Cannot merge type link with another link');\n\n            const obj = this.clone();\n\n            if (!obj.$_terms.whens) {\n                obj.$_terms.whens = [];\n            }\n\n            obj.$_terms.whens.push({ concat: source });\n            return obj.$_mutateRebuild();\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            Assert(desc.link, 'Invalid link description missing link');\n            return obj.ref(desc.link);\n        }\n    }\n});\n\n\n// Helpers\n\ninternals.generate = function (schema, value, state, prefs) {\n\n    let linked = state.mainstay.links.get(schema);\n    if (linked) {\n        return linked._generate(value, state, prefs).schema;\n    }\n\n    const ref = schema.$_terms.link[0].ref;\n    const { perspective, path } = internals.perspective(ref, state);\n    internals.assert(perspective, 'which is outside of schema boundaries', ref, schema, state, prefs);\n\n    try {\n        linked = path.length ? perspective.$_reach(path) : perspective;\n    }\n    catch (ignoreErr) {\n        internals.assert(false, 'to non-existing schema', ref, schema, state, prefs);\n    }\n\n    internals.assert(linked.type !== 'link', 'which is another link', ref, schema, state, prefs);\n\n    if (!schema._flags.relative) {\n        state.mainstay.links.set(schema, linked);\n    }\n\n    return linked._generate(value, state, prefs).schema;\n};\n\n\ninternals.perspective = function (ref, state) {\n\n    if (ref.type === 'local') {\n        for (const { schema, key } of state.schemas) {                              // From parent to root\n            const id = schema._flags.id || key;\n            if (id === ref.path[0]) {\n                return { perspective: schema, path: ref.path.slice(1) };\n            }\n\n            if (schema.$_terms.shared) {\n                for (const shared of schema.$_terms.shared) {\n                    if (shared._flags.id === ref.path[0]) {\n                        return { perspective: shared, path: ref.path.slice(1) };\n                    }\n                }\n            }\n        }\n\n        return { perspective: null, path: null };\n    }\n\n    if (ref.ancestor === 'root') {\n        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };\n    }\n\n    return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };\n};\n\n\ninternals.assert = function (condition, message, ref, schema, state, prefs) {\n\n    if (condition) {                // Manual check to avoid generating error message on success\n        return;\n    }\n\n    Assert(false, `\"${Errors.label(schema._flags, state, prefs)}\" contains link reference \"${ref.display}\" ${message}`);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9saW5rLmpzP2NkNzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLG9EQUF1Qjs7QUFFOUMsWUFBWSxtQkFBTyxDQUFDLGtEQUFPO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxtREFBVztBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxREFBWTtBQUNwQyxlQUFlLG1CQUFPLENBQUMsbURBQVc7OztBQUdsQzs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsZUFBZTtBQUNmLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMLHFCQUFxQix1QkFBdUI7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQSxtRUFBbUUsWUFBWSxHQUFHLFlBQVk7QUFDOUYsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLE1BQU07QUFDM0M7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBLG9CQUFvQixjQUFjLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsWUFBWTtBQUNaOzs7QUFHQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQSxzQkFBc0IsMENBQTBDLDZCQUE2QixZQUFZLElBQUksUUFBUTtBQUNySCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2xpbmsuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdsaW5rJyxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgc2NoZW1hQ2hhaW46IHRydWVcbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBsaW5rOiB7IGluaXQ6IG51bGwsIG1hbmlmZXN0OiAnc2luZ2xlJywgcmVnaXN0ZXI6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgYXJncyhzY2hlbWEsIHJlZikge1xuXG4gICAgICAgIHJldHVybiBzY2hlbWEucmVmKHJlZik7XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgICAgICBBc3NlcnQoc2NoZW1hLiRfdGVybXMubGluaywgJ1VuaW5pdGlhbGl6ZWQgbGluayBzY2hlbWEnKTtcblxuICAgICAgICBjb25zdCBsaW5rZWQgPSBpbnRlcm5hbHMuZ2VuZXJhdGUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgY29uc3QgcmVmID0gc2NoZW1hLiRfdGVybXMubGlua1swXS5yZWY7XG4gICAgICAgIHJldHVybiBsaW5rZWQuJF92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUubmVzdChsaW5rZWQsIGBsaW5rOiR7cmVmLmRpc3BsYXl9OiR7bGlua2VkLnR5cGV9YCksIHByZWZzKTtcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZShzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIHJlZjoge1xuICAgICAgICAgICAgbWV0aG9kKHJlZikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLiRfdGVybXMubGluaywgJ0Nhbm5vdCByZWluaXRpYWxpemUgc2NoZW1hJyk7XG5cbiAgICAgICAgICAgICAgICByZWYgPSBDb21waWxlLnJlZihyZWYpO1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZi50eXBlID09PSAndmFsdWUnIHx8IHJlZi50eXBlID09PSAnbG9jYWwnLCAnSW52YWxpZCByZWZlcmVuY2UgdHlwZTonLCByZWYudHlwZSk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZi50eXBlID09PSAnbG9jYWwnIHx8IHJlZi5hbmNlc3RvciA9PT0gJ3Jvb3QnIHx8IHJlZi5hbmNlc3RvciA+IDAsICdMaW5rIGNhbm5vdCByZWZlcmVuY2UgaXRzZWxmJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMubGluayA9IFt7IHJlZiB9XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbGF0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncmVsYXRpdmUnLCBlbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvdmVycmlkZXM6IHtcblxuICAgICAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgICAgIEFzc2VydCh0aGlzLiRfdGVybXMubGluaywgJ1VuaW5pdGlhbGl6ZWQgbGluayBzY2hlbWEnKTtcbiAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc291cmNlKSwgJ0ludmFsaWQgc2NoZW1hIG9iamVjdCcpO1xuICAgICAgICAgICAgQXNzZXJ0KHNvdXJjZS50eXBlICE9PSAnbGluaycsICdDYW5ub3QgbWVyZ2UgdHlwZSBsaW5rIHdpdGggYW5vdGhlciBsaW5rJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgaWYgKCFvYmouJF90ZXJtcy53aGVucykge1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLndoZW5zID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai4kX3Rlcm1zLndoZW5zLnB1c2goeyBjb25jYXQ6IHNvdXJjZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgQXNzZXJ0KGRlc2MubGluaywgJ0ludmFsaWQgbGluayBkZXNjcmlwdGlvbiBtaXNzaW5nIGxpbmsnKTtcbiAgICAgICAgICAgIHJldHVybiBvYmoucmVmKGRlc2MubGluayk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGxldCBsaW5rZWQgPSBzdGF0ZS5tYWluc3RheS5saW5rcy5nZXQoc2NoZW1hKTtcbiAgICBpZiAobGlua2VkKSB7XG4gICAgICAgIHJldHVybiBsaW5rZWQuX2dlbmVyYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpLnNjaGVtYTtcbiAgICB9XG5cbiAgICBjb25zdCByZWYgPSBzY2hlbWEuJF90ZXJtcy5saW5rWzBdLnJlZjtcbiAgICBjb25zdCB7IHBlcnNwZWN0aXZlLCBwYXRoIH0gPSBpbnRlcm5hbHMucGVyc3BlY3RpdmUocmVmLCBzdGF0ZSk7XG4gICAgaW50ZXJuYWxzLmFzc2VydChwZXJzcGVjdGl2ZSwgJ3doaWNoIGlzIG91dHNpZGUgb2Ygc2NoZW1hIGJvdW5kYXJpZXMnLCByZWYsIHNjaGVtYSwgc3RhdGUsIHByZWZzKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGxpbmtlZCA9IHBhdGgubGVuZ3RoID8gcGVyc3BlY3RpdmUuJF9yZWFjaChwYXRoKSA6IHBlcnNwZWN0aXZlO1xuICAgIH1cbiAgICBjYXRjaCAoaWdub3JlRXJyKSB7XG4gICAgICAgIGludGVybmFscy5hc3NlcnQoZmFsc2UsICd0byBub24tZXhpc3Rpbmcgc2NoZW1hJywgcmVmLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxzLmFzc2VydChsaW5rZWQudHlwZSAhPT0gJ2xpbmsnLCAnd2hpY2ggaXMgYW5vdGhlciBsaW5rJywgcmVmLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG5cbiAgICBpZiAoIXNjaGVtYS5fZmxhZ3MucmVsYXRpdmUpIHtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkubGlua3Muc2V0KHNjaGVtYSwgbGlua2VkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlua2VkLl9nZW5lcmF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKS5zY2hlbWE7XG59O1xuXG5cbmludGVybmFscy5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uIChyZWYsIHN0YXRlKSB7XG5cbiAgICBpZiAocmVmLnR5cGUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IHNjaGVtYSwga2V5IH0gb2Ygc3RhdGUuc2NoZW1hcykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZyb20gcGFyZW50IHRvIHJvb3RcbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2NoZW1hLl9mbGFncy5pZCB8fCBrZXk7XG4gICAgICAgICAgICBpZiAoaWQgPT09IHJlZi5wYXRoWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcGVyc3BlY3RpdmU6IHNjaGVtYSwgcGF0aDogcmVmLnBhdGguc2xpY2UoMSkgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnNoYXJlZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2hhcmVkIG9mIHNjaGVtYS4kX3Rlcm1zLnNoYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkLl9mbGFncy5pZCA9PT0gcmVmLnBhdGhbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBlcnNwZWN0aXZlOiBzaGFyZWQsIHBhdGg6IHJlZi5wYXRoLnNsaWNlKDEpIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogbnVsbCwgcGF0aDogbnVsbCB9O1xuICAgIH1cblxuICAgIGlmIChyZWYuYW5jZXN0b3IgPT09ICdyb290Jykge1xuICAgICAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogc3RhdGUuc2NoZW1hc1tzdGF0ZS5zY2hlbWFzLmxlbmd0aCAtIDFdLnNjaGVtYSwgcGF0aDogcmVmLnBhdGggfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogc3RhdGUuc2NoZW1hc1tyZWYuYW5jZXN0b3JdICYmIHN0YXRlLnNjaGVtYXNbcmVmLmFuY2VzdG9yXS5zY2hlbWEsIHBhdGg6IHJlZi5wYXRoIH07XG59O1xuXG5cbmludGVybmFscy5hc3NlcnQgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBtZXNzYWdlLCByZWYsIHNjaGVtYSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBpZiAoY29uZGl0aW9uKSB7ICAgICAgICAgICAgICAgIC8vIE1hbnVhbCBjaGVjayB0byBhdm9pZCBnZW5lcmF0aW5nIGVycm9yIG1lc3NhZ2Ugb24gc3VjY2Vzc1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgQXNzZXJ0KGZhbHNlLCBgXCIke0Vycm9ycy5sYWJlbChzY2hlbWEuX2ZsYWdzLCBzdGF0ZSwgcHJlZnMpfVwiIGNvbnRhaW5zIGxpbmsgcmVmZXJlbmNlIFwiJHtyZWYuZGlzcGxheX1cIiAke21lc3NhZ2V9YCk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/types/link.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/types/number.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/number.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\n\nconst Any = __webpack_require__(/*! ./any */ \"./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"./node_modules/joi/lib/common.js\");\n\n\nconst internals = {\n    numberRx: /^\\s*[+-]?(?:(?:\\d+(?:\\.\\d*)?)|(?:\\.\\d+))(?:e([+-]?\\d+))?\\s*$/i,\n    precisionRx: /(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'number',\n\n    flags: {\n\n        unsafe: { default: false }\n    },\n\n    coerce: {\n        from: 'string',\n        method(value, { schema, error }) {\n\n            const matches = value.match(internals.numberRx);\n            if (!matches) {\n                return;\n            }\n\n            value = value.trim();\n            const result = { value: parseFloat(value) };\n\n            if (result.value === 0) {\n                result.value = 0;           // -0\n            }\n\n            if (!schema._flags.unsafe) {\n                if (value.match(/e/i)) {\n                    const constructed = internals.normalizeExponent(`${result.value / Math.pow(10, matches[1])}e${matches[1]}`);\n                    if (constructed !== internals.normalizeExponent(value)) {\n                        result.errors = error('number.unsafe');\n                        return result;\n                    }\n                }\n                else {\n                    const string = result.value.toString();\n                    if (string.match(/e/i)) {\n                        return result;\n                    }\n\n                    if (string !== internals.normalizeDecimal(value)) {\n                        result.errors = error('number.unsafe');\n                        return result;\n                    }\n                }\n            }\n\n            return result;\n        }\n    },\n\n    validate(value, { schema, error, prefs }) {\n\n        if (value === Infinity ||\n            value === -Infinity) {\n\n            return { value, errors: error('number.infinity') };\n        }\n\n        if (!Common.isNumber(value)) {\n            return { value, errors: error('number.base') };\n        }\n\n        const result = { value };\n\n        if (prefs.convert) {\n            const rule = schema.$_getRule('precision');\n            if (rule) {\n                const precision = Math.pow(10, rule.args.limit);                    // This is conceptually equivalent to using toFixed but it should be much faster\n                result.value = Math.round(result.value * precision) / precision;\n            }\n        }\n\n        if (result.value === 0) {\n            result.value = 0;           // -0\n        }\n\n        if (!schema._flags.unsafe &&\n            (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {\n\n            result.errors = error('number.unsafe');\n        }\n\n        return result;\n    },\n\n    rules: {\n\n        compare: {\n            method: false,\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(value, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('number.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.isNumber,\n                    message: 'must be a number'\n                }\n            ]\n        },\n\n        greater: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'greater', method: 'compare', args: { limit }, operator: '>' });\n            }\n        },\n\n        integer: {\n            method() {\n\n                return this.$_addRule('integer');\n            },\n            validate(value, helpers) {\n\n                if (Math.trunc(value) - value === 0) {\n                    return value;\n                }\n\n                return helpers.error('number.integer');\n            }\n        },\n\n        less: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'less', method: 'compare', args: { limit }, operator: '<' });\n            }\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'compare', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'compare', args: { limit }, operator: '>=' });\n            }\n        },\n\n        multiple: {\n            method(base) {\n\n                return this.$_addRule({ name: 'multiple', args: { base } });\n            },\n            validate(value, helpers, { base }, options) {\n\n                if (value % base === 0) {\n                    return value;\n                }\n\n                return helpers.error('number.multiple', { multiple: options.args.base, value });\n            },\n            args: [\n                {\n                    name: 'base',\n                    ref: true,\n                    assert: (value) => typeof value === 'number' && isFinite(value) && value > 0,\n                    message: 'must be a positive number'\n                }\n            ],\n            multi: true\n        },\n\n        negative: {\n            method() {\n\n                return this.sign('negative');\n            }\n        },\n\n        port: {\n            method() {\n\n                return this.$_addRule('port');\n            },\n            validate(value, helpers) {\n\n                if (Number.isSafeInteger(value) &&\n                    value >= 0 &&\n                    value <= 65535) {\n\n                    return value;\n                }\n\n                return helpers.error('number.port');\n            }\n        },\n\n        positive: {\n            method() {\n\n                return this.sign('positive');\n            }\n        },\n\n        precision: {\n            method(limit) {\n\n                Assert(Number.isSafeInteger(limit), 'limit must be an integer');\n\n                return this.$_addRule({ name: 'precision', args: { limit } });\n            },\n            validate(value, helpers, { limit }) {\n\n                const places = value.toString().match(internals.precisionRx);\n                const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);\n                if (decimals <= limit) {\n                    return value;\n                }\n\n                return helpers.error('number.precision', { limit, value });\n            },\n            convert: true\n        },\n\n        sign: {\n            method(sign) {\n\n                Assert(['negative', 'positive'].includes(sign), 'Invalid sign', sign);\n\n                return this.$_addRule({ name: 'sign', args: { sign } });\n            },\n            validate(value, helpers, { sign }) {\n\n                if (sign === 'negative' && value < 0 ||\n                    sign === 'positive' && value > 0) {\n\n                    return value;\n                }\n\n                return helpers.error(`number.${sign}`);\n            }\n        },\n\n        unsafe: {\n            method(enabled = true) {\n\n                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n\n                return this.$_setFlag('unsafe', enabled);\n            }\n        }\n    },\n\n    cast: {\n        string: {\n            from: (value) => typeof value === 'number',\n            to(value, helpers) {\n\n                return value.toString();\n            }\n        }\n    },\n\n    messages: {\n        'number.base': '{{#label}} must be a number',\n        'number.greater': '{{#label}} must be greater than {{#limit}}',\n        'number.infinity': '{{#label}} cannot be infinity',\n        'number.integer': '{{#label}} must be an integer',\n        'number.less': '{{#label}} must be less than {{#limit}}',\n        'number.max': '{{#label}} must be less than or equal to {{#limit}}',\n        'number.min': '{{#label}} must be greater than or equal to {{#limit}}',\n        'number.multiple': '{{#label}} must be a multiple of {{#multiple}}',\n        'number.negative': '{{#label}} must be a negative number',\n        'number.port': '{{#label}} must be a valid port',\n        'number.positive': '{{#label}} must be a positive number',\n        'number.precision': '{{#label}} must have no more than {{#limit}} decimal places',\n        'number.unsafe': '{{#label}} must be a safe number'\n    }\n});\n\n\n// Helpers\n\ninternals.normalizeExponent = function (str) {\n\n    return str\n        .replace(/E/, 'e')\n        .replace(/\\.(\\d*[1-9])?0+e/, '.$1e')\n        .replace(/\\.e/, 'e')\n        .replace(/e\\+/, 'e')\n        .replace(/^\\+/, '')\n        .replace(/^(-?)0+([1-9])/, '$1$2');\n};\n\n\ninternals.normalizeDecimal = function (str) {\n\n    str = str\n        // Remove leading plus signs\n        .replace(/^\\+/, '')\n        // Remove trailing zeros if there is a decimal point and unecessary decimal points\n        .replace(/\\.0*$/, '')\n        // Add a integer 0 if the numbers starts with a decimal point\n        .replace(/^(-?)\\.([^\\.]*)$/, '$10.$2')\n        // Remove leading zeros\n        .replace(/^(-?)0+([0-9])/, '$1$2');\n\n    if (str.includes('.') &&\n        str.endsWith('0')) {\n\n        str = str.replace(/0+$/, '');\n    }\n\n    if (str === '-0') {\n        return '0';\n    }\n\n    return str;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9udW1iZXIuanM/MWE1ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0RBQXVCOztBQUU5QyxZQUFZLG1CQUFPLENBQUMsa0RBQU87QUFDM0IsZUFBZSxtQkFBTyxDQUFDLG1EQUFXOzs7QUFHbEM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQjtBQUNqQixLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBLHVFQUF1RSx3Q0FBd0MsR0FBRyxXQUFXO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxxQkFBcUIsdUJBQXVCOztBQUU1QztBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVEsR0FBRyx1QkFBdUI7O0FBRXhFO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0QsMkJBQTJCO0FBQ25GLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLHVDQUF1Qyw0Q0FBNEMsUUFBUSxpQkFBaUI7QUFDNUc7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsdUNBQXVDLHlDQUF5QyxRQUFRLGlCQUFpQjtBQUN6RztBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQSx1Q0FBdUMsd0NBQXdDLFFBQVEsa0JBQWtCO0FBQ3pHO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLHVDQUF1Qyx3Q0FBd0MsUUFBUSxrQkFBa0I7QUFDekc7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsdUNBQXVDLDBCQUEwQixPQUFPLEVBQUU7QUFDMUUsYUFBYTtBQUNiLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBO0FBQ0E7O0FBRUEseURBQXlELHFDQUFxQztBQUM5RixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBLHVDQUF1QywyQkFBMkIsUUFBUSxFQUFFO0FBQzVFLGFBQWE7QUFDYixzQ0FBc0MsUUFBUTs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsZUFBZTtBQUN6RSxhQUFhO0FBQ2I7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUEsdUNBQXVDLHNCQUFzQixPQUFPLEVBQUU7QUFDdEUsYUFBYTtBQUNiLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLEtBQUs7QUFDcEQ7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEMsNkJBQTZCLFFBQVEsd0JBQXdCLFFBQVE7QUFDckUsOEJBQThCLFFBQVE7QUFDdEMsNkJBQTZCLFFBQVE7QUFDckMsMEJBQTBCLFFBQVEscUJBQXFCLFFBQVE7QUFDL0QseUJBQXlCLFFBQVEsaUNBQWlDLFFBQVE7QUFDMUUseUJBQXlCLFFBQVEsb0NBQW9DLFFBQVE7QUFDN0UsOEJBQThCLFFBQVEseUJBQXlCLFdBQVc7QUFDMUUsOEJBQThCLFFBQVE7QUFDdEMsMEJBQTBCLFFBQVE7QUFDbEMsOEJBQThCLFFBQVE7QUFDdEMsK0JBQStCLFFBQVEsMEJBQTBCLFFBQVE7QUFDekUsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvbnVtYmVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBudW1iZXJSeDogL15cXHMqWystXT8oPzooPzpcXGQrKD86XFwuXFxkKik/KXwoPzpcXC5cXGQrKSkoPzplKFsrLV0/XFxkKykpP1xccyokL2ksXG4gICAgcHJlY2lzaW9uUng6IC8oPzpcXC4oXFxkKykpPyg/OltlRV0oWystXT9cXGQrKSk/JC9cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdudW1iZXInLFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICB1bnNhZmU6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogJ3N0cmluZycsXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yIH0pIHtcblxuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlLm1hdGNoKGludGVybmFscy5udW1iZXJSeCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogcGFyc2VGbG9hdCh2YWx1ZSkgfTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC52YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IDA7ICAgICAgICAgICAvLyAtMFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNjaGVtYS5fZmxhZ3MudW5zYWZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9lL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdGVkID0gaW50ZXJuYWxzLm5vcm1hbGl6ZUV4cG9uZW50KGAke3Jlc3VsdC52YWx1ZSAvIE1hdGgucG93KDEwLCBtYXRjaGVzWzFdKX1lJHttYXRjaGVzWzFdfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3RydWN0ZWQgIT09IGludGVybmFscy5ub3JtYWxpemVFeHBvbmVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBlcnJvcignbnVtYmVyLnVuc2FmZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nID0gcmVzdWx0LnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmcubWF0Y2goL2UvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nICE9PSBpbnRlcm5hbHMubm9ybWFsaXplRGVjaW1hbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBlcnJvcignbnVtYmVyLnVuc2FmZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSB8fFxuICAgICAgICAgICAgdmFsdWUgPT09IC1JbmZpbml0eSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignbnVtYmVyLmluZmluaXR5JykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQ29tbW9uLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ251bWJlci5iYXNlJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWUgfTtcblxuICAgICAgICBpZiAocHJlZnMuY29udmVydCkge1xuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHNjaGVtYS4kX2dldFJ1bGUoJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVjaXNpb24gPSBNYXRoLnBvdygxMCwgcnVsZS5hcmdzLmxpbWl0KTsgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgY29uY2VwdHVhbGx5IGVxdWl2YWxlbnQgdG8gdXNpbmcgdG9GaXhlZCBidXQgaXQgc2hvdWxkIGJlIG11Y2ggZmFzdGVyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gTWF0aC5yb3VuZChyZXN1bHQudmFsdWUgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC52YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gMDsgICAgICAgICAgIC8vIC0wXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNjaGVtYS5fZmxhZ3MudW5zYWZlICYmXG4gICAgICAgICAgICAodmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCB2YWx1ZSA8IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSkge1xuXG4gICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gZXJyb3IoJ251bWJlci51bnNhZmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgY29tcGFyZToge1xuICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKHZhbHVlLCBsaW1pdCwgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmxpbWl0LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmlzTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIG51bWJlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgZ3JlYXRlcjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZ3JlYXRlcicsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPicgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW50ZWdlcjoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdpbnRlZ2VyJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChNYXRoLnRydW5jKHZhbHVlKSAtIHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLmludGVnZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsZXNzOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZXNzJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc+PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbXVsdGlwbGU6IHtcbiAgICAgICAgICAgIG1ldGhvZChiYXNlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbXVsdGlwbGUnLCBhcmdzOiB7IGJhc2UgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBiYXNlIH0sIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAlIGJhc2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIubXVsdGlwbGUnLCB7IG11bHRpcGxlOiBvcHRpb25zLmFyZ3MuYmFzZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Jhc2UnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDAsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIG5lZ2F0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduKCduZWdhdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBvcnQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgncG9ydCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPD0gNjU1MzUpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ251bWJlci5wb3J0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zaXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ24oJ3Bvc2l0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlY2lzaW9uOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCksICdsaW1pdCBtdXN0IGJlIGFuIGludGVnZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdwcmVjaXNpb24nLCBhcmdzOiB7IGxpbWl0IH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2VzID0gdmFsdWUudG9TdHJpbmcoKS5tYXRjaChpbnRlcm5hbHMucHJlY2lzaW9uUngpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxzID0gTWF0aC5tYXgoKHBsYWNlc1sxXSA/IHBsYWNlc1sxXS5sZW5ndGggOiAwKSAtIChwbGFjZXNbMl0gPyBwYXJzZUludChwbGFjZXNbMl0sIDEwKSA6IDApLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVjaW1hbHMgPD0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIucHJlY2lzaW9uJywgeyBsaW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHNpZ246IHtcbiAgICAgICAgICAgIG1ldGhvZChzaWduKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWyduZWdhdGl2ZScsICdwb3NpdGl2ZSddLmluY2x1ZGVzKHNpZ24pLCAnSW52YWxpZCBzaWduJywgc2lnbik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnc2lnbicsIGFyZ3M6IHsgc2lnbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IHNpZ24gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHNpZ24gPT09ICduZWdhdGl2ZScgJiYgdmFsdWUgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPT09ICdwb3NpdGl2ZScgJiYgdmFsdWUgPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKGBudW1iZXIuJHtzaWdufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuc2FmZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ2VuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndW5zYWZlJywgZW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnbnVtYmVyLmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgICAgJ251bWJlci5ncmVhdGVyJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBncmVhdGVyIHRoYW4ge3sjbGltaXR9fScsXG4gICAgICAgICdudW1iZXIuaW5maW5pdHknOiAne3sjbGFiZWx9fSBjYW5ub3QgYmUgaW5maW5pdHknLFxuICAgICAgICAnbnVtYmVyLmludGVnZXInOiAne3sjbGFiZWx9fSBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgICAgICAnbnVtYmVyLmxlc3MnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5tdWx0aXBsZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBtdWx0aXBsZSBvZiB7eyNtdWx0aXBsZX19JyxcbiAgICAgICAgJ251bWJlci5uZWdhdGl2ZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBuZWdhdGl2ZSBudW1iZXInLFxuICAgICAgICAnbnVtYmVyLnBvcnQnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgcG9ydCcsXG4gICAgICAgICdudW1iZXIucG9zaXRpdmUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyxcbiAgICAgICAgJ251bWJlci5wcmVjaXNpb24nOiAne3sjbGFiZWx9fSBtdXN0IGhhdmUgbm8gbW9yZSB0aGFuIHt7I2xpbWl0fX0gZGVjaW1hbCBwbGFjZXMnLFxuICAgICAgICAnbnVtYmVyLnVuc2FmZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBzYWZlIG51bWJlcidcbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5ub3JtYWxpemVFeHBvbmVudCA9IGZ1bmN0aW9uIChzdHIpIHtcblxuICAgIHJldHVybiBzdHJcbiAgICAgICAgLnJlcGxhY2UoL0UvLCAnZScpXG4gICAgICAgIC5yZXBsYWNlKC9cXC4oXFxkKlsxLTldKT8wK2UvLCAnLiQxZScpXG4gICAgICAgIC5yZXBsYWNlKC9cXC5lLywgJ2UnKVxuICAgICAgICAucmVwbGFjZSgvZVxcKy8sICdlJylcbiAgICAgICAgLnJlcGxhY2UoL15cXCsvLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL14oLT8pMCsoWzEtOV0pLywgJyQxJDInKTtcbn07XG5cblxuaW50ZXJuYWxzLm5vcm1hbGl6ZURlY2ltYWwgPSBmdW5jdGlvbiAoc3RyKSB7XG5cbiAgICBzdHIgPSBzdHJcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgcGx1cyBzaWduc1xuICAgICAgICAucmVwbGFjZSgvXlxcKy8sICcnKVxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MgaWYgdGhlcmUgaXMgYSBkZWNpbWFsIHBvaW50IGFuZCB1bmVjZXNzYXJ5IGRlY2ltYWwgcG9pbnRzXG4gICAgICAgIC5yZXBsYWNlKC9cXC4wKiQvLCAnJylcbiAgICAgICAgLy8gQWRkIGEgaW50ZWdlciAwIGlmIHRoZSBudW1iZXJzIHN0YXJ0cyB3aXRoIGEgZGVjaW1hbCBwb2ludFxuICAgICAgICAucmVwbGFjZSgvXigtPylcXC4oW15cXC5dKikkLywgJyQxMC4kMicpXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zXG4gICAgICAgIC5yZXBsYWNlKC9eKC0/KTArKFswLTldKS8sICckMSQyJyk7XG5cbiAgICBpZiAoc3RyLmluY2x1ZGVzKCcuJykgJiZcbiAgICAgICAgc3RyLmVuZHNXaXRoKCcwJykpIHtcblxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvMCskLywgJycpO1xuICAgIH1cblxuICAgIGlmIChzdHIgPT09ICctMCcpIHtcbiAgICAgICAgcmV0dXJuICcwJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/types/number.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/types/object.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/object.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Keys = __webpack_require__(/*! ./keys */ \"./node_modules/joi/lib/types/keys.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = Keys.extend({\n\n    type: 'object',\n\n    cast: {\n        map: {\n            from: (value) => value && typeof value === 'object',\n            to(value, helpers) {\n\n                return new Map(Object.entries(value));\n            }\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9vYmplY3QuanM/YjcxNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsb0RBQVE7OztBQUc3Qjs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvb2JqZWN0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBLZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBLZXlzLmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnb2JqZWN0JyxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgbWFwOiB7XG4gICAgICAgICAgICBmcm9tOiAodmFsdWUpID0+IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcsXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAoT2JqZWN0LmVudHJpZXModmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/types/object.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/types/string.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/string.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst Domain = __webpack_require__(/*! @sideway/address/lib/domain */ \"@sideway/address/lib/domain\");\nconst Email = __webpack_require__(/*! @sideway/address/lib/email */ \"@sideway/address/lib/email\");\nconst Ip = __webpack_require__(/*! @sideway/address/lib/ip */ \"@sideway/address/lib/ip\");\nconst EscapeRegex = __webpack_require__(/*! @hapi/hoek/lib/escapeRegex */ \"@hapi/hoek/lib/escapeRegex\");\nconst Tlds = __webpack_require__(/*! @sideway/address/lib/tlds */ \"@sideway/address/lib/tlds\");\nconst Uri = __webpack_require__(/*! @sideway/address/lib/uri */ \"@sideway/address/lib/uri\");\n\nconst Any = __webpack_require__(/*! ./any */ \"./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"./node_modules/joi/lib/common.js\");\n\n\nconst internals = {\n    tlds: Tlds instanceof Set ? { tlds: { allow: Tlds, deny: null } } : false,              // $lab:coverage:ignore$\n    base64Regex: {\n        // paddingRequired\n        true: {\n            // urlSafe\n            true: /^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}==|[\\w\\-]{3}=)?$/,\n            false: /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n        },\n        false: {\n            true: /^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}(==)?|[\\w\\-]{3}=?)?$/,\n            false: /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/\n        }\n    },\n    dataUriRegex: /^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/,\n    hexRegex: /^[a-f0-9]+$/i,\n    ipRegex: Ip.regex().regex,\n    isoDurationRegex: /^P(?!$)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$/,\n\n    guidBrackets: {\n        '{': '}', '[': ']', '(': ')', '': ''\n    },\n    guidVersions: {\n        uuidv1: '1',\n        uuidv2: '2',\n        uuidv3: '3',\n        uuidv4: '4',\n        uuidv5: '5'\n    },\n    guidSeparators: new Set([undefined, true, false, '-', ':']),\n\n    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'string',\n\n    flags: {\n\n        insensitive: { default: false },\n        truncate: { default: false }\n    },\n\n    terms: {\n\n        replacements: { init: null }\n    },\n\n    coerce: {\n        from: 'string',\n        method(value, { schema, state, prefs }) {\n\n            const normalize = schema.$_getRule('normalize');\n            if (normalize) {\n                value = value.normalize(normalize.args.form);\n            }\n\n            const casing = schema.$_getRule('case');\n            if (casing) {\n                value = casing.args.direction === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n            }\n\n            const trim = schema.$_getRule('trim');\n            if (trim &&\n                trim.args.enabled) {\n\n                value = value.trim();\n            }\n\n            if (schema.$_terms.replacements) {\n                for (const replacement of schema.$_terms.replacements) {\n                    value = value.replace(replacement.pattern, replacement.replacement);\n                }\n            }\n\n            const hex = schema.$_getRule('hex');\n            if (hex &&\n                hex.args.options.byteAligned &&\n                value.length % 2 !== 0) {\n\n                value = `0${value}`;\n            }\n\n            if (schema.$_getRule('isoDate')) {\n                const iso = internals.isoDate(value);\n                if (iso) {\n                    value = iso;\n                }\n            }\n\n            if (schema._flags.truncate) {\n                const rule = schema.$_getRule('max');\n                if (rule) {\n                    let limit = rule.args.limit;\n                    if (Common.isResolvable(limit)) {\n                        limit = limit.resolve(value, state, prefs);\n                        if (!Common.limit(limit)) {\n                            return { value, errors: schema.$_createError('any.ref', limit, { ref: rule.args.limit, arg: 'limit', reason: 'must be a positive integer' }, state, prefs) };\n                        }\n                    }\n\n                    value = value.slice(0, limit);\n                }\n            }\n\n            return { value };\n        }\n    },\n\n    validate(value, { error }) {\n\n        if (typeof value !== 'string') {\n            return { value, errors: error('string.base') };\n        }\n\n        if (value === '') {\n            return { value, errors: error('string.empty') };\n        }\n    },\n\n    rules: {\n\n        alphanum: {\n            method() {\n\n                return this.$_addRule('alphanum');\n            },\n            validate(value, helpers) {\n\n                if (/^[a-zA-Z0-9]+$/.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.alphanum');\n            }\n        },\n\n        base64: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['paddingRequired', 'urlSafe']);\n\n                options = { urlSafe: false, paddingRequired: true, ...options };\n                Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');\n                Assert(typeof options.urlSafe === 'boolean', 'urlSafe must be boolean');\n\n                return this.$_addRule({ name: 'base64', args: { options } });\n            },\n            validate(value, helpers, { options }) {\n\n                const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];\n                if (regex.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.base64');\n            }\n        },\n\n        case: {\n            method(direction) {\n\n                Assert(['lower', 'upper'].includes(direction), 'Invalid case:', direction);\n\n                return this.$_addRule({ name: 'case', args: { direction } });\n            },\n            validate(value, helpers, { direction }) {\n\n                if (direction === 'lower' && value === value.toLocaleLowerCase() ||\n                    direction === 'upper' && value === value.toLocaleUpperCase()) {\n\n                    return value;\n                }\n\n                return helpers.error(`string.${direction}case`);\n            },\n            convert: true\n        },\n\n        creditCard: {\n            method() {\n\n                return this.$_addRule('creditCard');\n            },\n            validate(value, helpers) {\n\n                let i = value.length;\n                let sum = 0;\n                let mul = 1;\n\n                while (i--) {\n                    const char = value.charAt(i) * mul;\n                    sum = sum + (char - (char > 9) * 9);\n                    mul = mul ^ 3;\n                }\n\n                if (sum > 0 &&\n                    sum % 10 === 0) {\n\n                    return value;\n                }\n\n                return helpers.error('string.creditCard');\n            }\n        },\n\n        dataUri: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['paddingRequired']);\n\n                options = { paddingRequired: true, ...options };\n                Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');\n\n                return this.$_addRule({ name: 'dataUri', args: { options } });\n            },\n            validate(value, helpers, { options }) {\n\n                const matches = value.match(internals.dataUriRegex);\n\n                if (matches) {\n                    if (!matches[2]) {\n                        return value;\n                    }\n\n                    if (matches[2] !== 'base64') {\n                        return value;\n                    }\n\n                    const base64regex = internals.base64Regex[options.paddingRequired].false;\n                    if (base64regex.test(matches[3])) {\n                        return value;\n                    }\n                }\n\n                return helpers.error('string.dataUri');\n            }\n        },\n\n        domain: {\n            method(options) {\n\n                if (options) {\n                    Common.assertOptions(options, ['allowUnicode', 'maxDomainSegments', 'minDomainSegments', 'tlds']);\n                }\n\n                const address = internals.addressOptions(options);\n                return this.$_addRule({ name: 'domain', args: { options }, address });\n            },\n            validate(value, helpers, args, { address }) {\n\n                if (Domain.isValid(value, address)) {\n                    return value;\n                }\n\n                return helpers.error('string.domain');\n            }\n        },\n\n        email: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['allowUnicode', 'ignoreLength', 'maxDomainSegments', 'minDomainSegments', 'multiple', 'separator', 'tlds']);\n                Assert(options.multiple === undefined || typeof options.multiple === 'boolean', 'multiple option must be an boolean');\n\n                const address = internals.addressOptions(options);\n                const regex = new RegExp(`\\\\s*[${options.separator ? EscapeRegex(options.separator) : ','}]\\\\s*`);\n\n                return this.$_addRule({ name: 'email', args: { options }, regex, address });\n            },\n            validate(value, helpers, { options }, { regex, address }) {\n\n                const emails = options.multiple ? value.split(regex) : [value];\n                const invalids = [];\n                for (const email of emails) {\n                    if (!Email.isValid(email, address)) {\n                        invalids.push(email);\n                    }\n                }\n\n                if (!invalids.length) {\n                    return value;\n                }\n\n                return helpers.error('string.email', { value, invalids });\n            }\n        },\n\n        guid: {\n            alias: 'uuid',\n            method(options = {}) {\n\n                Common.assertOptions(options, ['version', 'separator']);\n\n                let versionNumbers = '';\n\n                if (options.version) {\n                    const versions = [].concat(options.version);\n\n                    Assert(versions.length >= 1, 'version must have at least 1 valid version specified');\n                    const set = new Set();\n\n                    for (let i = 0; i < versions.length; ++i) {\n                        const version = versions[i];\n                        Assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                        const versionNumber = internals.guidVersions[version.toLowerCase()];\n                        Assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n                        Assert(!set.has(versionNumber), 'version at position ' + i + ' must not be a duplicate');\n\n                        versionNumbers += versionNumber;\n                        set.add(versionNumber);\n                    }\n                }\n\n                Assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, \"-\", or \":\"');\n                const separator = options.separator === undefined ? '[:-]?' :\n                    options.separator === true ? '[:-]' :\n                        options.separator === false ? '[]?' : `\\\\${options.separator}`;\n\n                const regex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, 'i');\n\n                return this.$_addRule({ name: 'guid', args: { options }, regex });\n            },\n            validate(value, helpers, args, { regex }) {\n\n                const results = regex.exec(value);\n\n                if (!results) {\n                    return helpers.error('string.guid');\n                }\n\n                // Matching braces\n\n                if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n                    return helpers.error('string.guid');\n                }\n\n                return value;\n            }\n        },\n\n        hex: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['byteAligned']);\n\n                options = { byteAligned: false, ...options };\n                Assert(typeof options.byteAligned === 'boolean', 'byteAligned must be boolean');\n\n                return this.$_addRule({ name: 'hex', args: { options } });\n            },\n            validate(value, helpers, { options }) {\n\n                if (!internals.hexRegex.test(value)) {\n                    return helpers.error('string.hex');\n                }\n\n                if (options.byteAligned &&\n                    value.length % 2 !== 0) {\n\n                    return helpers.error('string.hexAlign');\n                }\n\n                return value;\n            }\n        },\n\n        hostname: {\n            method() {\n\n                return this.$_addRule('hostname');\n            },\n            validate(value, helpers) {\n\n                if (Domain.isValid(value, { minDomainSegments: 1 }) ||\n                    internals.ipRegex.test(value)) {\n\n                    return value;\n                }\n\n                return helpers.error('string.hostname');\n            }\n        },\n\n        insensitive: {\n            method() {\n\n                return this.$_setFlag('insensitive', true);\n            }\n        },\n\n        ip: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['cidr', 'version']);\n\n                const { cidr, versions, regex } = Ip.regex(options);\n                const version = options.version ? versions : undefined;\n                return this.$_addRule({ name: 'ip', args: { options: { cidr, version } }, regex });\n            },\n            validate(value, helpers, { options }, { regex }) {\n\n                if (regex.test(value)) {\n                    return value;\n                }\n\n                if (options.version) {\n                    return helpers.error('string.ipVersion', { value, cidr: options.cidr, version: options.version });\n                }\n\n                return helpers.error('string.ip', { value, cidr: options.cidr });\n            }\n        },\n\n        isoDate: {\n            method() {\n\n                return this.$_addRule('isoDate');\n            },\n            validate(value, { error }) {\n\n                if (internals.isoDate(value)) {\n                    return value;\n                }\n\n                return error('string.isoDate');\n            }\n        },\n\n        isoDuration: {\n            method() {\n\n                return this.$_addRule('isoDuration');\n            },\n            validate(value, helpers) {\n\n                if (internals.isoDurationRegex.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.isoDuration');\n            }\n        },\n\n        length: {\n            method(limit, encoding) {\n\n                return internals.length(this, 'length', limit, '=', encoding);\n            },\n            validate(value, helpers, { limit, encoding }, { name, operator, args }) {\n\n                const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;      // $lab:coverage:ignore$\n                if (Common.compare(length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('string.' + name, { limit: args.limit, value, encoding });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                },\n                'encoding'\n            ]\n        },\n\n        lowercase: {\n            method() {\n\n                return this.case('lower');\n            }\n        },\n\n        max: {\n            method(limit, encoding) {\n\n                return internals.length(this, 'max', limit, '<=', encoding);\n            },\n            args: ['limit', 'encoding']\n        },\n\n        min: {\n            method(limit, encoding) {\n\n                return internals.length(this, 'min', limit, '>=', encoding);\n            },\n            args: ['limit', 'encoding']\n        },\n\n        normalize: {\n            method(form = 'NFC') {\n\n                Assert(internals.normalizationForms.includes(form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n\n                return this.$_addRule({ name: 'normalize', args: { form } });\n            },\n            validate(value, { error }, { form }) {\n\n                if (value === value.normalize(form)) {\n                    return value;\n                }\n\n                return error('string.normalize', { value, form });\n            },\n            convert: true\n        },\n\n        pattern: {\n            alias: 'regex',\n            method(regex, options = {}) {\n\n                Assert(regex instanceof RegExp, 'regex must be a RegExp');\n                Assert(!regex.flags.includes('g') && !regex.flags.includes('y'), 'regex should not use global or sticky mode');\n\n                if (typeof options === 'string') {\n                    options = { name: options };\n                }\n\n                Common.assertOptions(options, ['invert', 'name']);\n\n                const errorCode = ['string.pattern', options.invert ? '.invert' : '', options.name ? '.name' : '.base'].join('');\n                return this.$_addRule({ name: 'pattern', args: { regex, options }, errorCode });\n            },\n            validate(value, helpers, { regex, options }, { errorCode }) {\n\n                const patternMatch = regex.test(value);\n\n                if (patternMatch ^ options.invert) {\n                    return value;\n                }\n\n                return helpers.error(errorCode, { name: options.name, regex, value });\n            },\n            args: ['regex', 'options'],\n            multi: true\n        },\n\n        replace: {\n            method(pattern, replacement) {\n\n                if (typeof pattern === 'string') {\n                    pattern = new RegExp(EscapeRegex(pattern), 'g');\n                }\n\n                Assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n                Assert(typeof replacement === 'string', 'replacement must be a String');\n\n                const obj = this.clone();\n\n                if (!obj.$_terms.replacements) {\n                    obj.$_terms.replacements = [];\n                }\n\n                obj.$_terms.replacements.push({ pattern, replacement });\n                return obj;\n            }\n        },\n\n        token: {\n            method() {\n\n                return this.$_addRule('token');\n            },\n            validate(value, helpers) {\n\n                if (/^\\w+$/.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.token');\n            }\n        },\n\n        trim: {\n            method(enabled = true) {\n\n                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n\n                return this.$_addRule({ name: 'trim', args: { enabled } });\n            },\n            validate(value, helpers, { enabled }) {\n\n                if (!enabled ||\n                    value === value.trim()) {\n\n                    return value;\n                }\n\n                return helpers.error('string.trim');\n            },\n            convert: true\n        },\n\n        truncate: {\n            method(enabled = true) {\n\n                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n\n                return this.$_setFlag('truncate', enabled);\n            }\n        },\n\n        uppercase: {\n            method() {\n\n                return this.case('upper');\n            }\n        },\n\n        uri: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['allowRelative', 'allowQuerySquareBrackets', 'domain', 'relativeOnly', 'scheme']);\n\n                if (options.domain) {\n                    Common.assertOptions(options.domain, ['allowUnicode', 'maxDomainSegments', 'minDomainSegments', 'tlds']);\n                }\n\n                const { regex, scheme } = Uri.regex(options);\n                const domain = options.domain ? internals.addressOptions(options.domain) : null;\n                return this.$_addRule({ name: 'uri', args: { options }, regex, domain, scheme });\n            },\n            validate(value, helpers, { options }, { regex, domain, scheme }) {\n\n                if (['http:/', 'https:/'].includes(value)) {            // scheme:/ is technically valid but makes no sense\n                    return helpers.error('string.uri');\n                }\n\n                const match = regex.exec(value);\n                if (match) {\n                    const matched = match[1] || match[2];\n                    if (domain &&\n                        (!options.allowRelative || matched) &&\n                        !Domain.isValid(matched, domain)) {\n\n                        return helpers.error('string.domain', { value: matched });\n                    }\n\n                    return value;\n                }\n\n                if (options.relativeOnly) {\n                    return helpers.error('string.uriRelativeOnly');\n                }\n\n                if (options.scheme) {\n                    return helpers.error('string.uriCustomScheme', { scheme, value });\n                }\n\n                return helpers.error('string.uri');\n            }\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.replacements) {\n                for (const { pattern, replacement } of desc.replacements) {\n                    obj = obj.replace(pattern, replacement);\n                }\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'string.alphanum': '{{#label}} must only contain alpha-numeric characters',\n        'string.base': '{{#label}} must be a string',\n        'string.base64': '{{#label}} must be a valid base64 string',\n        'string.creditCard': '{{#label}} must be a credit card',\n        'string.dataUri': '{{#label}} must be a valid dataUri string',\n        'string.domain': '{{#label}} must contain a valid domain name',\n        'string.email': '{{#label}} must be a valid email',\n        'string.empty': '{{#label}} is not allowed to be empty',\n        'string.guid': '{{#label}} must be a valid GUID',\n        'string.hex': '{{#label}} must only contain hexadecimal characters',\n        'string.hexAlign': '{{#label}} hex decoded representation must be byte aligned',\n        'string.hostname': '{{#label}} must be a valid hostname',\n        'string.ip': '{{#label}} must be a valid ip address with a {{#cidr}} CIDR',\n        'string.ipVersion': '{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR',\n        'string.isoDate': '{{#label}} must be in iso format',\n        'string.isoDuration': '{{#label}} must be a valid ISO 8601 duration',\n        'string.length': '{{#label}} length must be {{#limit}} characters long',\n        'string.lowercase': '{{#label}} must only contain lowercase characters',\n        'string.max': '{{#label}} length must be less than or equal to {{#limit}} characters long',\n        'string.min': '{{#label}} length must be at least {{#limit}} characters long',\n        'string.normalize': '{{#label}} must be unicode normalized in the {{#form}} form',\n        'string.token': '{{#label}} must only contain alpha-numeric and underscore characters',\n        'string.pattern.base': '{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}',\n        'string.pattern.name': '{{#label}} with value {:[.]} fails to match the {{#name}} pattern',\n        'string.pattern.invert.base': '{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}',\n        'string.pattern.invert.name': '{{#label}} with value {:[.]} matches the inverted {{#name}} pattern',\n        'string.trim': '{{#label}} must not have leading or trailing whitespace',\n        'string.uri': '{{#label}} must be a valid uri',\n        'string.uriCustomScheme': '{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern',\n        'string.uriRelativeOnly': '{{#label}} must be a valid relative uri',\n        'string.uppercase': '{{#label}} must only contain uppercase characters'\n    }\n});\n\n\n// Helpers\n\ninternals.addressOptions = function (options) {\n\n    if (!options) {\n        return options;\n    }\n\n    // minDomainSegments\n\n    Assert(options.minDomainSegments === undefined ||\n        Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, 'minDomainSegments must be a positive integer');\n\n    // maxDomainSegments\n\n    Assert(options.maxDomainSegments === undefined ||\n        Number.isSafeInteger(options.maxDomainSegments) && options.maxDomainSegments > 0, 'maxDomainSegments must be a positive integer');\n\n    // tlds\n\n    if (options.tlds === false) {\n        return options;\n    }\n\n    if (options.tlds === true ||\n        options.tlds === undefined) {\n\n        Assert(internals.tlds, 'Built-in TLD list disabled');\n        return Object.assign({}, options, internals.tlds);\n    }\n\n    Assert(typeof options.tlds === 'object', 'tlds must be true, false, or an object');\n\n    const deny = options.tlds.deny;\n    if (deny) {\n        if (Array.isArray(deny)) {\n            options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });\n        }\n\n        Assert(options.tlds.deny instanceof Set, 'tlds.deny must be an array, Set, or boolean');\n        Assert(!options.tlds.allow, 'Cannot specify both tlds.allow and tlds.deny lists');\n        internals.validateTlds(options.tlds.deny, 'tlds.deny');\n        return options;\n    }\n\n    const allow = options.tlds.allow;\n    if (!allow) {\n        return options;\n    }\n\n    if (allow === true) {\n        Assert(internals.tlds, 'Built-in TLD list disabled');\n        return Object.assign({}, options, internals.tlds);\n    }\n\n    if (Array.isArray(allow)) {\n        options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });\n    }\n\n    Assert(options.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');\n    internals.validateTlds(options.tlds.allow, 'tlds.allow');\n    return options;\n};\n\n\ninternals.validateTlds = function (set, source) {\n\n    for (const tld of set) {\n        Assert(Domain.isValid(tld, { minDomainSegments: 1, maxDomainSegments: 1 }), `${source} must contain valid top level domain names`);\n    }\n};\n\n\ninternals.isoDate = function (value) {\n\n    if (!Common.isIsoDate(value)) {\n        return null;\n    }\n\n    if (/.*T.*[+-]\\d\\d$/.test(value)) {             // Add missing trailing zeros to timeshift\n        value += '00';\n    }\n\n    const date = new Date(value);\n    if (isNaN(date.getTime())) {\n        return null;\n    }\n\n    return date.toISOString();\n};\n\n\ninternals.length = function (schema, name, limit, operator, encoding) {\n\n    Assert(!encoding || Buffer && Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);      // $lab:coverage:ignore$\n\n    return schema.$_addRule({ name, method: 'length', args: { limit, encoding }, operator });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9zdHJpbmcuanM/NmUwYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0RBQXVCO0FBQzlDLGVBQWUsbUJBQU8sQ0FBQyxnRUFBNkI7QUFDcEQsY0FBYyxtQkFBTyxDQUFDLDhEQUE0QjtBQUNsRCxXQUFXLG1CQUFPLENBQUMsd0RBQXlCO0FBQzVDLG9CQUFvQixtQkFBTyxDQUFDLDhEQUE0QjtBQUN4RCxhQUFhLG1CQUFPLENBQUMsNERBQTJCO0FBQ2hELFlBQVksbUJBQU8sQ0FBQywwREFBMEI7O0FBRTlDLFlBQVksbUJBQU8sQ0FBQyxrREFBTztBQUMzQixlQUFlLG1CQUFPLENBQUMsbURBQVc7OztBQUdsQztBQUNBLGlDQUFpQyxRQUFRLDBCQUEwQixFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUU7QUFDbkUsdUNBQXVDLEVBQUUsZUFBZSxFQUFFLG9CQUFvQixFQUFFLGtCQUFrQixFQUFFO0FBQ3BHLFNBQVM7QUFDVDtBQUNBLDhCQUE4QixFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFO0FBQ3RFLHVDQUF1QyxFQUFFLGVBQWUsRUFBRSxvQkFBb0IsRUFBRSxxQkFBcUIsRUFBRTtBQUN2RztBQUNBLEtBQUs7QUFDTCw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxLQUFLO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDLG1CQUFtQjtBQUNuQixLQUFLOztBQUVMOztBQUVBLHVCQUF1QjtBQUN2QixLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCOztB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QUF5QixRQUFRO0FBQ2pDLHFDQUFxQyxRQUFRLGtEQUFrRCxTQUFTO0FBQ3hHLHFDQUFxQyxRQUFRO0FBQzdDLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWSxRQUFRLHNCQUFzQixFQUFFO0FBQ2xGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBLGtDQUFrQyxZQUFZLFFBQVEsd0JBQXdCLEVBQUU7QUFDaEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0Esb0NBQW9DLDZDQUE2QyxNQUFNLE9BQU87QUFDOUY7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBLDhGQUE4Rjs7QUFFOUYsNkJBQTZCLGdDQUFnQyxrQkFBa0IsWUFBWTtBQUMzRiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL3N0cmluZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBEb21haW4gPSByZXF1aXJlKCdAc2lkZXdheS9hZGRyZXNzL2xpYi9kb21haW4nKTtcbmNvbnN0IEVtYWlsID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvZW1haWwnKTtcbmNvbnN0IElwID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvaXAnKTtcbmNvbnN0IEVzY2FwZVJlZ2V4ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZXNjYXBlUmVnZXgnKTtcbmNvbnN0IFRsZHMgPSByZXF1aXJlKCdAc2lkZXdheS9hZGRyZXNzL2xpYi90bGRzJyk7XG5jb25zdCBVcmkgPSByZXF1aXJlKCdAc2lkZXdheS9hZGRyZXNzL2xpYi91cmknKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICB0bGRzOiBUbGRzIGluc3RhbmNlb2YgU2V0ID8geyB0bGRzOiB7IGFsbG93OiBUbGRzLCBkZW55OiBudWxsIH0gfSA6IGZhbHNlLCAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgYmFzZTY0UmVnZXg6IHtcbiAgICAgICAgLy8gcGFkZGluZ1JlcXVpcmVkXG4gICAgICAgIHRydWU6IHtcbiAgICAgICAgICAgIC8vIHVybFNhZmVcbiAgICAgICAgICAgIHRydWU6IC9eKD86W1xcd1xcLV17Mn1bXFx3XFwtXXsyfSkqKD86W1xcd1xcLV17Mn09PXxbXFx3XFwtXXszfT0pPyQvLFxuICAgICAgICAgICAgZmFsc2U6IC9eKD86W0EtWmEtejAtOStcXC9dezJ9W0EtWmEtejAtOStcXC9dezJ9KSooPzpbQS1aYS16MC05K1xcL117Mn09PXxbQS1aYS16MC05K1xcL117M309KT8kL1xuICAgICAgICB9LFxuICAgICAgICBmYWxzZToge1xuICAgICAgICAgICAgdHJ1ZTogL14oPzpbXFx3XFwtXXsyfVtcXHdcXC1dezJ9KSooPzpbXFx3XFwtXXsyfSg9PSk/fFtcXHdcXC1dezN9PT8pPyQvLFxuICAgICAgICAgICAgZmFsc2U6IC9eKD86W0EtWmEtejAtOStcXC9dezJ9W0EtWmEtejAtOStcXC9dezJ9KSooPzpbQS1aYS16MC05K1xcL117Mn0oPT0pP3xbQS1aYS16MC05K1xcL117M309Pyk/JC9cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YVVyaVJlZ2V4OiAvXmRhdGE6W1xcdysuLV0rXFwvW1xcdysuLV0rOygoY2hhcnNldD1bXFx3LV0rfGJhc2U2NCksKT8oLiopJC8sXG4gICAgaGV4UmVnZXg6IC9eW2EtZjAtOV0rJC9pLFxuICAgIGlwUmVnZXg6IElwLnJlZ2V4KCkucmVnZXgsXG4gICAgaXNvRHVyYXRpb25SZWdleDogL15QKD8hJCkoXFxkK1kpPyhcXGQrTSk/KFxcZCtXKT8oXFxkK0QpPyhUKD89XFxkKShcXGQrSCk/KFxcZCtNKT8oXFxkK1MpPyk/JC8sXG5cbiAgICBndWlkQnJhY2tldHM6IHtcbiAgICAgICAgJ3snOiAnfScsICdbJzogJ10nLCAnKCc6ICcpJywgJyc6ICcnXG4gICAgfSxcbiAgICBndWlkVmVyc2lvbnM6IHtcbiAgICAgICAgdXVpZHYxOiAnMScsXG4gICAgICAgIHV1aWR2MjogJzInLFxuICAgICAgICB1dWlkdjM6ICczJyxcbiAgICAgICAgdXVpZHY0OiAnNCcsXG4gICAgICAgIHV1aWR2NTogJzUnXG4gICAgfSxcbiAgICBndWlkU2VwYXJhdG9yczogbmV3IFNldChbdW5kZWZpbmVkLCB0cnVlLCBmYWxzZSwgJy0nLCAnOiddKSxcblxuICAgIG5vcm1hbGl6YXRpb25Gb3JtczogWydORkMnLCAnTkZEJywgJ05GS0MnLCAnTkZLRCddXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnc3RyaW5nJyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgaW5zZW5zaXRpdmU6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgdHJ1bmNhdGU6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIHJlcGxhY2VtZW50czogeyBpbml0OiBudWxsIH1cbiAgICB9LFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206ICdzdHJpbmcnLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hLCBzdGF0ZSwgcHJlZnMgfSkge1xuXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemUgPSBzY2hlbWEuJF9nZXRSdWxlKCdub3JtYWxpemUnKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm5vcm1hbGl6ZShub3JtYWxpemUuYXJncy5mb3JtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2FzaW5nID0gc2NoZW1hLiRfZ2V0UnVsZSgnY2FzZScpO1xuICAgICAgICAgICAgaWYgKGNhc2luZykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY2FzaW5nLmFyZ3MuZGlyZWN0aW9uID09PSAndXBwZXInID8gdmFsdWUudG9Mb2NhbGVVcHBlckNhc2UoKSA6IHZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRyaW0gPSBzY2hlbWEuJF9nZXRSdWxlKCd0cmltJyk7XG4gICAgICAgICAgICBpZiAodHJpbSAmJlxuICAgICAgICAgICAgICAgIHRyaW0uYXJncy5lbmFibGVkKSB7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVwbGFjZW1lbnQgb2Ygc2NoZW1hLiRfdGVybXMucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZXBsYWNlbWVudC5wYXR0ZXJuLCByZXBsYWNlbWVudC5yZXBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBoZXggPSBzY2hlbWEuJF9nZXRSdWxlKCdoZXgnKTtcbiAgICAgICAgICAgIGlmIChoZXggJiZcbiAgICAgICAgICAgICAgICBoZXguYXJncy5vcHRpb25zLmJ5dGVBbGlnbmVkICYmXG4gICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoICUgMiAhPT0gMCkge1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBgMCR7dmFsdWV9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS4kX2dldFJ1bGUoJ2lzb0RhdGUnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzbyA9IGludGVybmFscy5pc29EYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXNvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3MudHJ1bmNhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gc2NoZW1hLiRfZ2V0UnVsZSgnbWF4Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbWl0ID0gcnVsZS5hcmdzLmxpbWl0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZShsaW1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0ID0gbGltaXQucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQ29tbW9uLmxpbWl0KGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkucmVmJywgbGltaXQsIHsgcmVmOiBydWxlLmFyZ3MubGltaXQsIGFyZzogJ2xpbWl0JywgcmVhc29uOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInIH0sIHN0YXRlLCBwcmVmcykgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgbGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdzdHJpbmcuYmFzZScpIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignc3RyaW5nLmVtcHR5JykgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGFscGhhbnVtOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2FscGhhbnVtJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmICgvXlthLXpBLVowLTldKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmFscGhhbnVtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmFzZTY0OiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ3BhZGRpbmdSZXF1aXJlZCcsICd1cmxTYWZlJ10pO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgdXJsU2FmZTogZmFsc2UsIHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSwgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQgPT09ICdib29sZWFuJywgJ3BhZGRpbmdSZXF1aXJlZCBtdXN0IGJlIGJvb2xlYW4nKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMudXJsU2FmZSA9PT0gJ2Jvb2xlYW4nLCAndXJsU2FmZSBtdXN0IGJlIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdiYXNlNjQnLCBhcmdzOiB7IG9wdGlvbnMgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gaW50ZXJuYWxzLmJhc2U2NFJlZ2V4W29wdGlvbnMucGFkZGluZ1JlcXVpcmVkXVtvcHRpb25zLnVybFNhZmVdO1xuICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5iYXNlNjQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjYXNlOiB7XG4gICAgICAgICAgICBtZXRob2QoZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWydsb3dlcicsICd1cHBlciddLmluY2x1ZGVzKGRpcmVjdGlvbiksICdJbnZhbGlkIGNhc2U6JywgZGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdjYXNlJywgYXJnczogeyBkaXJlY3Rpb24gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBkaXJlY3Rpb24gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2xvd2VyJyAmJiB2YWx1ZSA9PT0gdmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPT09ICd1cHBlcicgJiYgdmFsdWUgPT09IHZhbHVlLnRvTG9jYWxlVXBwZXJDYXNlKCkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoYHN0cmluZy4ke2RpcmVjdGlvbn1jYXNlYCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWRpdENhcmQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnY3JlZGl0Q2FyZCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgaSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgbXVsID0gMTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhciA9IHZhbHVlLmNoYXJBdChpKSAqIG11bDtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtICsgKGNoYXIgLSAoY2hhciA+IDkpICogOSk7XG4gICAgICAgICAgICAgICAgICAgIG11bCA9IG11bCBeIDM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN1bSA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgc3VtICUgMTAgPT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5jcmVkaXRDYXJkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF0YVVyaToge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydwYWRkaW5nUmVxdWlyZWQnXSk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyBwYWRkaW5nUmVxdWlyZWQ6IHRydWUsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMucGFkZGluZ1JlcXVpcmVkID09PSAnYm9vbGVhbicsICdwYWRkaW5nUmVxdWlyZWQgbXVzdCBiZSBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZGF0YVVyaScsIGFyZ3M6IHsgb3B0aW9ucyB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlLm1hdGNoKGludGVybmFscy5kYXRhVXJpUmVnZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1syXSAhPT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NHJlZ2V4ID0gaW50ZXJuYWxzLmJhc2U2NFJlZ2V4W29wdGlvbnMucGFkZGluZ1JlcXVpcmVkXS5mYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2U2NHJlZ2V4LnRlc3QobWF0Y2hlc1szXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZGF0YVVyaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRvbWFpbjoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYWxsb3dVbmljb2RlJywgJ21heERvbWFpblNlZ21lbnRzJywgJ21pbkRvbWFpblNlZ21lbnRzJywgJ3RsZHMnXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGludGVybmFscy5hZGRyZXNzT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZG9tYWluJywgYXJnczogeyBvcHRpb25zIH0sIGFkZHJlc3MgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIGFyZ3MsIHsgYWRkcmVzcyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoRG9tYWluLmlzVmFsaWQodmFsdWUsIGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmRvbWFpbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGVtYWlsOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsbG93VW5pY29kZScsICdpZ25vcmVMZW5ndGgnLCAnbWF4RG9tYWluU2VnbWVudHMnLCAnbWluRG9tYWluU2VnbWVudHMnLCAnbXVsdGlwbGUnLCAnc2VwYXJhdG9yJywgJ3RsZHMnXSk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KG9wdGlvbnMubXVsdGlwbGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucy5tdWx0aXBsZSA9PT0gJ2Jvb2xlYW4nLCAnbXVsdGlwbGUgb3B0aW9uIG11c3QgYmUgYW4gYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGludGVybmFscy5hZGRyZXNzT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxzKlske29wdGlvbnMuc2VwYXJhdG9yID8gRXNjYXBlUmVnZXgob3B0aW9ucy5zZXBhcmF0b3IpIDogJywnfV1cXFxccypgKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdlbWFpbCcsIGFyZ3M6IHsgb3B0aW9ucyB9LCByZWdleCwgYWRkcmVzcyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0sIHsgcmVnZXgsIGFkZHJlc3MgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZW1haWxzID0gb3B0aW9ucy5tdWx0aXBsZSA/IHZhbHVlLnNwbGl0KHJlZ2V4KSA6IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVtYWlsIG9mIGVtYWlscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUVtYWlsLmlzVmFsaWQoZW1haWwsIGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkcy5wdXNoKGVtYWlsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaW52YWxpZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmVtYWlsJywgeyB2YWx1ZSwgaW52YWxpZHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ3VpZDoge1xuICAgICAgICAgICAgYWxpYXM6ICd1dWlkJyxcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsndmVyc2lvbicsICdzZXBhcmF0b3InXSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgdmVyc2lvbk51bWJlcnMgPSAnJztcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbnMgPSBbXS5jb25jYXQob3B0aW9ucy52ZXJzaW9uKTtcblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQodmVyc2lvbnMubGVuZ3RoID49IDEsICd2ZXJzaW9uIG11c3QgaGF2ZSBhdCBsZWFzdCAxIHZhbGlkIHZlcnNpb24gc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gdmVyc2lvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbk51bWJlciA9IGludGVybmFscy5ndWlkVmVyc2lvbnNbdmVyc2lvbi50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydCh2ZXJzaW9uTnVtYmVyLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBiZSBvbmUgb2YgJyArIE9iamVjdC5rZXlzKGludGVybmFscy5ndWlkVmVyc2lvbnMpLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KCFzZXQuaGFzKHZlcnNpb25OdW1iZXIpLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBub3QgYmUgYSBkdXBsaWNhdGUnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbk51bWJlcnMgKz0gdmVyc2lvbk51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5hZGQodmVyc2lvbk51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoaW50ZXJuYWxzLmd1aWRTZXBhcmF0b3JzLmhhcyhvcHRpb25zLnNlcGFyYXRvciksICdzZXBhcmF0b3IgbXVzdCBiZSBvbmUgb2YgdHJ1ZSwgZmFsc2UsIFwiLVwiLCBvciBcIjpcIicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IG9wdGlvbnMuc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnWzotXT8nIDpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZXBhcmF0b3IgPT09IHRydWUgPyAnWzotXScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZXBhcmF0b3IgPT09IGZhbHNlID8gJ1tdPycgOiBgXFxcXCR7b3B0aW9ucy5zZXBhcmF0b3J9YDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXihbXFxcXFt7XFxcXChdPylbMC05QS1GXXs4fSgke3NlcGFyYXRvcn0pWzAtOUEtRl17NH1cXFxcMj9bJHt2ZXJzaW9uTnVtYmVycyB8fCAnMC05QS1GJ31dWzAtOUEtRl17M31cXFxcMj9bJHt2ZXJzaW9uTnVtYmVycyA/ICc4OUFCJyA6ICcwLTlBLUYnfV1bMC05QS1GXXszfVxcXFwyP1swLTlBLUZdezEyfShbXFxcXF19XFxcXCldPykkYCwgJ2knKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdndWlkJywgYXJnczogeyBvcHRpb25zIH0sIHJlZ2V4IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCBhcmdzLCB7IHJlZ2V4IH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSByZWdleC5leGVjKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmd1aWQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYXRjaGluZyBicmFjZXNcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZ3VpZEJyYWNrZXRzW3Jlc3VsdHNbMV1dICE9PSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5ndWlkJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhleDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydieXRlQWxpZ25lZCddKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IGJ5dGVBbGlnbmVkOiBmYWxzZSwgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy5ieXRlQWxpZ25lZCA9PT0gJ2Jvb2xlYW4nLCAnYnl0ZUFsaWduZWQgbXVzdCBiZSBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnaGV4JywgYXJnczogeyBvcHRpb25zIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWludGVybmFscy5oZXhSZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmhleCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVBbGlnbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmxlbmd0aCAlIDIgIT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmhleEFsaWduJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhvc3RuYW1lOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2hvc3RuYW1lJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChEb21haW4uaXNWYWxpZCh2YWx1ZSwgeyBtaW5Eb21haW5TZWdtZW50czogMSB9KSB8fFxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuaXBSZWdleC50ZXN0KHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmhvc3RuYW1lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5zZW5zaXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnaW5zZW5zaXRpdmUnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpcDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydjaWRyJywgJ3ZlcnNpb24nXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGNpZHIsIHZlcnNpb25zLCByZWdleCB9ID0gSXAucmVnZXgob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbiA/IHZlcnNpb25zIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdpcCcsIGFyZ3M6IHsgb3B0aW9uczogeyBjaWRyLCB2ZXJzaW9uIH0gfSwgcmVnZXggfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9LCB7IHJlZ2V4IH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmlwVmVyc2lvbicsIHsgdmFsdWUsIGNpZHI6IG9wdGlvbnMuY2lkciwgdmVyc2lvbjogb3B0aW9ucy52ZXJzaW9uIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuaXAnLCB7IHZhbHVlLCBjaWRyOiBvcHRpb25zLmNpZHIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvRGF0ZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdpc29EYXRlJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5pc29EYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdzdHJpbmcuaXNvRGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzb0R1cmF0aW9uOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2lzb0R1cmF0aW9uJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuaXNvRHVyYXRpb25SZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5pc29EdXJhdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0LCBlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5sZW5ndGgodGhpcywgJ2xlbmd0aCcsIGxpbWl0LCAnPScsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCwgZW5jb2RpbmcgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBlbmNvZGluZyA/IEJ1ZmZlciAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSwgZW5jb2RpbmcpIDogdmFsdWUubGVuZ3RoOyAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZShsZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlLCBlbmNvZGluZyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZW5jb2RpbmcnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbG93ZXJjYXNlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYXNlKCdsb3dlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0LCBlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5sZW5ndGgodGhpcywgJ21heCcsIGxpbWl0LCAnPD0nLCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydsaW1pdCcsICdlbmNvZGluZyddXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQsIGVuY29kaW5nKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmxlbmd0aCh0aGlzLCAnbWluJywgbGltaXQsICc+PScsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2xpbWl0JywgJ2VuY29kaW5nJ11cbiAgICAgICAgfSxcblxuICAgICAgICBub3JtYWxpemU6IHtcbiAgICAgICAgICAgIG1ldGhvZChmb3JtID0gJ05GQycpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChpbnRlcm5hbHMubm9ybWFsaXphdGlvbkZvcm1zLmluY2x1ZGVzKGZvcm0pLCAnbm9ybWFsaXphdGlvbiBmb3JtIG11c3QgYmUgb25lIG9mICcgKyBpbnRlcm5hbHMubm9ybWFsaXphdGlvbkZvcm1zLmpvaW4oJywgJykpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ25vcm1hbGl6ZScsIGFyZ3M6IHsgZm9ybSB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0sIHsgZm9ybSB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHZhbHVlLm5vcm1hbGl6ZShmb3JtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdzdHJpbmcubm9ybWFsaXplJywgeyB2YWx1ZSwgZm9ybSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb252ZXJ0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF0dGVybjoge1xuICAgICAgICAgICAgYWxpYXM6ICdyZWdleCcsXG4gICAgICAgICAgICBtZXRob2QocmVnZXgsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwLCAncmVnZXggbXVzdCBiZSBhIFJlZ0V4cCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghcmVnZXguZmxhZ3MuaW5jbHVkZXMoJ2cnKSAmJiAhcmVnZXguZmxhZ3MuaW5jbHVkZXMoJ3knKSwgJ3JlZ2V4IHNob3VsZCBub3QgdXNlIGdsb2JhbCBvciBzdGlja3kgbW9kZScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0geyBuYW1lOiBvcHRpb25zIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydpbnZlcnQnLCAnbmFtZSddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IFsnc3RyaW5nLnBhdHRlcm4nLCBvcHRpb25zLmludmVydCA/ICcuaW52ZXJ0JyA6ICcnLCBvcHRpb25zLm5hbWUgPyAnLm5hbWUnIDogJy5iYXNlJ10uam9pbignJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3BhdHRlcm4nLCBhcmdzOiB7IHJlZ2V4LCBvcHRpb25zIH0sIGVycm9yQ29kZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyByZWdleCwgb3B0aW9ucyB9LCB7IGVycm9yQ29kZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuTWF0Y2ggPSByZWdleC50ZXN0KHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuTWF0Y2ggXiBvcHRpb25zLmludmVydCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoZXJyb3JDb2RlLCB7IG5hbWU6IG9wdGlvbnMubmFtZSwgcmVnZXgsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsncmVnZXgnLCAnb3B0aW9ucyddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICByZXBsYWNlOiB7XG4gICAgICAgICAgICBtZXRob2QocGF0dGVybiwgcmVwbGFjZW1lbnQpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAoRXNjYXBlUmVnZXgocGF0dGVybiksICdnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHAsICdwYXR0ZXJuIG11c3QgYmUgYSBSZWdFeHAnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHJlcGxhY2VtZW50ID09PSAnc3RyaW5nJywgJ3JlcGxhY2VtZW50IG11c3QgYmUgYSBTdHJpbmcnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXMucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlcGxhY2VtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlcGxhY2VtZW50cy5wdXNoKHsgcGF0dGVybiwgcmVwbGFjZW1lbnQgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b2tlbjoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCd0b2tlbicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoL15cXHcrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudG9rZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0cmltOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nLCAnZW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3RyaW0nLCBhcmdzOiB7IGVuYWJsZWQgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBlbmFibGVkIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICghZW5hYmxlZCB8fFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gdmFsdWUudHJpbSgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudHJpbScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICB0cnVuY2F0ZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ2VuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndHJ1bmNhdGUnLCBlbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cHBlcmNhc2U6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhc2UoJ3VwcGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXJpOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsbG93UmVsYXRpdmUnLCAnYWxsb3dRdWVyeVNxdWFyZUJyYWNrZXRzJywgJ2RvbWFpbicsICdyZWxhdGl2ZU9ubHknLCAnc2NoZW1lJ10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMuZG9tYWluLCBbJ2FsbG93VW5pY29kZScsICdtYXhEb21haW5TZWdtZW50cycsICdtaW5Eb21haW5TZWdtZW50cycsICd0bGRzJ10pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVnZXgsIHNjaGVtZSB9ID0gVXJpLnJlZ2V4KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IG9wdGlvbnMuZG9tYWluID8gaW50ZXJuYWxzLmFkZHJlc3NPcHRpb25zKG9wdGlvbnMuZG9tYWluKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3VyaScsIGFyZ3M6IHsgb3B0aW9ucyB9LCByZWdleCwgZG9tYWluLCBzY2hlbWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9LCB7IHJlZ2V4LCBkb21haW4sIHNjaGVtZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoWydodHRwOi8nLCAnaHR0cHM6LyddLmluY2x1ZGVzKHZhbHVlKSkgeyAgICAgICAgICAgIC8vIHNjaGVtZTovIGlzIHRlY2huaWNhbGx5IHZhbGlkIGJ1dCBtYWtlcyBubyBzZW5zZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZWQgPSBtYXRjaFsxXSB8fCBtYXRjaFsyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFvcHRpb25zLmFsbG93UmVsYXRpdmUgfHwgbWF0Y2hlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEb21haW4uaXNWYWxpZChtYXRjaGVkLCBkb21haW4pKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZG9tYWluJywgeyB2YWx1ZTogbWF0Y2hlZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZWxhdGl2ZU9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy51cmlSZWxhdGl2ZU9ubHknKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy51cmlDdXN0b21TY2hlbWUnLCB7IHNjaGVtZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy51cmknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5yZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcGF0dGVybiwgcmVwbGFjZW1lbnQgfSBvZiBkZXNjLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdzdHJpbmcuYWxwaGFudW0nOiAne3sjbGFiZWx9fSBtdXN0IG9ubHkgY29udGFpbiBhbHBoYS1udW1lcmljIGNoYXJhY3RlcnMnLFxuICAgICAgICAnc3RyaW5nLmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgc3RyaW5nJyxcbiAgICAgICAgJ3N0cmluZy5iYXNlNjQnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgYmFzZTY0IHN0cmluZycsXG4gICAgICAgICdzdHJpbmcuY3JlZGl0Q2FyZCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBjcmVkaXQgY2FyZCcsXG4gICAgICAgICdzdHJpbmcuZGF0YVVyaSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBkYXRhVXJpIHN0cmluZycsXG4gICAgICAgICdzdHJpbmcuZG9tYWluJzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIGEgdmFsaWQgZG9tYWluIG5hbWUnLFxuICAgICAgICAnc3RyaW5nLmVtYWlsJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGVtYWlsJyxcbiAgICAgICAgJ3N0cmluZy5lbXB0eSc6ICd7eyNsYWJlbH19IGlzIG5vdCBhbGxvd2VkIHRvIGJlIGVtcHR5JyxcbiAgICAgICAgJ3N0cmluZy5ndWlkJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIEdVSUQnLFxuICAgICAgICAnc3RyaW5nLmhleCc6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMnLFxuICAgICAgICAnc3RyaW5nLmhleEFsaWduJzogJ3t7I2xhYmVsfX0gaGV4IGRlY29kZWQgcmVwcmVzZW50YXRpb24gbXVzdCBiZSBieXRlIGFsaWduZWQnLFxuICAgICAgICAnc3RyaW5nLmhvc3RuYW1lJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGhvc3RuYW1lJyxcbiAgICAgICAgJ3N0cmluZy5pcCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBpcCBhZGRyZXNzIHdpdGggYSB7eyNjaWRyfX0gQ0lEUicsXG4gICAgICAgICdzdHJpbmcuaXBWZXJzaW9uJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGlwIGFkZHJlc3Mgb2Ygb25lIG9mIHRoZSBmb2xsb3dpbmcgdmVyc2lvbnMge3sjdmVyc2lvbn19IHdpdGggYSB7eyNjaWRyfX0gQ0lEUicsXG4gICAgICAgICdzdHJpbmcuaXNvRGF0ZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgaW4gaXNvIGZvcm1hdCcsXG4gICAgICAgICdzdHJpbmcuaXNvRHVyYXRpb24nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgSVNPIDg2MDEgZHVyYXRpb24nLFxuICAgICAgICAnc3RyaW5nLmxlbmd0aCc6ICd7eyNsYWJlbH19IGxlbmd0aCBtdXN0IGJlIHt7I2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgJ3N0cmluZy5sb3dlcmNhc2UnOiAne3sjbGFiZWx9fSBtdXN0IG9ubHkgY29udGFpbiBsb3dlcmNhc2UgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcubWF4JzogJ3t7I2xhYmVsfX0gbGVuZ3RoIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgJ3N0cmluZy5taW4nOiAne3sjbGFiZWx9fSBsZW5ndGggbXVzdCBiZSBhdCBsZWFzdCB7eyNsaW1pdH19IGNoYXJhY3RlcnMgbG9uZycsXG4gICAgICAgICdzdHJpbmcubm9ybWFsaXplJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSB1bmljb2RlIG5vcm1hbGl6ZWQgaW4gdGhlIHt7I2Zvcm19fSBmb3JtJyxcbiAgICAgICAgJ3N0cmluZy50b2tlbic6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIGFscGhhLW51bWVyaWMgYW5kIHVuZGVyc2NvcmUgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5iYXNlJzogJ3t7I2xhYmVsfX0gd2l0aCB2YWx1ZSB7OlsuXX0gZmFpbHMgdG8gbWF0Y2ggdGhlIHJlcXVpcmVkIHBhdHRlcm46IHt7I3JlZ2V4fX0nLFxuICAgICAgICAnc3RyaW5nLnBhdHRlcm4ubmFtZSc6ICd7eyNsYWJlbH19IHdpdGggdmFsdWUgezpbLl19IGZhaWxzIHRvIG1hdGNoIHRoZSB7eyNuYW1lfX0gcGF0dGVybicsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5pbnZlcnQuYmFzZSc6ICd7eyNsYWJlbH19IHdpdGggdmFsdWUgezpbLl19IG1hdGNoZXMgdGhlIGludmVydGVkIHBhdHRlcm46IHt7I3JlZ2V4fX0nLFxuICAgICAgICAnc3RyaW5nLnBhdHRlcm4uaW52ZXJ0Lm5hbWUnOiAne3sjbGFiZWx9fSB3aXRoIHZhbHVlIHs6Wy5dfSBtYXRjaGVzIHRoZSBpbnZlcnRlZCB7eyNuYW1lfX0gcGF0dGVybicsXG4gICAgICAgICdzdHJpbmcudHJpbSc6ICd7eyNsYWJlbH19IG11c3Qgbm90IGhhdmUgbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlJyxcbiAgICAgICAgJ3N0cmluZy51cmknOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgdXJpJyxcbiAgICAgICAgJ3N0cmluZy51cmlDdXN0b21TY2hlbWUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgdXJpIHdpdGggYSBzY2hlbWUgbWF0Y2hpbmcgdGhlIHt7I3NjaGVtZX19IHBhdHRlcm4nLFxuICAgICAgICAnc3RyaW5nLnVyaVJlbGF0aXZlT25seSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCByZWxhdGl2ZSB1cmknLFxuICAgICAgICAnc3RyaW5nLnVwcGVyY2FzZSc6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIHVwcGVyY2FzZSBjaGFyYWN0ZXJzJ1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmFkZHJlc3NPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvLyBtaW5Eb21haW5TZWdtZW50c1xuXG4gICAgQXNzZXJ0KG9wdGlvbnMubWluRG9tYWluU2VnbWVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBOdW1iZXIuaXNTYWZlSW50ZWdlcihvcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzKSAmJiBvcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzID4gMCwgJ21pbkRvbWFpblNlZ21lbnRzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAvLyBtYXhEb21haW5TZWdtZW50c1xuXG4gICAgQXNzZXJ0KG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBOdW1iZXIuaXNTYWZlSW50ZWdlcihvcHRpb25zLm1heERvbWFpblNlZ21lbnRzKSAmJiBvcHRpb25zLm1heERvbWFpblNlZ21lbnRzID4gMCwgJ21heERvbWFpblNlZ21lbnRzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAvLyB0bGRzXG5cbiAgICBpZiAob3B0aW9ucy50bGRzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50bGRzID09PSB0cnVlIHx8XG4gICAgICAgIG9wdGlvbnMudGxkcyA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgQXNzZXJ0KGludGVybmFscy50bGRzLCAnQnVpbHQtaW4gVExEIGxpc3QgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIGludGVybmFscy50bGRzKTtcbiAgICB9XG5cbiAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMudGxkcyA9PT0gJ29iamVjdCcsICd0bGRzIG11c3QgYmUgdHJ1ZSwgZmFsc2UsIG9yIGFuIG9iamVjdCcpO1xuXG4gICAgY29uc3QgZGVueSA9IG9wdGlvbnMudGxkcy5kZW55O1xuICAgIGlmIChkZW55KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlbnkpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyB0bGRzOiB7IGRlbnk6IG5ldyBTZXQoZGVueSkgfSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydChvcHRpb25zLnRsZHMuZGVueSBpbnN0YW5jZW9mIFNldCwgJ3RsZHMuZGVueSBtdXN0IGJlIGFuIGFycmF5LCBTZXQsIG9yIGJvb2xlYW4nKTtcbiAgICAgICAgQXNzZXJ0KCFvcHRpb25zLnRsZHMuYWxsb3csICdDYW5ub3Qgc3BlY2lmeSBib3RoIHRsZHMuYWxsb3cgYW5kIHRsZHMuZGVueSBsaXN0cycpO1xuICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGVUbGRzKG9wdGlvbnMudGxkcy5kZW55LCAndGxkcy5kZW55Jyk7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbG93ID0gb3B0aW9ucy50bGRzLmFsbG93O1xuICAgIGlmICghYWxsb3cpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93ID09PSB0cnVlKSB7XG4gICAgICAgIEFzc2VydChpbnRlcm5hbHMudGxkcywgJ0J1aWx0LWluIFRMRCBsaXN0IGRpc2FibGVkJyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBpbnRlcm5hbHMudGxkcyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYWxsb3cpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHRsZHM6IHsgYWxsb3c6IG5ldyBTZXQoYWxsb3cpIH0gfSk7XG4gICAgfVxuXG4gICAgQXNzZXJ0KG9wdGlvbnMudGxkcy5hbGxvdyBpbnN0YW5jZW9mIFNldCwgJ3RsZHMuYWxsb3cgbXVzdCBiZSBhbiBhcnJheSwgU2V0LCBvciBib29sZWFuJyk7XG4gICAgaW50ZXJuYWxzLnZhbGlkYXRlVGxkcyhvcHRpb25zLnRsZHMuYWxsb3csICd0bGRzLmFsbG93Jyk7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5cbmludGVybmFscy52YWxpZGF0ZVRsZHMgPSBmdW5jdGlvbiAoc2V0LCBzb3VyY2UpIHtcblxuICAgIGZvciAoY29uc3QgdGxkIG9mIHNldCkge1xuICAgICAgICBBc3NlcnQoRG9tYWluLmlzVmFsaWQodGxkLCB7IG1pbkRvbWFpblNlZ21lbnRzOiAxLCBtYXhEb21haW5TZWdtZW50czogMSB9KSwgYCR7c291cmNlfSBtdXN0IGNvbnRhaW4gdmFsaWQgdG9wIGxldmVsIGRvbWFpbiBuYW1lc2ApO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmlzb0RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIGlmICghQ29tbW9uLmlzSXNvRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKC8uKlQuKlsrLV1cXGRcXGQkLy50ZXN0KHZhbHVlKSkgeyAgICAgICAgICAgICAvLyBBZGQgbWlzc2luZyB0cmFpbGluZyB6ZXJvcyB0byB0aW1lc2hpZnRcbiAgICAgICAgdmFsdWUgKz0gJzAwJztcbiAgICB9XG5cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcbn07XG5cblxuaW50ZXJuYWxzLmxlbmd0aCA9IGZ1bmN0aW9uIChzY2hlbWEsIG5hbWUsIGxpbWl0LCBvcGVyYXRvciwgZW5jb2RpbmcpIHtcblxuICAgIEFzc2VydCghZW5jb2RpbmcgfHwgQnVmZmVyICYmIEJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSwgJ0ludmFsaWQgZW5jb2Rpbmc6JywgZW5jb2RpbmcpOyAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuXG4gICAgcmV0dXJuIHNjaGVtYS4kX2FkZFJ1bGUoeyBuYW1lLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0LCBlbmNvZGluZyB9LCBvcGVyYXRvciB9KTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/types/string.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/types/symbol.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/symbol.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\n\nconst Any = __webpack_require__(/*! ./any */ \"./node_modules/joi/lib/types/any.js\");\n\n\nconst internals = {};\n\n\ninternals.Map = class extends Map {\n\n    slice() {\n\n        return new internals.Map(this);\n    }\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'symbol',\n\n    terms: {\n\n        map: { init: new internals.Map() }\n    },\n\n    coerce: {\n        method(value, { schema, error }) {\n\n            const lookup = schema.$_terms.map.get(value);\n            if (lookup) {\n                value = lookup;\n            }\n\n            if (!schema._flags.only ||\n                typeof value === 'symbol') {\n\n                return { value };\n            }\n\n            return { value, errors: error('symbol.map', { map: schema.$_terms.map }) };\n        }\n    },\n\n    validate(value, { error }) {\n\n        if (typeof value !== 'symbol') {\n            return { value, errors: error('symbol.base') };\n        }\n    },\n\n    rules: {\n        map: {\n            method(iterable) {\n\n                if (iterable &&\n                    !iterable[Symbol.iterator] &&\n                    typeof iterable === 'object') {\n\n                    iterable = Object.entries(iterable);\n                }\n\n                Assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');\n\n                const obj = this.clone();\n\n                const symbols = [];\n                for (const entry of iterable) {\n                    Assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');\n                    const [key, value] = entry;\n\n                    Assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be of type object, function, or Symbol');\n                    Assert(typeof value === 'symbol', 'Value must be a Symbol');\n\n                    obj.$_terms.map.set(key, value);\n                    symbols.push(value);\n                }\n\n                return obj.valid(...symbols);\n            }\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.map) {\n                obj = obj.map(desc.map);\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'symbol.base': '{{#label}} must be a symbol',\n        'symbol.map': '{{#label}} must be one of {{#map}}'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9zeW1ib2wuanM/ODA1ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0RBQXVCOztBQUU5QyxZQUFZLG1CQUFPLENBQUMsa0RBQU87OztBQUczQjs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjO0FBQ2QsS0FBSzs7QUFFTDtBQUNBLHVCQUF1QixnQkFBZ0I7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCOztBQUVBLG9CQUFvQixxQ0FBcUMsMEJBQTBCO0FBQ25GO0FBQ0EsS0FBSzs7QUFFTCxxQkFBcUIsUUFBUTs7QUFFN0I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDLHlCQUF5QixRQUFRLGtCQUFrQixNQUFNO0FBQ3pEO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL3N5bWJvbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLk1hcCA9IGNsYXNzIGV4dGVuZHMgTWFwIHtcblxuICAgIHNsaWNlKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLk1hcCh0aGlzKTtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnc3ltYm9sJyxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgbWFwOiB7IGluaXQ6IG5ldyBpbnRlcm5hbHMuTWFwKCkgfVxuICAgIH0sXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IgfSkge1xuXG4gICAgICAgICAgICBjb25zdCBsb29rdXAgPSBzY2hlbWEuJF90ZXJtcy5tYXAuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChsb29rdXApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxvb2t1cDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLm9ubHkgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignc3ltYm9sLm1hcCcsIHsgbWFwOiBzY2hlbWEuJF90ZXJtcy5tYXAgfSkgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdzeW1ib2wuYmFzZScpIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcbiAgICAgICAgbWFwOiB7XG4gICAgICAgICAgICBtZXRob2QoaXRlcmFibGUpIHtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVyYWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICAhaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaXRlcmFibGUgPT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QuZW50cmllcyhpdGVyYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KGl0ZXJhYmxlICYmIGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0sICdJdGVyYWJsZSBtdXN0IGJlIGFuIGl0ZXJhYmxlIG9yIG9iamVjdCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ltYm9scyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KGVudHJ5ICYmIGVudHJ5W1N5bWJvbC5pdGVyYXRvcl0sICdFbnRyeSBtdXN0IGJlIGFuIGl0ZXJhYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGVudHJ5O1xuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Yga2V5ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Yga2V5ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBrZXkgIT09ICdzeW1ib2wnLCAnS2V5IG11c3Qgbm90IGJlIG9mIHR5cGUgb2JqZWN0LCBmdW5jdGlvbiwgb3IgU3ltYm9sJyk7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnLCAnVmFsdWUgbXVzdCBiZSBhIFN5bWJvbCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLm1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai52YWxpZCguLi5zeW1ib2xzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5tYXApIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoubWFwKGRlc2MubWFwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnc3ltYm9sLmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgc3ltYm9sJyxcbiAgICAgICAgJ3N5bWJvbC5tYXAnOiAne3sjbGFiZWx9fSBtdXN0IGJlIG9uZSBvZiB7eyNtYXB9fSdcbiAgICB9XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/types/symbol.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/validator.js":
/*!*******************************************!*\
  !*** ./node_modules/joi/lib/validator.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"@hapi/hoek/lib/clone\");\nconst Ignore = __webpack_require__(/*! @hapi/hoek/lib/ignore */ \"@hapi/hoek/lib/ignore\");\nconst Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ \"@hapi/hoek/lib/reach\");\n\nconst Common = __webpack_require__(/*! ./common */ \"./node_modules/joi/lib/common.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"./node_modules/joi/lib/errors.js\");\nconst State = __webpack_require__(/*! ./state */ \"./node_modules/joi/lib/state.js\");\n\n\nconst internals = {\n    result: Symbol('result')\n};\n\n\nexports.entry = function (value, schema, prefs) {\n\n    let settings = Common.defaults;\n    if (prefs) {\n        Assert(prefs.warnings === undefined, 'Cannot override warnings preference in synchronous validation');\n        Assert(prefs.artifacts === undefined, 'Cannot override artifacts preference in synchronous validation');\n        settings = Common.preferences(Common.defaults, prefs);\n    }\n\n    const result = internals.entry(value, schema, settings);\n    Assert(!result.mainstay.externals.length, 'Schema with external rules must use validateAsync()');\n    const outcome = { value: result.value };\n\n    if (result.error) {\n        outcome.error = result.error;\n    }\n\n    if (result.mainstay.warnings.length) {\n        outcome.warning = Errors.details(result.mainstay.warnings);\n    }\n\n    if (result.mainstay.debug) {\n        outcome.debug = result.mainstay.debug;\n    }\n\n    if (result.mainstay.artifacts) {\n        outcome.artifacts = result.mainstay.artifacts;\n    }\n\n    return outcome;\n};\n\n\nexports.entryAsync = async function (value, schema, prefs) {\n\n    let settings = Common.defaults;\n    if (prefs) {\n        settings = Common.preferences(Common.defaults, prefs);\n    }\n\n    const result = internals.entry(value, schema, settings);\n    const mainstay = result.mainstay;\n    if (result.error) {\n        if (mainstay.debug) {\n            result.error.debug = mainstay.debug;\n        }\n\n        throw result.error;\n    }\n\n    if (mainstay.externals.length) {\n        let root = result.value;\n        for (const { method, path, label } of mainstay.externals) {\n            let node = root;\n            let key;\n            let parent;\n\n            if (path.length) {\n                key = path[path.length - 1];\n                parent = Reach(root, path.slice(0, -1));\n                node = parent[key];\n            }\n\n            try {\n                const output = await method(node, { prefs });\n                if (output === undefined ||\n                    output === node) {\n\n                    continue;\n                }\n\n                if (parent) {\n                    parent[key] = output;\n                }\n                else {\n                    root = output;\n                }\n            }\n            catch (err) {\n                err.message += ` (${label})`;       // Change message to include path\n                throw err;\n            }\n        }\n\n        result.value = root;\n    }\n\n    if (!settings.warnings &&\n        !settings.debug &&\n        !settings.artifacts) {\n\n        return result.value;\n    }\n\n    const outcome = { value: result.value };\n    if (mainstay.warnings.length) {\n        outcome.warning = Errors.details(mainstay.warnings);\n    }\n\n    if (mainstay.debug) {\n        outcome.debug = mainstay.debug;\n    }\n\n    if (mainstay.artifacts) {\n        outcome.artifacts = mainstay.artifacts;\n    }\n\n    return outcome;\n};\n\n\ninternals.entry = function (value, schema, prefs) {\n\n    // Prepare state\n\n    const { tracer, cleanup } = internals.tracer(schema, prefs);\n    const debug = prefs.debug ? [] : null;\n    const links = schema._ids._schemaChain ? new Map() : null;\n    const mainstay = { externals: [], warnings: [], tracer, debug, links };\n    const schemas = schema._ids._schemaChain ? [{ schema }] : null;\n    const state = new State([], [], { mainstay, schemas });\n\n    // Validate value\n\n    const result = exports.validate(value, schema, state, prefs);\n\n    // Process value and errors\n\n    if (cleanup) {\n        schema.$_root.untrace();\n    }\n\n    const error = Errors.process(result.errors, value, prefs);\n    return { value: result.value, error, mainstay };\n};\n\n\ninternals.tracer = function (schema, prefs) {\n\n    if (schema.$_root._tracer) {\n        return { tracer: schema.$_root._tracer._register(schema) };\n    }\n\n    if (prefs.debug) {\n        Assert(schema.$_root.trace, 'Debug mode not supported');\n        return { tracer: schema.$_root.trace()._register(schema), cleanup: true };\n    }\n\n    return { tracer: internals.ignore };\n};\n\n\nexports.validate = function (value, schema, state, prefs, overrides = {}) {\n\n    if (schema.$_terms.whens) {\n        schema = schema._generate(value, state, prefs).schema;\n    }\n\n    // Setup state and settings\n\n    if (schema._preferences) {\n        prefs = internals.prefs(schema, prefs);\n    }\n\n    // Cache\n\n    if (schema._cache &&\n        prefs.cache) {\n\n        const result = schema._cache.get(value);\n        state.mainstay.tracer.debug(state, 'validate', 'cached', !!result);\n        if (result) {\n            return result;\n        }\n    }\n\n    // Helpers\n\n    const createError = (code, local, localState) => schema.$_createError(code, value, local, localState || state, prefs);\n    const helpers = {\n        original: value,\n        prefs,\n        schema,\n        state,\n        error: createError,\n        errorsArray: internals.errorsArray,\n        warn: (code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)),\n        message: (messages, local) => schema.$_createError('custom', value, local, state, prefs, { messages })\n    };\n\n    // Prepare\n\n    state.mainstay.tracer.entry(schema, state);\n\n    const def = schema._definition;\n    if (def.prepare &&\n        value !== undefined &&\n        prefs.convert) {\n\n        const prepared = def.prepare(value, helpers);\n        if (prepared) {\n            state.mainstay.tracer.value(state, 'prepare', value, prepared.value);\n            if (prepared.errors) {\n                return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);         // Prepare error always aborts early\n            }\n\n            value = prepared.value;\n        }\n    }\n\n    // Type coercion\n\n    if (def.coerce &&\n        value !== undefined &&\n        prefs.convert &&\n        (!def.coerce.from || def.coerce.from.includes(typeof value))) {\n\n        const coerced = def.coerce.method(value, helpers);\n        if (coerced) {\n            state.mainstay.tracer.value(state, 'coerced', value, coerced.value);\n            if (coerced.errors) {\n                return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);           // Coerce error always aborts early\n            }\n\n            value = coerced.value;\n        }\n    }\n\n    // Empty value\n\n    const empty = schema._flags.empty;\n    if (empty &&\n        empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {\n\n        state.mainstay.tracer.value(state, 'empty', value, undefined);\n        value = undefined;\n    }\n\n    // Presence requirements (required, optional, forbidden)\n\n    const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);\n    if (value === undefined) {\n        if (presence === 'forbidden') {\n            return internals.finalize(value, null, helpers);\n        }\n\n        if (presence === 'required') {\n            return internals.finalize(value, [schema.$_createError('any.required', value, null, state, prefs)], helpers);\n        }\n\n        if (presence === 'optional') {\n            if (schema._flags.default !== Common.symbols.deepDefault) {\n                return internals.finalize(value, null, helpers);\n            }\n\n            state.mainstay.tracer.value(state, 'default', value, {});\n            value = {};\n        }\n    }\n    else if (presence === 'forbidden') {\n        return internals.finalize(value, [schema.$_createError('any.unknown', value, null, state, prefs)], helpers);\n    }\n\n    // Allowed values\n\n    const errors = [];\n\n    if (schema._valids) {\n        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);\n        if (match) {\n            if (prefs.convert) {\n                state.mainstay.tracer.value(state, 'valids', value, match.value);\n                value = match.value;\n            }\n\n            state.mainstay.tracer.filter(schema, state, 'valid', match);\n            return internals.finalize(value, null, helpers);\n        }\n\n        if (schema._flags.only) {\n            const report = schema.$_createError('any.only', value, { valids: schema._valids.values({ display: true }) }, state, prefs);\n            if (prefs.abortEarly) {\n                return internals.finalize(value, [report], helpers);\n            }\n\n            errors.push(report);\n        }\n    }\n\n    // Denied values\n\n    if (schema._invalids) {\n        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);\n        if (match) {\n            state.mainstay.tracer.filter(schema, state, 'invalid', match);\n            const report = schema.$_createError('any.invalid', value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);\n            if (prefs.abortEarly) {\n                return internals.finalize(value, [report], helpers);\n            }\n\n            errors.push(report);\n        }\n    }\n\n    // Base type\n\n    if (def.validate) {\n        const base = def.validate(value, helpers);\n        if (base) {\n            state.mainstay.tracer.value(state, 'base', value, base.value);\n            value = base.value;\n\n            if (base.errors) {\n                if (!Array.isArray(base.errors)) {\n                    errors.push(base.errors);\n                    return internals.finalize(value, errors, helpers);          // Base error always aborts early\n                }\n\n                if (base.errors.length) {\n                    errors.push(...base.errors);\n                    return internals.finalize(value, errors, helpers);          // Base error always aborts early\n                }\n            }\n        }\n    }\n\n    // Validate tests\n\n    if (!schema._rules.length) {\n        return internals.finalize(value, errors, helpers);\n    }\n\n    return internals.rules(value, errors, helpers);\n};\n\n\ninternals.rules = function (value, errors, helpers) {\n\n    const { schema, state, prefs } = helpers;\n\n    for (const rule of schema._rules) {\n        const definition = schema._definition.rules[rule.method];\n\n        // Skip rules that are also applied in coerce step\n\n        if (definition.convert &&\n            prefs.convert) {\n\n            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'full');\n            continue;\n        }\n\n        // Resolve references\n\n        let ret;\n        let args = rule.args;\n        if (rule._resolve.length) {\n            args = Object.assign({}, args);                                     // Shallow copy\n            for (const key of rule._resolve) {\n                const resolver = definition.argsByName.get(key);\n\n                const resolved = args[key].resolve(value, state, prefs);\n                const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;\n\n                const invalid = Common.validateArg(normalized, null, resolver);\n                if (invalid) {\n                    ret = schema.$_createError('any.ref', resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);\n                    break;\n                }\n\n                args[key] = normalized;\n            }\n        }\n\n        // Test rule\n\n        ret = ret || definition.validate(value, helpers, args, rule);           // Use ret if already set to reference error\n\n        const result = internals.rule(ret, rule);\n        if (result.errors) {\n            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'error');\n\n            if (rule.warn) {\n                state.mainstay.warnings.push(...result.errors);\n                continue;\n            }\n\n            if (prefs.abortEarly) {\n                return internals.finalize(value, result.errors, helpers);\n            }\n\n            errors.push(...result.errors);\n        }\n        else {\n            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'pass');\n            state.mainstay.tracer.value(state, 'rule', value, result.value, rule.name);\n            value = result.value;\n        }\n    }\n\n    return internals.finalize(value, errors, helpers);\n};\n\n\ninternals.rule = function (ret, rule) {\n\n    if (ret instanceof Errors.Report) {\n        internals.error(ret, rule);\n        return { errors: [ret], value: null };\n    }\n\n    if (Array.isArray(ret) &&\n        ret[Common.symbols.errors]) {\n\n        ret.forEach((report) => internals.error(report, rule));\n        return { errors: ret, value: null };\n    }\n\n    return { errors: null, value: ret };\n};\n\n\ninternals.error = function (report, rule) {\n\n    if (rule.message) {\n        report._setTemplate(rule.message);\n    }\n\n    return report;\n};\n\n\ninternals.finalize = function (value, errors, helpers) {\n\n    errors = errors || [];\n    const { schema, state, prefs } = helpers;\n\n    // Failover value\n\n    if (errors.length) {\n        const failover = internals.default('failover', undefined, errors, helpers);\n        if (failover !== undefined) {\n            state.mainstay.tracer.value(state, 'failover', value, failover);\n            value = failover;\n            errors = [];\n        }\n    }\n\n    // Error override\n\n    if (errors.length &&\n        schema._flags.error) {\n\n        if (typeof schema._flags.error === 'function') {\n            errors = schema._flags.error(errors);\n            if (!Array.isArray(errors)) {\n                errors = [errors];\n            }\n\n            for (const error of errors) {\n                Assert(error instanceof Error || error instanceof Errors.Report, 'error() must return an Error object');\n            }\n        }\n        else {\n            errors = [schema._flags.error];\n        }\n    }\n\n    // Default\n\n    if (value === undefined) {\n        const defaulted = internals.default('default', value, errors, helpers);\n        state.mainstay.tracer.value(state, 'default', value, defaulted);\n        value = defaulted;\n    }\n\n    // Cast\n\n    if (schema._flags.cast &&\n        value !== undefined) {\n\n        const caster = schema._definition.cast[schema._flags.cast];\n        if (caster.from(value)) {\n            const casted = caster.to(value, helpers);\n            state.mainstay.tracer.value(state, 'cast', value, casted, schema._flags.cast);\n            value = casted;\n        }\n    }\n\n    // Externals\n\n    if (schema.$_terms.externals &&\n        prefs.externals &&\n        prefs._externals !== false) {                       // Disabled for matching\n\n        for (const { method } of schema.$_terms.externals) {\n            state.mainstay.externals.push({ method, path: state.path, label: Errors.label(schema._flags, state, prefs) });\n        }\n    }\n\n    // Result\n\n    const result = { value, errors: errors.length ? errors : null };\n\n    if (schema._flags.result) {\n        result.value = schema._flags.result === 'strip' ? undefined : /* raw */ helpers.original;\n        state.mainstay.tracer.value(state, schema._flags.result, value, result.value);\n        state.shadow(value, schema._flags.result);\n    }\n\n    // Cache\n\n    if (schema._cache &&\n        prefs.cache !== false &&\n        !schema._refs.length) {\n\n        schema._cache.set(helpers.original, result);\n    }\n\n    // Artifacts\n\n    if (value !== undefined &&\n        !result.errors &&\n        schema._flags.artifact !== undefined) {\n\n        state.mainstay.artifacts = state.mainstay.artifacts || new Map();\n        if (!state.mainstay.artifacts.has(schema._flags.artifact)) {\n            state.mainstay.artifacts.set(schema._flags.artifact, []);\n        }\n\n        state.mainstay.artifacts.get(schema._flags.artifact).push(state.path);\n    }\n\n    return result;\n};\n\n\ninternals.prefs = function (schema, prefs) {\n\n    const isDefaultOptions = prefs === Common.defaults;\n    if (isDefaultOptions &&\n        schema._preferences[Common.symbols.prefs]) {\n\n        return schema._preferences[Common.symbols.prefs];\n    }\n\n    prefs = Common.preferences(prefs, schema._preferences);\n    if (isDefaultOptions) {\n        schema._preferences[Common.symbols.prefs] = prefs;\n    }\n\n    return prefs;\n};\n\n\ninternals.default = function (flag, value, errors, helpers) {\n\n    const { schema, state, prefs } = helpers;\n    const source = schema._flags[flag];\n    if (prefs.noDefaults ||\n        source === undefined) {\n\n        return value;\n    }\n\n    state.mainstay.tracer.log(schema, state, 'rule', flag, 'full');\n\n    if (!source) {\n        return source;\n    }\n\n    if (typeof source === 'function') {\n        const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];\n\n        try {\n            return source(...args);\n        }\n        catch (err) {\n            errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));\n            return;\n        }\n    }\n\n    if (typeof source !== 'object') {\n        return source;\n    }\n\n    if (source[Common.symbols.literal]) {\n        return source.literal;\n    }\n\n    if (Common.isResolvable(source)) {\n        return source.resolve(value, state, prefs);\n    }\n\n    return Clone(source);\n};\n\n\ninternals.trim = function (value, schema) {\n\n    if (typeof value !== 'string') {\n        return value;\n    }\n\n    const trim = schema.$_getRule('trim');\n    if (!trim ||\n        !trim.args.enabled) {\n\n        return value;\n    }\n\n    return value.trim();\n};\n\n\ninternals.ignore = {\n    active: false,\n    debug: Ignore,\n    entry: Ignore,\n    filter: Ignore,\n    log: Ignore,\n    resolve: Ignore,\n    value: Ignore\n};\n\n\ninternals.errorsArray = function () {\n\n    const errors = [];\n    errors[Common.symbols.errors] = true;\n    return errors;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi92YWxpZGF0b3IuanM/ZTE3MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0RBQXVCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyxrREFBc0I7QUFDNUMsZUFBZSxtQkFBTyxDQUFDLG9EQUF1QjtBQUM5QyxjQUFjLG1CQUFPLENBQUMsa0RBQXNCOztBQUU1QyxlQUFlLG1CQUFPLENBQUMsa0RBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLGtEQUFVO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxnREFBUzs7O0FBRy9CO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU0sR0FBRztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qixp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QUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxLQUFLLFVBQVUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvam9pL2xpYi92YWxpZGF0b3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgSWdub3JlID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvaWdub3JlJyk7XG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL3JlYWNoJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgU3RhdGUgPSByZXF1aXJlKCcuL3N0YXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHJlc3VsdDogU3ltYm9sKCdyZXN1bHQnKVxufTtcblxuXG5leHBvcnRzLmVudHJ5ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIHByZWZzKSB7XG5cbiAgICBsZXQgc2V0dGluZ3MgPSBDb21tb24uZGVmYXVsdHM7XG4gICAgaWYgKHByZWZzKSB7XG4gICAgICAgIEFzc2VydChwcmVmcy53YXJuaW5ncyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIHdhcm5pbmdzIHByZWZlcmVuY2UgaW4gc3luY2hyb25vdXMgdmFsaWRhdGlvbicpO1xuICAgICAgICBBc3NlcnQocHJlZnMuYXJ0aWZhY3RzID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgYXJ0aWZhY3RzIHByZWZlcmVuY2UgaW4gc3luY2hyb25vdXMgdmFsaWRhdGlvbicpO1xuICAgICAgICBzZXR0aW5ncyA9IENvbW1vbi5wcmVmZXJlbmNlcyhDb21tb24uZGVmYXVsdHMsIHByZWZzKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuZW50cnkodmFsdWUsIHNjaGVtYSwgc2V0dGluZ3MpO1xuICAgIEFzc2VydCghcmVzdWx0Lm1haW5zdGF5LmV4dGVybmFscy5sZW5ndGgsICdTY2hlbWEgd2l0aCBleHRlcm5hbCBydWxlcyBtdXN0IHVzZSB2YWxpZGF0ZUFzeW5jKCknKTtcbiAgICBjb25zdCBvdXRjb21lID0geyB2YWx1ZTogcmVzdWx0LnZhbHVlIH07XG5cbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIG91dGNvbWUuZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5tYWluc3RheS53YXJuaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgb3V0Y29tZS53YXJuaW5nID0gRXJyb3JzLmRldGFpbHMocmVzdWx0Lm1haW5zdGF5Lndhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lm1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgIG91dGNvbWUuZGVidWcgPSByZXN1bHQubWFpbnN0YXkuZGVidWc7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5tYWluc3RheS5hcnRpZmFjdHMpIHtcbiAgICAgICAgb3V0Y29tZS5hcnRpZmFjdHMgPSByZXN1bHQubWFpbnN0YXkuYXJ0aWZhY3RzO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRjb21lO1xufTtcblxuXG5leHBvcnRzLmVudHJ5QXN5bmMgPSBhc3luYyBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgcHJlZnMpIHtcblxuICAgIGxldCBzZXR0aW5ncyA9IENvbW1vbi5kZWZhdWx0cztcbiAgICBpZiAocHJlZnMpIHtcbiAgICAgICAgc2V0dGluZ3MgPSBDb21tb24ucHJlZmVyZW5jZXMoQ29tbW9uLmRlZmF1bHRzLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLmVudHJ5KHZhbHVlLCBzY2hlbWEsIHNldHRpbmdzKTtcbiAgICBjb25zdCBtYWluc3RheSA9IHJlc3VsdC5tYWluc3RheTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIGlmIChtYWluc3RheS5kZWJ1Zykge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yLmRlYnVnID0gbWFpbnN0YXkuZGVidWc7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKG1haW5zdGF5LmV4dGVybmFscy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJvb3QgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGZvciAoY29uc3QgeyBtZXRob2QsIHBhdGgsIGxhYmVsIH0gb2YgbWFpbnN0YXkuZXh0ZXJuYWxzKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHJvb3Q7XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgbGV0IHBhcmVudDtcblxuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IFJlYWNoKHJvb3QsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50W2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgbWV0aG9kKG5vZGUsIHsgcHJlZnMgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9PT0gbm9kZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50W2tleV0gPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb290ID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArPSBgICgke2xhYmVsfSlgOyAgICAgICAvLyBDaGFuZ2UgbWVzc2FnZSB0byBpbmNsdWRlIHBhdGhcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQudmFsdWUgPSByb290O1xuICAgIH1cblxuICAgIGlmICghc2V0dGluZ3Mud2FybmluZ3MgJiZcbiAgICAgICAgIXNldHRpbmdzLmRlYnVnICYmXG4gICAgICAgICFzZXR0aW5ncy5hcnRpZmFjdHMpIHtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IG91dGNvbWUgPSB7IHZhbHVlOiByZXN1bHQudmFsdWUgfTtcbiAgICBpZiAobWFpbnN0YXkud2FybmluZ3MubGVuZ3RoKSB7XG4gICAgICAgIG91dGNvbWUud2FybmluZyA9IEVycm9ycy5kZXRhaWxzKG1haW5zdGF5Lndhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAobWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgb3V0Y29tZS5kZWJ1ZyA9IG1haW5zdGF5LmRlYnVnO1xuICAgIH1cblxuICAgIGlmIChtYWluc3RheS5hcnRpZmFjdHMpIHtcbiAgICAgICAgb3V0Y29tZS5hcnRpZmFjdHMgPSBtYWluc3RheS5hcnRpZmFjdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGNvbWU7XG59O1xuXG5cbmludGVybmFscy5lbnRyeSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCBwcmVmcykge1xuXG4gICAgLy8gUHJlcGFyZSBzdGF0ZVxuXG4gICAgY29uc3QgeyB0cmFjZXIsIGNsZWFudXAgfSA9IGludGVybmFscy50cmFjZXIoc2NoZW1hLCBwcmVmcyk7XG4gICAgY29uc3QgZGVidWcgPSBwcmVmcy5kZWJ1ZyA/IFtdIDogbnVsbDtcbiAgICBjb25zdCBsaW5rcyA9IHNjaGVtYS5faWRzLl9zY2hlbWFDaGFpbiA/IG5ldyBNYXAoKSA6IG51bGw7XG4gICAgY29uc3QgbWFpbnN0YXkgPSB7IGV4dGVybmFsczogW10sIHdhcm5pbmdzOiBbXSwgdHJhY2VyLCBkZWJ1ZywgbGlua3MgfTtcbiAgICBjb25zdCBzY2hlbWFzID0gc2NoZW1hLl9pZHMuX3NjaGVtYUNoYWluID8gW3sgc2NoZW1hIH1dIDogbnVsbDtcbiAgICBjb25zdCBzdGF0ZSA9IG5ldyBTdGF0ZShbXSwgW10sIHsgbWFpbnN0YXksIHNjaGVtYXMgfSk7XG5cbiAgICAvLyBWYWxpZGF0ZSB2YWx1ZVxuXG4gICAgY29uc3QgcmVzdWx0ID0gZXhwb3J0cy52YWxpZGF0ZSh2YWx1ZSwgc2NoZW1hLCBzdGF0ZSwgcHJlZnMpO1xuXG4gICAgLy8gUHJvY2VzcyB2YWx1ZSBhbmQgZXJyb3JzXG5cbiAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICBzY2hlbWEuJF9yb290LnVudHJhY2UoKTtcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvciA9IEVycm9ycy5wcm9jZXNzKHJlc3VsdC5lcnJvcnMsIHZhbHVlLCBwcmVmcyk7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdC52YWx1ZSwgZXJyb3IsIG1haW5zdGF5IH07XG59O1xuXG5cbmludGVybmFscy50cmFjZXIgPSBmdW5jdGlvbiAoc2NoZW1hLCBwcmVmcykge1xuXG4gICAgaWYgKHNjaGVtYS4kX3Jvb3QuX3RyYWNlcikge1xuICAgICAgICByZXR1cm4geyB0cmFjZXI6IHNjaGVtYS4kX3Jvb3QuX3RyYWNlci5fcmVnaXN0ZXIoc2NoZW1hKSB9O1xuICAgIH1cblxuICAgIGlmIChwcmVmcy5kZWJ1Zykge1xuICAgICAgICBBc3NlcnQoc2NoZW1hLiRfcm9vdC50cmFjZSwgJ0RlYnVnIG1vZGUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICByZXR1cm4geyB0cmFjZXI6IHNjaGVtYS4kX3Jvb3QudHJhY2UoKS5fcmVnaXN0ZXIoc2NoZW1hKSwgY2xlYW51cDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IHRyYWNlcjogaW50ZXJuYWxzLmlnbm9yZSB9O1xufTtcblxuXG5leHBvcnRzLnZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIHN0YXRlLCBwcmVmcywgb3ZlcnJpZGVzID0ge30pIHtcblxuICAgIGlmIChzY2hlbWEuJF90ZXJtcy53aGVucykge1xuICAgICAgICBzY2hlbWEgPSBzY2hlbWEuX2dlbmVyYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpLnNjaGVtYTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCBzdGF0ZSBhbmQgc2V0dGluZ3NcblxuICAgIGlmIChzY2hlbWEuX3ByZWZlcmVuY2VzKSB7XG4gICAgICAgIHByZWZzID0gaW50ZXJuYWxzLnByZWZzKHNjaGVtYSwgcHJlZnMpO1xuICAgIH1cblxuICAgIC8vIENhY2hlXG5cbiAgICBpZiAoc2NoZW1hLl9jYWNoZSAmJlxuICAgICAgICBwcmVmcy5jYWNoZSkge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5fY2FjaGUuZ2V0KHZhbHVlKTtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmRlYnVnKHN0YXRlLCAndmFsaWRhdGUnLCAnY2FjaGVkJywgISFyZXN1bHQpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGVscGVyc1xuXG4gICAgY29uc3QgY3JlYXRlRXJyb3IgPSAoY29kZSwgbG9jYWwsIGxvY2FsU3RhdGUpID0+IHNjaGVtYS4kX2NyZWF0ZUVycm9yKGNvZGUsIHZhbHVlLCBsb2NhbCwgbG9jYWxTdGF0ZSB8fCBzdGF0ZSwgcHJlZnMpO1xuICAgIGNvbnN0IGhlbHBlcnMgPSB7XG4gICAgICAgIG9yaWdpbmFsOiB2YWx1ZSxcbiAgICAgICAgcHJlZnMsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcixcbiAgICAgICAgZXJyb3JzQXJyYXk6IGludGVybmFscy5lcnJvcnNBcnJheSxcbiAgICAgICAgd2FybjogKGNvZGUsIGxvY2FsLCBsb2NhbFN0YXRlKSA9PiBzdGF0ZS5tYWluc3RheS53YXJuaW5ncy5wdXNoKGNyZWF0ZUVycm9yKGNvZGUsIGxvY2FsLCBsb2NhbFN0YXRlKSksXG4gICAgICAgIG1lc3NhZ2U6IChtZXNzYWdlcywgbG9jYWwpID0+IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdjdXN0b20nLCB2YWx1ZSwgbG9jYWwsIHN0YXRlLCBwcmVmcywgeyBtZXNzYWdlcyB9KVxuICAgIH07XG5cbiAgICAvLyBQcmVwYXJlXG5cbiAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZW50cnkoc2NoZW1hLCBzdGF0ZSk7XG5cbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX2RlZmluaXRpb247XG4gICAgaWYgKGRlZi5wcmVwYXJlICYmXG4gICAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgcHJlZnMuY29udmVydCkge1xuXG4gICAgICAgIGNvbnN0IHByZXBhcmVkID0gZGVmLnByZXBhcmUodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICBpZiAocHJlcGFyZWQpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ3ByZXBhcmUnLCB2YWx1ZSwgcHJlcGFyZWQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHByZXBhcmVkLmVycm9ycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUocHJlcGFyZWQudmFsdWUsIFtdLmNvbmNhdChwcmVwYXJlZC5lcnJvcnMpLCBoZWxwZXJzKTsgICAgICAgICAvLyBQcmVwYXJlIGVycm9yIGFsd2F5cyBhYm9ydHMgZWFybHlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBwcmVwYXJlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFR5cGUgY29lcmNpb25cblxuICAgIGlmIChkZWYuY29lcmNlICYmXG4gICAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgcHJlZnMuY29udmVydCAmJlxuICAgICAgICAoIWRlZi5jb2VyY2UuZnJvbSB8fCBkZWYuY29lcmNlLmZyb20uaW5jbHVkZXModHlwZW9mIHZhbHVlKSkpIHtcblxuICAgICAgICBjb25zdCBjb2VyY2VkID0gZGVmLmNvZXJjZS5tZXRob2QodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICBpZiAoY29lcmNlZCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnY29lcmNlZCcsIHZhbHVlLCBjb2VyY2VkLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjb2VyY2VkLmVycm9ycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUoY29lcmNlZC52YWx1ZSwgW10uY29uY2F0KGNvZXJjZWQuZXJyb3JzKSwgaGVscGVycyk7ICAgICAgICAgICAvLyBDb2VyY2UgZXJyb3IgYWx3YXlzIGFib3J0cyBlYXJseVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IGNvZXJjZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbXB0eSB2YWx1ZVxuXG4gICAgY29uc3QgZW1wdHkgPSBzY2hlbWEuX2ZsYWdzLmVtcHR5O1xuICAgIGlmIChlbXB0eSAmJlxuICAgICAgICBlbXB0eS4kX21hdGNoKGludGVybmFscy50cmltKHZhbHVlLCBzY2hlbWEpLCBzdGF0ZS5uZXN0KGVtcHR5KSwgQ29tbW9uLmRlZmF1bHRzKSkge1xuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2VtcHR5JywgdmFsdWUsIHVuZGVmaW5lZCk7XG4gICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFByZXNlbmNlIHJlcXVpcmVtZW50cyAocmVxdWlyZWQsIG9wdGlvbmFsLCBmb3JiaWRkZW4pXG5cbiAgICBjb25zdCBwcmVzZW5jZSA9IG92ZXJyaWRlcy5wcmVzZW5jZSB8fCBzY2hlbWEuX2ZsYWdzLnByZXNlbmNlIHx8IChzY2hlbWEuX2ZsYWdzLl9lbmRlZFN3aXRjaCA/IG51bGwgOiBwcmVmcy5wcmVzZW5jZSk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHByZXNlbmNlID09PSAnZm9yYmlkZGVuJykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgbnVsbCwgaGVscGVycyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlc2VuY2UgPT09ICdyZXF1aXJlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LnJlcXVpcmVkJywgdmFsdWUsIG51bGwsIHN0YXRlLCBwcmVmcyldLCBoZWxwZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW5jZSA9PT0gJ29wdGlvbmFsJykge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3MuZGVmYXVsdCAhPT0gQ29tbW9uLnN5bWJvbHMuZGVlcERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBudWxsLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnZGVmYXVsdCcsIHZhbHVlLCB7fSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHByZXNlbmNlID09PSAnZm9yYmlkZGVuJykge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBbc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS51bmtub3duJywgdmFsdWUsIG51bGwsIHN0YXRlLCBwcmVmcyldLCBoZWxwZXJzKTtcbiAgICB9XG5cbiAgICAvLyBBbGxvd2VkIHZhbHVlc1xuXG4gICAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgICBpZiAoc2NoZW1hLl92YWxpZHMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBzY2hlbWEuX3ZhbGlkcy5nZXQodmFsdWUsIHN0YXRlLCBwcmVmcywgc2NoZW1hLl9mbGFncy5pbnNlbnNpdGl2ZSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgaWYgKHByZWZzLmNvbnZlcnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICd2YWxpZHMnLCB2YWx1ZSwgbWF0Y2gudmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbWF0Y2gudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5maWx0ZXIoc2NoZW1hLCBzdGF0ZSwgJ3ZhbGlkJywgbWF0Y2gpO1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgbnVsbCwgaGVscGVycyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NoZW1hLl9mbGFncy5vbmx5KSB7XG4gICAgICAgICAgICBjb25zdCByZXBvcnQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55Lm9ubHknLCB2YWx1ZSwgeyB2YWxpZHM6IHNjaGVtYS5fdmFsaWRzLnZhbHVlcyh7IGRpc3BsYXk6IHRydWUgfSkgfSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgW3JlcG9ydF0sIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcnMucHVzaChyZXBvcnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVuaWVkIHZhbHVlc1xuXG4gICAgaWYgKHNjaGVtYS5faW52YWxpZHMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBzY2hlbWEuX2ludmFsaWRzLmdldCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBzY2hlbWEuX2ZsYWdzLmluc2Vuc2l0aXZlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZmlsdGVyKHNjaGVtYSwgc3RhdGUsICdpbnZhbGlkJywgbWF0Y2gpO1xuICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS5pbnZhbGlkJywgdmFsdWUsIHsgaW52YWxpZHM6IHNjaGVtYS5faW52YWxpZHMudmFsdWVzKHsgZGlzcGxheTogdHJ1ZSB9KSB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBbcmVwb3J0XSwgaGVscGVycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCYXNlIHR5cGVcblxuICAgIGlmIChkZWYudmFsaWRhdGUpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IGRlZi52YWxpZGF0ZSh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdiYXNlJywgdmFsdWUsIGJhc2UudmFsdWUpO1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoYmFzZS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYmFzZS5lcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGJhc2UuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTsgICAgICAgICAgLy8gQmFzZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJhc2UuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5iYXNlLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIGVycm9ycywgaGVscGVycyk7ICAgICAgICAgIC8vIEJhc2UgZXJyb3IgYWx3YXlzIGFib3J0cyBlYXJseVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHRlc3RzXG5cbiAgICBpZiAoIXNjaGVtYS5fcnVsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIGVycm9ycywgaGVscGVycyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5ydWxlcyh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTtcbn07XG5cblxuaW50ZXJuYWxzLnJ1bGVzID0gZnVuY3Rpb24gKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpIHtcblxuICAgIGNvbnN0IHsgc2NoZW1hLCBzdGF0ZSwgcHJlZnMgfSA9IGhlbHBlcnM7XG5cbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2Ygc2NoZW1hLl9ydWxlcykge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gc2NoZW1hLl9kZWZpbml0aW9uLnJ1bGVzW3J1bGUubWV0aG9kXTtcblxuICAgICAgICAvLyBTa2lwIHJ1bGVzIHRoYXQgYXJlIGFsc28gYXBwbGllZCBpbiBjb2VyY2Ugc3RlcFxuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLmNvbnZlcnQgJiZcbiAgICAgICAgICAgIHByZWZzLmNvbnZlcnQpIHtcblxuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIHJ1bGUubmFtZSwgJ2Z1bGwnKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzb2x2ZSByZWZlcmVuY2VzXG5cbiAgICAgICAgbGV0IHJldDtcbiAgICAgICAgbGV0IGFyZ3MgPSBydWxlLmFyZ3M7XG4gICAgICAgIGlmIChydWxlLl9yZXNvbHZlLmxlbmd0aCkge1xuICAgICAgICAgICAgYXJncyA9IE9iamVjdC5hc3NpZ24oe30sIGFyZ3MpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGFsbG93IGNvcHlcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJ1bGUuX3Jlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGRlZmluaXRpb24uYXJnc0J5TmFtZS5nZXQoa2V5KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gYXJnc1trZXldLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IHJlc29sdmVyLm5vcm1hbGl6ZSA/IHJlc29sdmVyLm5vcm1hbGl6ZShyZXNvbHZlZCkgOiByZXNvbHZlZDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWQgPSBDb21tb24udmFsaWRhdGVBcmcobm9ybWFsaXplZCwgbnVsbCwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkucmVmJywgcmVzb2x2ZWQsIHsgYXJnOiBrZXksIHJlZjogYXJnc1trZXldLCByZWFzb246IGludmFsaWQgfSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJnc1trZXldID0gbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlc3QgcnVsZVxuXG4gICAgICAgIHJldCA9IHJldCB8fCBkZWZpbml0aW9uLnZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCBhcmdzLCBydWxlKTsgICAgICAgICAgIC8vIFVzZSByZXQgaWYgYWxyZWFkeSBzZXQgdG8gcmVmZXJlbmNlIGVycm9yXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnJ1bGUocmV0LCBydWxlKTtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5sb2coc2NoZW1hLCBzdGF0ZSwgJ3J1bGUnLCBydWxlLm5hbWUsICdlcnJvcicpO1xuXG4gICAgICAgICAgICBpZiAocnVsZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkud2FybmluZ3MucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCByZXN1bHQuZXJyb3JzLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzdWx0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIubG9nKHNjaGVtYSwgc3RhdGUsICdydWxlJywgcnVsZS5uYW1lLCAncGFzcycpO1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAncnVsZScsIHZhbHVlLCByZXN1bHQudmFsdWUsIHJ1bGUubmFtZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIGVycm9ycywgaGVscGVycyk7XG59O1xuXG5cbmludGVybmFscy5ydWxlID0gZnVuY3Rpb24gKHJldCwgcnVsZSkge1xuXG4gICAgaWYgKHJldCBpbnN0YW5jZW9mIEVycm9ycy5SZXBvcnQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmVycm9yKHJldCwgcnVsZSk7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogW3JldF0sIHZhbHVlOiBudWxsIH07XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmV0KSAmJlxuICAgICAgICByZXRbQ29tbW9uLnN5bWJvbHMuZXJyb3JzXSkge1xuXG4gICAgICAgIHJldC5mb3JFYWNoKChyZXBvcnQpID0+IGludGVybmFscy5lcnJvcihyZXBvcnQsIHJ1bGUpKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiByZXQsIHZhbHVlOiBudWxsIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZXJyb3JzOiBudWxsLCB2YWx1ZTogcmV0IH07XG59O1xuXG5cbmludGVybmFscy5lcnJvciA9IGZ1bmN0aW9uIChyZXBvcnQsIHJ1bGUpIHtcblxuICAgIGlmIChydWxlLm1lc3NhZ2UpIHtcbiAgICAgICAgcmVwb3J0Ll9zZXRUZW1wbGF0ZShydWxlLm1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiByZXBvcnQ7XG59O1xuXG5cbmludGVybmFscy5maW5hbGl6ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKSB7XG5cbiAgICBlcnJvcnMgPSBlcnJvcnMgfHwgW107XG4gICAgY29uc3QgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9ID0gaGVscGVycztcblxuICAgIC8vIEZhaWxvdmVyIHZhbHVlXG5cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBmYWlsb3ZlciA9IGludGVybmFscy5kZWZhdWx0KCdmYWlsb3ZlcicsIHVuZGVmaW5lZCwgZXJyb3JzLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKGZhaWxvdmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2ZhaWxvdmVyJywgdmFsdWUsIGZhaWxvdmVyKTtcbiAgICAgICAgICAgIHZhbHVlID0gZmFpbG92ZXI7XG4gICAgICAgICAgICBlcnJvcnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVycm9yIG92ZXJyaWRlXG5cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCAmJlxuICAgICAgICBzY2hlbWEuX2ZsYWdzLmVycm9yKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuX2ZsYWdzLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBzY2hlbWEuX2ZsYWdzLmVycm9yKGVycm9ycyk7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IFtlcnJvcnNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVycm9yIG9mIGVycm9ycykge1xuICAgICAgICAgICAgICAgIEFzc2VydChlcnJvciBpbnN0YW5jZW9mIEVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCwgJ2Vycm9yKCkgbXVzdCByZXR1cm4gYW4gRXJyb3Igb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBbc2NoZW1hLl9mbGFncy5lcnJvcl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0XG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0ZWQgPSBpbnRlcm5hbHMuZGVmYXVsdCgnZGVmYXVsdCcsIHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpO1xuICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdkZWZhdWx0JywgdmFsdWUsIGRlZmF1bHRlZCk7XG4gICAgICAgIHZhbHVlID0gZGVmYXVsdGVkO1xuICAgIH1cblxuICAgIC8vIENhc3RcblxuICAgIGlmIChzY2hlbWEuX2ZsYWdzLmNhc3QgJiZcbiAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIGNvbnN0IGNhc3RlciA9IHNjaGVtYS5fZGVmaW5pdGlvbi5jYXN0W3NjaGVtYS5fZmxhZ3MuY2FzdF07XG4gICAgICAgIGlmIChjYXN0ZXIuZnJvbSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhc3RlZCA9IGNhc3Rlci50byh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdjYXN0JywgdmFsdWUsIGNhc3RlZCwgc2NoZW1hLl9mbGFncy5jYXN0KTtcbiAgICAgICAgICAgIHZhbHVlID0gY2FzdGVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXh0ZXJuYWxzXG5cbiAgICBpZiAoc2NoZW1hLiRfdGVybXMuZXh0ZXJuYWxzICYmXG4gICAgICAgIHByZWZzLmV4dGVybmFscyAmJlxuICAgICAgICBwcmVmcy5fZXh0ZXJuYWxzICE9PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZWQgZm9yIG1hdGNoaW5nXG5cbiAgICAgICAgZm9yIChjb25zdCB7IG1ldGhvZCB9IG9mIHNjaGVtYS4kX3Rlcm1zLmV4dGVybmFscykge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkuZXh0ZXJuYWxzLnB1c2goeyBtZXRob2QsIHBhdGg6IHN0YXRlLnBhdGgsIGxhYmVsOiBFcnJvcnMubGFiZWwoc2NoZW1hLl9mbGFncywgc3RhdGUsIHByZWZzKSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc3VsdFxuXG4gICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcnMubGVuZ3RoID8gZXJyb3JzIDogbnVsbCB9O1xuXG4gICAgaWYgKHNjaGVtYS5fZmxhZ3MucmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHNjaGVtYS5fZmxhZ3MucmVzdWx0ID09PSAnc3RyaXAnID8gdW5kZWZpbmVkIDogLyogcmF3ICovIGhlbHBlcnMub3JpZ2luYWw7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgc2NoZW1hLl9mbGFncy5yZXN1bHQsIHZhbHVlLCByZXN1bHQudmFsdWUpO1xuICAgICAgICBzdGF0ZS5zaGFkb3codmFsdWUsIHNjaGVtYS5fZmxhZ3MucmVzdWx0KTtcbiAgICB9XG5cbiAgICAvLyBDYWNoZVxuXG4gICAgaWYgKHNjaGVtYS5fY2FjaGUgJiZcbiAgICAgICAgcHJlZnMuY2FjaGUgIT09IGZhbHNlICYmXG4gICAgICAgICFzY2hlbWEuX3JlZnMubGVuZ3RoKSB7XG5cbiAgICAgICAgc2NoZW1hLl9jYWNoZS5zZXQoaGVscGVycy5vcmlnaW5hbCwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvLyBBcnRpZmFjdHNcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICFyZXN1bHQuZXJyb3JzICYmXG4gICAgICAgIHNjaGVtYS5fZmxhZ3MuYXJ0aWZhY3QgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmFydGlmYWN0cyA9IHN0YXRlLm1haW5zdGF5LmFydGlmYWN0cyB8fCBuZXcgTWFwKCk7XG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkuYXJ0aWZhY3RzLmhhcyhzY2hlbWEuX2ZsYWdzLmFydGlmYWN0KSkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkuYXJ0aWZhY3RzLnNldChzY2hlbWEuX2ZsYWdzLmFydGlmYWN0LCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5tYWluc3RheS5hcnRpZmFjdHMuZ2V0KHNjaGVtYS5fZmxhZ3MuYXJ0aWZhY3QpLnB1c2goc3RhdGUucGF0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuaW50ZXJuYWxzLnByZWZzID0gZnVuY3Rpb24gKHNjaGVtYSwgcHJlZnMpIHtcblxuICAgIGNvbnN0IGlzRGVmYXVsdE9wdGlvbnMgPSBwcmVmcyA9PT0gQ29tbW9uLmRlZmF1bHRzO1xuICAgIGlmIChpc0RlZmF1bHRPcHRpb25zICYmXG4gICAgICAgIHNjaGVtYS5fcHJlZmVyZW5jZXNbQ29tbW9uLnN5bWJvbHMucHJlZnNdKSB7XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYS5fcHJlZmVyZW5jZXNbQ29tbW9uLnN5bWJvbHMucHJlZnNdO1xuICAgIH1cblxuICAgIHByZWZzID0gQ29tbW9uLnByZWZlcmVuY2VzKHByZWZzLCBzY2hlbWEuX3ByZWZlcmVuY2VzKTtcbiAgICBpZiAoaXNEZWZhdWx0T3B0aW9ucykge1xuICAgICAgICBzY2hlbWEuX3ByZWZlcmVuY2VzW0NvbW1vbi5zeW1ib2xzLnByZWZzXSA9IHByZWZzO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmcztcbn07XG5cblxuaW50ZXJuYWxzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZmxhZywgdmFsdWUsIGVycm9ycywgaGVscGVycykge1xuXG4gICAgY29uc3QgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9ID0gaGVscGVycztcbiAgICBjb25zdCBzb3VyY2UgPSBzY2hlbWEuX2ZsYWdzW2ZsYWddO1xuICAgIGlmIChwcmVmcy5ub0RlZmF1bHRzIHx8XG4gICAgICAgIHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5sb2coc2NoZW1hLCBzdGF0ZSwgJ3J1bGUnLCBmbGFnLCAnZnVsbCcpO1xuXG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBhcmdzID0gc291cmNlLmxlbmd0aCA/IFtDbG9uZShzdGF0ZS5hbmNlc3RvcnNbMF0pLCBoZWxwZXJzXSA6IFtdO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKGBhbnkuJHtmbGFnfWAsIG51bGwsIHsgZXJyb3I6IGVyciB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2VbQ29tbW9uLnN5bWJvbHMubGl0ZXJhbF0pIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saXRlcmFsO1xuICAgIH1cblxuICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiBDbG9uZShzb3VyY2UpO1xufTtcblxuXG5pbnRlcm5hbHMudHJpbSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hKSB7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3QgdHJpbSA9IHNjaGVtYS4kX2dldFJ1bGUoJ3RyaW0nKTtcbiAgICBpZiAoIXRyaW0gfHxcbiAgICAgICAgIXRyaW0uYXJncy5lbmFibGVkKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS50cmltKCk7XG59O1xuXG5cbmludGVybmFscy5pZ25vcmUgPSB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBkZWJ1ZzogSWdub3JlLFxuICAgIGVudHJ5OiBJZ25vcmUsXG4gICAgZmlsdGVyOiBJZ25vcmUsXG4gICAgbG9nOiBJZ25vcmUsXG4gICAgcmVzb2x2ZTogSWdub3JlLFxuICAgIHZhbHVlOiBJZ25vcmVcbn07XG5cblxuaW50ZXJuYWxzLmVycm9yc0FycmF5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgZXJyb3JzW0NvbW1vbi5zeW1ib2xzLmVycm9yc10gPSB0cnVlO1xuICAgIHJldHVybiBlcnJvcnM7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/validator.js\n");

/***/ }),

/***/ "./node_modules/joi/lib/values.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/values.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"@hapi/hoek/lib/assert\");\nconst DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ \"@hapi/hoek/lib/deepEqual\");\n\nconst Common = __webpack_require__(/*! ./common */ \"./node_modules/joi/lib/common.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = internals.Values = class {\n\n    constructor(values, refs) {\n\n        this._values = new Set(values);\n        this._refs = new Set(refs);\n        this._lowercase = internals.lowercases(values);\n\n        this._override = false;\n    }\n\n    get length() {\n\n        return this._values.size + this._refs.size;\n    }\n\n    add(value, refs) {\n\n        // Reference\n\n        if (Common.isResolvable(value)) {\n            if (!this._refs.has(value)) {\n                this._refs.add(value);\n\n                if (refs) {                     // Skipped in a merge\n                    refs.register(value);\n                }\n            }\n\n            return;\n        }\n\n        // Value\n\n        if (!this.has(value, null, null, false)) {\n            this._values.add(value);\n\n            if (typeof value === 'string') {\n                this._lowercase.set(value.toLowerCase(), value);\n            }\n        }\n    }\n\n    static merge(target, source, remove) {\n\n        target = target || new internals.Values();\n\n        if (source) {\n            if (source._override) {\n                return source.clone();\n            }\n\n            for (const item of [...source._values, ...source._refs]) {\n                target.add(item);\n            }\n        }\n\n        if (remove) {\n            for (const item of [...remove._values, ...remove._refs]) {\n                target.remove(item);\n            }\n        }\n\n        return target.length ? target : null;\n    }\n\n    remove(value) {\n\n        // Reference\n\n        if (Common.isResolvable(value)) {\n            this._refs.delete(value);\n            return;\n        }\n\n        // Value\n\n        this._values.delete(value);\n\n        if (typeof value === 'string') {\n            this._lowercase.delete(value.toLowerCase());\n        }\n    }\n\n    has(value, state, prefs, insensitive) {\n\n        return !!this.get(value, state, prefs, insensitive);\n    }\n\n    get(value, state, prefs, insensitive) {\n\n        if (!this.length) {\n            return false;\n        }\n\n        // Simple match\n\n        if (this._values.has(value)) {\n            return { value };\n        }\n\n        // Case insensitive string match\n\n        if (typeof value === 'string' &&\n            value &&\n            insensitive) {\n\n            const found = this._lowercase.get(value.toLowerCase());\n            if (found) {\n                return { value: found };\n            }\n        }\n\n        if (!this._refs.size &&\n            typeof value !== 'object') {\n\n            return false;\n        }\n\n        // Objects\n\n        if (typeof value === 'object') {\n            for (const item of this._values) {\n                if (DeepEqual(item, value)) {\n                    return { value: item };\n                }\n            }\n        }\n\n        // References\n\n        if (state) {\n            for (const ref of this._refs) {\n                const resolved = ref.resolve(value, state, prefs, null, { in: true });\n                if (resolved === undefined) {\n                    continue;\n                }\n\n                const items = !ref.in || typeof resolved !== 'object'\n                    ? [resolved]\n                    : Array.isArray(resolved) ? resolved : Object.keys(resolved);\n\n                for (const item of items) {\n                    if (typeof item !== typeof value) {\n                        continue;\n                    }\n\n                    if (insensitive &&\n                        value &&\n                        typeof value === 'string') {\n\n                        if (item.toLowerCase() === value.toLowerCase()) {\n                            return { value: item, ref };\n                        }\n                    }\n                    else {\n                        if (DeepEqual(item, value)) {\n                            return { value: item, ref };\n                        }\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    override() {\n\n        this._override = true;\n    }\n\n    values(options) {\n\n        if (options &&\n            options.display) {\n\n            const values = [];\n\n            for (const item of [...this._values, ...this._refs]) {\n                if (item !== undefined) {\n                    values.push(item);\n                }\n            }\n\n            return values;\n        }\n\n        return Array.from([...this._values, ...this._refs]);\n    }\n\n    clone() {\n\n        const set = new internals.Values(this._values, this._refs);\n        set._override = this._override;\n        return set;\n    }\n\n    concat(source) {\n\n        Assert(!source._override, 'Cannot concat override set of values');\n\n        const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);\n        set._override = this._override;\n        return set;\n    }\n\n    describe() {\n\n        const normalized = [];\n\n        if (this._override) {\n            normalized.push({ override: true });\n        }\n\n        for (const value of this._values.values()) {\n            normalized.push(value && typeof value === 'object' ? { value } : value);\n        }\n\n        for (const value of this._refs.values()) {\n            normalized.push(value.describe());\n        }\n\n        return normalized;\n    }\n};\n\n\ninternals.Values.prototype[Common.symbols.values] = true;\n\n\n// Aliases\n\ninternals.Values.prototype.slice = internals.Values.prototype.clone;\n\n\n// Helpers\n\ninternals.lowercases = function (from) {\n\n    const map = new Map();\n\n    if (from) {\n        for (const value of from) {\n            if (typeof value === 'string') {\n                map.set(value.toLowerCase(), value);\n            }\n        }\n    }\n\n    return map;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam9pL2xpYi92YWx1ZXMuanM/MmI2OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0RBQXVCO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLDBEQUEwQjs7QUFFcEQsZUFBZSxtQkFBTyxDQUFDLGtEQUFVOzs7QUFHakM7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlFQUF5RSxXQUFXO0FBQ3BGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDOztBQUVBO0FBQ0Esa0VBQWtFLFFBQVE7QUFDMUU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdmFsdWVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlZhbHVlcyA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHZhbHVlcywgcmVmcykge1xuXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IG5ldyBTZXQodmFsdWVzKTtcbiAgICAgICAgdGhpcy5fcmVmcyA9IG5ldyBTZXQocmVmcyk7XG4gICAgICAgIHRoaXMuX2xvd2VyY2FzZSA9IGludGVybmFscy5sb3dlcmNhc2VzKHZhbHVlcyk7XG5cbiAgICAgICAgdGhpcy5fb3ZlcnJpZGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXMuc2l6ZSArIHRoaXMuX3JlZnMuc2l6ZTtcbiAgICB9XG5cbiAgICBhZGQodmFsdWUsIHJlZnMpIHtcblxuICAgICAgICAvLyBSZWZlcmVuY2VcblxuICAgICAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVmcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmcy5hZGQodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlZnMpIHsgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwcGVkIGluIGEgbWVyZ2VcbiAgICAgICAgICAgICAgICAgICAgcmVmcy5yZWdpc3Rlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWx1ZVxuXG4gICAgICAgIGlmICghdGhpcy5oYXModmFsdWUsIG51bGwsIG51bGwsIGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmFkZCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG93ZXJjYXNlLnNldCh2YWx1ZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHJlbW92ZSkge1xuXG4gICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgaW50ZXJuYWxzLlZhbHVlcygpO1xuXG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuX292ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgWy4uLnNvdXJjZS5fdmFsdWVzLCAuLi5zb3VyY2UuX3JlZnNdKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBbLi4ucmVtb3ZlLl92YWx1ZXMsIC4uLnJlbW92ZS5fcmVmc10pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC5sZW5ndGggPyB0YXJnZXQgOiBudWxsO1xuICAgIH1cblxuICAgIHJlbW92ZSh2YWx1ZSkge1xuXG4gICAgICAgIC8vIFJlZmVyZW5jZVxuXG4gICAgICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVmcy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsdWVcblxuICAgICAgICB0aGlzLl92YWx1ZXMuZGVsZXRlKHZhbHVlKTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fbG93ZXJjYXNlLmRlbGV0ZSh2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhcyh2YWx1ZSwgc3RhdGUsIHByZWZzLCBpbnNlbnNpdGl2ZSkge1xuXG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0KHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGluc2Vuc2l0aXZlKTtcbiAgICB9XG5cbiAgICBnZXQodmFsdWUsIHN0YXRlLCBwcmVmcywgaW5zZW5zaXRpdmUpIHtcblxuICAgICAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW1wbGUgbWF0Y2hcblxuICAgICAgICBpZiAodGhpcy5fdmFsdWVzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXNlIGluc2Vuc2l0aXZlIHN0cmluZyBtYXRjaFxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgaW5zZW5zaXRpdmUpIHtcblxuICAgICAgICAgICAgY29uc3QgZm91bmQgPSB0aGlzLl9sb3dlcmNhc2UuZ2V0KHZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGZvdW5kIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3JlZnMuc2l6ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPYmplY3RzXG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoRGVlcEVxdWFsKGl0ZW0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlZmVyZW5jZXNcblxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRoaXMuX3JlZnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlZi5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgaW46IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSAhcmVmLmluIHx8IHR5cGVvZiByZXNvbHZlZCAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgPyBbcmVzb2x2ZWRdXG4gICAgICAgICAgICAgICAgICAgIDogQXJyYXkuaXNBcnJheShyZXNvbHZlZCkgPyByZXNvbHZlZCA6IE9iamVjdC5rZXlzKHJlc29sdmVkKTtcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZW5zaXRpdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbSwgcmVmIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRGVlcEVxdWFsKGl0ZW0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtLCByZWYgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBvdmVycmlkZSgpIHtcblxuICAgICAgICB0aGlzLl9vdmVycmlkZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFsdWVzKG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAob3B0aW9ucyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5kaXNwbGF5KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgWy4uLnRoaXMuX3ZhbHVlcywgLi4udGhpcy5fcmVmc10pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKFsuLi50aGlzLl92YWx1ZXMsIC4uLnRoaXMuX3JlZnNdKTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICBjb25zdCBzZXQgPSBuZXcgaW50ZXJuYWxzLlZhbHVlcyh0aGlzLl92YWx1ZXMsIHRoaXMuX3JlZnMpO1xuICAgICAgICBzZXQuX292ZXJyaWRlID0gdGhpcy5fb3ZlcnJpZGU7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuXG4gICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgIEFzc2VydCghc291cmNlLl9vdmVycmlkZSwgJ0Nhbm5vdCBjb25jYXQgb3ZlcnJpZGUgc2V0IG9mIHZhbHVlcycpO1xuXG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyBpbnRlcm5hbHMuVmFsdWVzKFsuLi50aGlzLl92YWx1ZXMsIC4uLnNvdXJjZS5fdmFsdWVzXSwgWy4uLnRoaXMuX3JlZnMsIC4uLnNvdXJjZS5fcmVmc10pO1xuICAgICAgICBzZXQuX292ZXJyaWRlID0gdGhpcy5fb3ZlcnJpZGU7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLl9vdmVycmlkZSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKHsgb3ZlcnJpZGU6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuX3ZhbHVlcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB7IHZhbHVlIH0gOiB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuX3JlZnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaCh2YWx1ZS5kZXNjcmliZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlZhbHVlcy5wcm90b3R5cGVbQ29tbW9uLnN5bWJvbHMudmFsdWVzXSA9IHRydWU7XG5cblxuLy8gQWxpYXNlc1xuXG5pbnRlcm5hbHMuVmFsdWVzLnByb3RvdHlwZS5zbGljZSA9IGludGVybmFscy5WYWx1ZXMucHJvdG90eXBlLmNsb25lO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmxvd2VyY2FzZXMgPSBmdW5jdGlvbiAoZnJvbSkge1xuXG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuXG4gICAgaWYgKGZyb20pIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBmcm9tKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG1hcC5zZXQodmFsdWUudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/joi/lib/values.js\n");

/***/ }),

/***/ "./node_modules/joi/package.json":
/*!***************************************!*\
  !*** ./node_modules/joi/package.json ***!
  \***************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, browser, bugs, bundleDependencies, dependencies, deprecated, description, devDependencies, files, homepage, keywords, license, main, name, repository, scripts, types, version, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"_from\\\":\\\"joi@^17.4.0\\\",\\\"_id\\\":\\\"joi@17.4.0\\\",\\\"_inBundle\\\":false,\\\"_integrity\\\":\\\"sha512-F4WiW2xaV6wc1jxete70Rw4V/VuMd6IN+a5ilZsxG4uYtUXWu2kq9W5P2dz30e7Gmw8RCbY/u/uk+dMPma9tAg==\\\",\\\"_location\\\":\\\"/joi\\\",\\\"_phantomChildren\\\":{},\\\"_requested\\\":{\\\"type\\\":\\\"range\\\",\\\"registry\\\":true,\\\"raw\\\":\\\"joi@^17.4.0\\\",\\\"name\\\":\\\"joi\\\",\\\"escapedName\\\":\\\"joi\\\",\\\"rawSpec\\\":\\\"^17.4.0\\\",\\\"saveSpec\\\":null,\\\"fetchSpec\\\":\\\"^17.4.0\\\"},\\\"_requiredBy\\\":[\\\"#USER\\\",\\\"/\\\"],\\\"_resolved\\\":\\\"https://registry.npmjs.org/joi/-/joi-17.4.0.tgz\\\",\\\"_shasum\\\":\\\"b5c2277c8519e016316e49ababd41a1908d9ef20\\\",\\\"_spec\\\":\\\"joi@^17.4.0\\\",\\\"_where\\\":\\\"/Users/year12/Desktop/Harvey/alevel_2020-2021\\\",\\\"browser\\\":\\\"dist/joi-browser.min.js\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/sideway/joi/issues\\\"},\\\"bundleDependencies\\\":false,\\\"dependencies\\\":{\\\"@hapi/hoek\\\":\\\"^9.0.0\\\",\\\"@hapi/topo\\\":\\\"^5.0.0\\\",\\\"@sideway/address\\\":\\\"^4.1.0\\\",\\\"@sideway/formula\\\":\\\"^3.0.0\\\",\\\"@sideway/pinpoint\\\":\\\"^2.0.0\\\"},\\\"deprecated\\\":false,\\\"description\\\":\\\"Object schema validation\\\",\\\"devDependencies\\\":{\\\"@hapi/bourne\\\":\\\"2.x.x\\\",\\\"@hapi/code\\\":\\\"8.x.x\\\",\\\"@hapi/joi-legacy-test\\\":\\\"npm:@hapi/joi@15.x.x\\\",\\\"@hapi/lab\\\":\\\"24.x.x\\\",\\\"typescript\\\":\\\"4.0.x\\\"},\\\"files\\\":[\\\"lib/**/*\\\",\\\"dist/*\\\"],\\\"homepage\\\":\\\"https://github.com/sideway/joi#readme\\\",\\\"keywords\\\":[\\\"schema\\\",\\\"validation\\\"],\\\"license\\\":\\\"BSD-3-Clause\\\",\\\"main\\\":\\\"lib/index.js\\\",\\\"name\\\":\\\"joi\\\",\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git://github.com/sideway/joi.git\\\"},\\\"scripts\\\":{\\\"prepublishOnly\\\":\\\"cd browser && npm install && npm run build\\\",\\\"test\\\":\\\"lab -t 100 -a @hapi/code -L -Y\\\",\\\"test-cov-html\\\":\\\"lab -r html -o coverage.html -a @hapi/code\\\"},\\\"types\\\":\\\"lib/index.d.ts\\\",\\\"version\\\":\\\"17.4.0\\\"}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9qb2kvcGFja2FnZS5qc29uLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/joi/package.json\n");

/***/ }),

/***/ "./pages/test.js":
/*!***********************!*\
  !*** ./pages/test.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return render; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var camera_controls__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! camera-controls */ \"camera-controls\");\n/* harmony import */ var camera_controls__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(camera_controls__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _components_Context_socketioContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Context/socketioContext */ \"./components/Context/socketioContext.js\");\n/* harmony import */ var _components_gameFundalmentals_nametag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/gameFundalmentals/nametag */ \"./components/gameFundalmentals/nametag.js\");\n/* harmony import */ var _components_Core_API_ConnectAPI__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/Core-API/ConnectAPI */ \"./components/Core-API/ConnectAPI.js\");\n/* harmony import */ var _components_Core_API_RenderingHandler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/Core-API/RenderingHandler */ \"./components/Core-API/RenderingHandler.js\");\n/* harmony import */ var _components_gameFundalmentals_MainSceneHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../components/gameFundalmentals/MainSceneHandler */ \"./components/gameFundalmentals/MainSceneHandler.js\");\n/* harmony import */ var _components_gameUI_gameFeed__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../components/gameUI/gameFeed */ \"./components/gameUI/gameFeed.js\");\n\nvar _jsxFileName = \"/Users/year12/Desktop/Harvey/alevel_2020-2021/pages/test.js\";\n// Written By Harvey Randall \\\\\n\n\n\n\n\nvar Stats = __webpack_require__(/*! stats.js */ \"stats.js\");\n\n\n\n\n\n\n\ncamera_controls__WEBPACK_IMPORTED_MODULE_3___default.a.install({\n  THREE: three__WEBPACK_IMPORTED_MODULE_2__\n});\nfunction render() {\n  var _ref;\n\n  const {\n    0: child,\n    1: setChild\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(undefined);\n  const {\n    0: gameEventData,\n    1: setGameEventData\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])([]);\n  const {\n    0: newTheta,\n    1: setTheat\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(0);\n  const {\n    0: day,\n    1: setDay\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(\"not day\");\n  const {\n    0: child2,\n    1: setChild2\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(undefined);\n  const {\n    0: pos,\n    1: setPos\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(undefined);\n  const {\n    0: rot,\n    1: setRot\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(undefined);\n  const socket = Object(_components_Context_socketioContext__WEBPACK_IMPORTED_MODULE_4__[\"useAppContext\"])();\n  const {\n    0: recievedSeed,\n    1: setSeed\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(undefined);\n  const {\n    0: rendered,\n    1: setRendered\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(false);\n  const {\n    0: clients,\n    1: setClients\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])([]);\n  const {\n    0: personData,\n    1: setPersonalData\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(undefined);\n  const {\n    0: latestPerson,\n    1: setLatestestPerson\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])([]);\n  Object(_components_Core_API_ConnectAPI__WEBPACK_IMPORTED_MODULE_6__[\"StartSeverClientCommunication\"])(socket);\n  socket.once(\"welcome\", (seed, client, data) => {\n    setSeed(seed);\n    console.log(client);\n    setClients(client);\n    setPersonalData(data);\n  });\n  Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(() => {\n    if (child === undefined || recievedSeed === undefined || rendered === true) return;\n    setRendered(true);\n    let stats = new Stats();\n    stats.showPanel(1);\n    document.body.appendChild(stats.dom);\n    let SceneToGet = new three__WEBPACK_IMPORTED_MODULE_2__[\"Scene\"]();\n    let Renders = new three__WEBPACK_IMPORTED_MODULE_2__[\"WebGLRenderer\"]({\n      antialias: true,\n      alpha: true\n    });\n    Renders.setClearColor(0x87ceeb, 1);\n    Renders.setSize(window.innerWidth, window.innerHeight);\n    child.appendChild(Renders.domElement);\n    let CurrentScene = \"Main\";\n    var Camera = new three__WEBPACK_IMPORTED_MODULE_2__[\"PerspectiveCamera\"](75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    Object(_components_gameFundalmentals_MainSceneHandler__WEBPACK_IMPORTED_MODULE_8__[\"GenerateMainScene\"])(SceneToGet, Renders, document, recievedSeed, child2, Camera);\n    Renders.domElement.requestPointerLock();\n    let players = [];\n\n    function MakeCube(color = \"rgb(0,0,0)\", name = \"unkown\") {\n      const group = new three__WEBPACK_IMPORTED_MODULE_2__[\"Group\"]();\n      const geometry = new three__WEBPACK_IMPORTED_MODULE_2__[\"BoxGeometry\"](1, 1, 1);\n      const material = new three__WEBPACK_IMPORTED_MODULE_2__[\"MeshLambertMaterial\"]({\n        color: new three__WEBPACK_IMPORTED_MODULE_2__[\"Color\"](color),\n        emissive: new three__WEBPACK_IMPORTED_MODULE_2__[\"Color\"](color)\n      });\n      const cube = new three__WEBPACK_IMPORTED_MODULE_2__[\"Mesh\"](geometry, material);\n      group.add(cube);\n      const cyclinder = new three__WEBPACK_IMPORTED_MODULE_2__[\"CylinderGeometry\"](0.3, 0.3, 0.6, 30);\n      const material2 = new three__WEBPACK_IMPORTED_MODULE_2__[\"MeshLambertMaterial\"]({\n        color: 0x000000\n      });\n      const cylinderBuild = new three__WEBPACK_IMPORTED_MODULE_2__[\"Mesh\"](cyclinder, material2);\n      cylinderBuild.rotateX(Math.PI / 2 + Math.PI);\n      cylinderBuild.position.set(0, 0, -0.6);\n      group.add(cylinderBuild);\n      Object(_components_gameFundalmentals_nametag__WEBPACK_IMPORTED_MODULE_5__[\"GenerateLabel\"])(name, group);\n      SceneToGet.add(group);\n      group.name = name;\n      return group;\n    }\n\n    let prevData = [];\n\n    let addtoGameFeed = (name = \"Unkown\", event) => {\n      let NewGameEventArray = [...prevData];\n      console.log(NewGameEventArray);\n      NewGameEventArray.unshift({\n        name: name,\n        event: event\n      });\n      delete NewGameEventArray[10];\n      delete NewGameEventArray[11];\n      setGameEventData([...NewGameEventArray]);\n      console.log(\"array below\");\n      console.log(prevData);\n      prevData = NewGameEventArray;\n    };\n\n    clients.forEach(e => {\n      console.log(\"Adding PLayer \" + e);\n      let cube = MakeCube(e.color, e.name);\n      players[e] = cube;\n    });\n    socket.on('NewPlayer', (id, data) => {\n      console.log(data);\n      console.log(\"New PLyer \" + id);\n      let cube = MakeCube(data.color, data.name);\n      addtoGameFeed(data === null || data === void 0 ? void 0 : data.name, \"Joined the game!\");\n      players[id] = cube;\n    });\n    socket.on('LostPLayer', (id, how, data) => {\n      console.log(\"lost PLyer \" + id);\n      let cube = players[id];\n      SceneToGet.remove(cube);\n      delete players[id];\n      console.log(data);\n      addtoGameFeed(data === null || data === void 0 ? void 0 : data.name, how === true ? \"Was removed from the game for being inactive\" : \"Left the game!\");\n    });\n    Object(_components_Core_API_ConnectAPI__WEBPACK_IMPORTED_MODULE_6__[\"ListenToEvent\"])('PlayerLocationUpdate', (id, pos, rot, data) => {\n      let cube = players[id];\n\n      if (cube) {\n        cube.rotation.set(rot._x, rot._y, rot._z);\n        cube.position.set(pos.x, pos.y, pos.z);\n      } else {\n        let cube = MakeCube(data === null || data === void 0 ? void 0 : data.color, data === null || data === void 0 ? void 0 : data.name);\n        players[id] = cube;\n      }\n    });\n    socket.on(\"NewChat\", (data, text) => {\n      addtoGameFeed(data.name, text);\n    });\n    setInterval(() => {\n      socket.emit('LocationUpdate', Camera.position, Camera.rotation);\n    }, 10);\n\n    var animate = function () {\n      stats.begin();\n      requestAnimationFrame(animate); // Update all moving parts\n\n      Object(_components_Core_API_RenderingHandler__WEBPACK_IMPORTED_MODULE_7__[\"UpdateRenderCycle\"])(CurrentScene);\n      Renders.render(SceneToGet, Camera);\n      stats.end();\n    };\n\n    animate();\n  }, [child, clients]);\n\n  let sendChat = e => {\n    e.preventDefault();\n    socket.emit(\"sendChat\", child2.value);\n    child2.value = \"\";\n  };\n\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"main\", {\n    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"h1\", {\n      style: {\n        position: \"fixed\",\n        marginTop: \"40px\",\n        color: \"white\"\n      },\n      children: personData === undefined ? \"LOADING...\" : personData.name\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 185,\n      columnNumber: 13\n    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"div\", {\n      style: {\n        width: \"100vw\",\n        height: \"100vh\",\n        position: \"fixed\",\n        marginTop: \"80px\"\n      },\n      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_components_gameUI_gameFeed__WEBPACK_IMPORTED_MODULE_9__[\"CreateUI\"], {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 187,\n        columnNumber: 17\n      }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"form\", {\n        onSubmit: sendChat,\n        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"input\", {\n          ref: ref => setChild2(ref)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 189,\n          columnNumber: 21\n        }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"input\", {\n          type: \"Submit\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 190,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 188,\n        columnNumber: 17\n      }, this), [...gameEventData].map(e => {\n        if (e == undefined) return;\n        return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"h4\", {\n          style: {\n            color: \"white\"\n          },\n          children: [e.name, \" - \", e.event]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 195,\n          columnNumber: 25\n        }, this);\n      })]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 186,\n      columnNumber: 13\n    }, this), (_ref = recievedSeed === undefined) !== null && _ref !== void 0 ? _ref : /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"h1\", {\n      children: \"LOADING SEED!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 200,\n      columnNumber: 45\n    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"div\", {\n      ref: ref => setChild(ref)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 201,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 184,\n    columnNumber: 9\n  }, this);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWdlcy90ZXN0LmpzPzE0MmIiXSwibmFtZXMiOlsiU3RhdHMiLCJyZXF1aXJlIiwiQ2FtZXJhQ29udHJvbHMiLCJpbnN0YWxsIiwiVEhSRUUiLCJyZW5kZXIiLCJjaGlsZCIsInNldENoaWxkIiwidXNlU3RhdGUiLCJ1bmRlZmluZWQiLCJnYW1lRXZlbnREYXRhIiwic2V0R2FtZUV2ZW50RGF0YSIsIm5ld1RoZXRhIiwic2V0VGhlYXQiLCJkYXkiLCJzZXREYXkiLCJjaGlsZDIiLCJzZXRDaGlsZDIiLCJwb3MiLCJzZXRQb3MiLCJyb3QiLCJzZXRSb3QiLCJzb2NrZXQiLCJ1c2VBcHBDb250ZXh0IiwicmVjaWV2ZWRTZWVkIiwic2V0U2VlZCIsInJlbmRlcmVkIiwic2V0UmVuZGVyZWQiLCJjbGllbnRzIiwic2V0Q2xpZW50cyIsInBlcnNvbkRhdGEiLCJzZXRQZXJzb25hbERhdGEiLCJsYXRlc3RQZXJzb24iLCJzZXRMYXRlc3Rlc3RQZXJzb24iLCJTdGFydFNldmVyQ2xpZW50Q29tbXVuaWNhdGlvbiIsIm9uY2UiLCJzZWVkIiwiY2xpZW50IiwiZGF0YSIsImNvbnNvbGUiLCJsb2ciLCJ1c2VFZmZlY3QiLCJzdGF0cyIsInNob3dQYW5lbCIsImRvY3VtZW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwiZG9tIiwiU2NlbmVUb0dldCIsIlNjZW5lIiwiUmVuZGVycyIsIldlYkdMUmVuZGVyZXIiLCJhbnRpYWxpYXMiLCJhbHBoYSIsInNldENsZWFyQ29sb3IiLCJzZXRTaXplIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiZG9tRWxlbWVudCIsIkN1cnJlbnRTY2VuZSIsIkNhbWVyYSIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwiR2VuZXJhdGVNYWluU2NlbmUiLCJyZXF1ZXN0UG9pbnRlckxvY2siLCJwbGF5ZXJzIiwiTWFrZUN1YmUiLCJjb2xvciIsIm5hbWUiLCJncm91cCIsImdlb21ldHJ5IiwibWF0ZXJpYWwiLCJlbWlzc2l2ZSIsImN1YmUiLCJhZGQiLCJjeWNsaW5kZXIiLCJtYXRlcmlhbDIiLCJjeWxpbmRlckJ1aWxkIiwicm90YXRlWCIsIk1hdGgiLCJQSSIsInBvc2l0aW9uIiwic2V0IiwiR2VuZXJhdGVMYWJlbCIsInByZXZEYXRhIiwiYWRkdG9HYW1lRmVlZCIsImV2ZW50IiwiTmV3R2FtZUV2ZW50QXJyYXkiLCJ1bnNoaWZ0IiwiZm9yRWFjaCIsImUiLCJvbiIsImlkIiwiaG93IiwicmVtb3ZlIiwiTGlzdGVuVG9FdmVudCIsInJvdGF0aW9uIiwiX3giLCJfeSIsIl96IiwieCIsInkiLCJ6IiwidGV4dCIsInNldEludGVydmFsIiwiZW1pdCIsImFuaW1hdGUiLCJiZWdpbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIlVwZGF0ZVJlbmRlckN5Y2xlIiwiZW5kIiwic2VuZENoYXQiLCJwcmV2ZW50RGVmYXVsdCIsInZhbHVlIiwibWFyZ2luVG9wIiwid2lkdGgiLCJoZWlnaHQiLCJyZWYiLCJtYXAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsSUFBSUEsS0FBSyxHQUFHQyxtQkFBTyxDQUFDLDBCQUFELENBQW5COztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxzREFBYyxDQUFDQyxPQUFmLENBQXVCO0FBQUVDLE9BQUssRUFBRUEsa0NBQUtBO0FBQWQsQ0FBdkI7QUFHZSxTQUFTQyxNQUFULEdBQWtCO0FBQUE7O0FBQzdCLFFBQU07QUFBQSxPQUFDQyxLQUFEO0FBQUEsT0FBUUM7QUFBUixNQUFvQkMsc0RBQVEsQ0FBQ0MsU0FBRCxDQUFsQztBQUNBLFFBQU07QUFBQSxPQUFDQyxhQUFEO0FBQUEsT0FBZ0JDO0FBQWhCLE1BQW9DSCxzREFBUSxDQUFDLEVBQUQsQ0FBbEQ7QUFFQSxRQUFNO0FBQUEsT0FBQ0ksUUFBRDtBQUFBLE9BQVdDO0FBQVgsTUFBdUJMLHNEQUFRLENBQUMsQ0FBRCxDQUFyQztBQUNBLFFB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QU5MO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUZKLFVBZ0JNOUQsWUFBWSxLQUFLZixTQWhCdkIsb0RBZ0JvQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQWhCcEMsZUFpQkk7QUFBSyxTQUFHLEVBQUU0RyxHQUFHLElBQUs5RyxRQUFRLENBQUM4RyxHQUFEO0FBQTFCO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFqQko7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBREo7QUFxQkgiLCJmaWxlIjoiLi9wYWdlcy90ZXN0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gV3JpdHRlbiBCeSBIYXJ2ZXkgUmFuZGFsbCBcXFxcXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIlxuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IENhbWVyYUNvbnRyb2xzIGZyb20gJ2NhbWVyYS1jb250cm9scyc7XG5pbXBvcnQgeyBEb3VibGVTaWRlLCBQZXJzcGVjdGl2ZUNhbWVyYSwgU2NlbmUsIFdlYkdMUmVuZGVyZXIgfSBmcm9tIFwidGhyZWVcIlxudmFyIFN0YXRzID0gcmVxdWlyZSgnc3RhdHMuanMnKVxuaW1wb3J0IHsgdXNlQXBwQ29udGV4dCB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ29udGV4dC9zb2NrZXRpb0NvbnRleHQnXG5pbXBvcnQgeyBHZW5lcmF0ZUxhYmVsIH0gZnJvbSAnLi4vY29tcG9uZW50cy9nYW1lRnVuZGFsbWVudGFscy9uYW1ldGFnJ1xuaW1wb3J0IHsgU3RhcnRTZXZlckNsaWVudENvbW11bmljYXRpb24sIExpc3RlblRvRXZlbnQgfSBmcm9tIFwiLi4vY29tcG9uZW50cy9Db3JlLUFQSS9Db25uZWN0QVBJXCI7XG5pbXBvcnQgeyBVcGRhdGVSZW5kZXJDeWNsZSB9IGZyb20gXCIuLi9jb21wb25lbnRzL0NvcmUtQVBJL1JlbmRlcmluZ0hhbmRsZXJcIjtcbmltcG9ydCB7IEdlbmVyYXRlTWFpblNjZW5lIH0gZnJvbSBcIi4uL2NvbXBvbmVudHMvZ2FtZUZ1bmRhbG1lbnRhbHMvTWFpblNjZW5lSGFuZGxlclwiO1xuaW1wb3J0IHsgQ3JlYXRlVUkgfSBmcm9tIFwiLi4vY29tcG9uZW50cy9nYW1lVUkvZ2FtZUZlZWRcIjtcbkNhbWVyYUNvbnRyb2xzLmluc3RhbGwoeyBUSFJFRTogVEhSRUUgfSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIGNvbnN0IFtjaGlsZCwgc2V0Q2hpbGRdID0gdXNlU3RhdGUodW5kZWZpbmVkKVxuICAgIGNvbnN0IFtnYW1lRXZlbnREYXRhLCBzZXRHYW1lRXZlbnREYXRhXSA9IHVzZVN0YXRlKFtdKVxuXG4gICAgY29uc3QgW25ld1RoZXRhLCBzZXRUaGVhdF0gPSB1c2VTdGF0ZSgwKVxuICAgIGNvbnN0IFtkYXksIHNldERheV0gPSB1c2VTdGF0ZShcIm5vdCBkYXlcIilcbiAgICBjb25zdCBbY2hpbGQyLCBzZXRDaGlsZDJdID0gdXNlU3RhdGUodW5kZWZpbmVkKVxuICAgIGNvbnN0IFtwb3MsIHNldFBvc10gPSB1c2VTdGF0ZSh1bmRlZmluZWQpXG4gICAgY29uc3QgW3JvdCwgc2V0Um90XSA9IHVzZVN0YXRlKHVuZGVmaW5lZClcbiAgICBjb25zdCBzb2NrZXQgPSB1c2VBcHBDb250ZXh0KClcbiAgICBjb25zdCBbcmVjaWV2ZWRTZWVkLCBzZXRTZWVkXSA9IHVzZVN0YXRlKHVuZGVmaW5lZClcbiAgICBjb25zdCBbcmVuZGVyZWQsIHNldFJlbmRlcmVkXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtjbGllbnRzLCBzZXRDbGllbnRzXSA9IHVzZVN0YXRlKFtdKVxuICAgIGNvbnN0IFtwZXJzb25EYXRhLCBzZXRQZXJzb25hbERhdGFdID0gdXNlU3RhdGUodW5kZWZpbmVkKVxuICAgIGNvbnN0IFtsYXRlc3RQZXJzb24sIHNldExhdGVzdGVzdFBlcnNvbl0gPSB1c2VTdGF0ZShbXSlcblxuICAgIFN0YXJ0U2V2ZXJDbGllbnRDb21tdW5pY2F0aW9uKHNvY2tldClcblxuXG4gICAgc29ja2V0Lm9uY2UoXCJ3ZWxjb21lXCIsIChzZWVkLCBjbGllbnQsIGRhdGEpID0+IHtcbiAgICAgICAgc2V0U2VlZChzZWVkKVxuICAgICAgICBjb25zb2xlLmxvZyhjbGllbnQpXG4gICAgICAgIHNldENsaWVudHMoY2xpZW50KVxuICAgICAgICBzZXRQZXJzb25hbERhdGEoZGF0YSlcbiAgICB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gdW5kZWZpbmVkIHx8IHJlY2lldmVkU2VlZCA9PT0gdW5kZWZpbmVkIHx8IHJlbmRlcmVkID09PSB0cnVlKSByZXR1cm47XG4gICAgICAgIHNldFJlbmRlcmVkKHRydWUpXG5cbiAgICAgICAgbGV0IHN0YXRzID0gbmV3IFN0YXRzKCk7XG4gICAgICAgIHN0YXRzLnNob3dQYW5lbCgxKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0cy5kb20pO1xuXG4gICAgICAgIGxldCBTY2VuZVRvR2V0ID0gbmV3IFNjZW5lKClcbiAgICAgICAgbGV0IFJlbmRlcnMgPSBuZXcgV2ViR0xSZW5kZXJlcih7XG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICAgICAgICBhbHBoYTogdHJ1ZVxuICAgICAgICB9KVxuXG4gICAgICAgIFJlbmRlcnMuc2V0Q2xlYXJDb2xvcigweDg3Y2VlYiwgMSk7XG5cblxuICAgICAgICBSZW5kZXJzLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICAgICAgY2hpbGQuYXBwZW5kQ2hpbGQoUmVuZGVycy5kb21FbGVtZW50KTtcblxuXG4gICAgICAgIGxldCBDdXJyZW50U2NlbmUgPSBcIk1haW5cIlxuXG5cblxuXG5cblxuICAgICAgICB2YXIgQ2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKDc1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMC4xLCAxMDAwKVxuICAgICAgICBHZW5lcmF0ZU1haW5TY2VuZShTY2VuZVRvR2V0LCBSZW5kZXJzLCBkb2N1bWVudCwgcmVjaWV2ZWRTZWVkLCBjaGlsZDIsIENhbWVyYSlcblxuXG4gICAgICAgIFJlbmRlcnMuZG9tRWxlbWVudC5yZXF1ZXN0UG9pbnRlckxvY2soKVxuXG4gICAgICAgIGxldCBwbGF5ZXJzID0gW11cblxuICAgICAgICBmdW5jdGlvbiBNYWtlQ3ViZShjb2xvciA9IFwicmdiKDAsMCwwKVwiLCBuYW1lID0gXCJ1bmtvd25cIikge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBuZXcgVEhSRUUuR3JvdXAoKTtcbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDEsIDEsIDEpO1xuICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7IGNvbG9yOiBuZXcgVEhSRUUuQ29sb3IoY29sb3IpLCBlbWlzc2l2ZTogbmV3IFRIUkVFLkNvbG9yKGNvbG9yKSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGN1YmUgPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICAgICAgZ3JvdXAuYWRkKGN1YmUpXG4gICAgICAgICAgICBjb25zdCBjeWNsaW5kZXIgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSgwLjMsIDAuMywgMC42LCAzMCk7XG4gICAgICAgICAgICBjb25zdCBtYXRlcmlhbDIgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7IGNvbG9yOiAweDAwMDAwMCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGN5bGluZGVyQnVpbGQgPSBuZXcgVEhSRUUuTWVzaChjeWNsaW5kZXIsIG1hdGVyaWFsMik7XG4gICAgICAgICAgICBjeWxpbmRlckJ1aWxkLnJvdGF0ZVgoKE1hdGguUEkgLyAyKSArIE1hdGguUEkpXG4gICAgICAgICAgICBjeWxpbmRlckJ1aWxkLnBvc2l0aW9uLnNldCgwLCAwLCAtMC42KVxuICAgICAgICAgICAgZ3JvdXAuYWRkKGN5bGluZGVyQnVpbGQpXG5cbiAgICAgICAgICAgIEdlbmVyYXRlTGFiZWwobmFtZSwgZ3JvdXApXG4gICAgICAgICAgICBTY2VuZVRvR2V0LmFkZChncm91cClcbiAgICAgICAgICAgIGdyb3VwLm5hbWUgPSBuYW1lXG4gICAgICAgICAgICByZXR1cm4gZ3JvdXBcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwcmV2RGF0YSA9IFtdXG5cbiAgICAgICAgbGV0IGFkZHRvR2FtZUZlZWQgPSAobmFtZSA9IFwiVW5rb3duXCIsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgTmV3R2FtZUV2ZW50QXJyYXkgPSBbLi4ucHJldkRhdGFdXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhOZXdHYW1lRXZlbnRBcnJheSlcbiAgICAgICAgICAgIE5ld0dhbWVFdmVudEFycmF5LnVuc2hpZnQoeyBuYW1lOiBuYW1lLCBldmVudDogZXZlbnQgfSlcbiAgICAgICAgICAgIGRlbGV0ZSBOZXdHYW1lRXZlbnRBcnJheVsxMF1cbiAgICAgICAgICAgIGRlbGV0ZSBOZXdHYW1lRXZlbnRBcnJheVsxMV1cbiAgICAgICAgICAgIHNldEdhbWVFdmVudERhdGEoWy4uLk5ld0dhbWVFdmVudEFycmF5XSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYXJyYXkgYmVsb3dcIilcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHByZXZEYXRhKVxuICAgICAgICAgICAgcHJldkRhdGEgPSBOZXdHYW1lRXZlbnRBcnJheVxuICAgICAgICB9XG5cbiAgICAgICAgY2xpZW50cy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBZGRpbmcgUExheWVyIFwiICsgZSlcbiAgICAgICAgICAgIGxldCBjdWJlID0gTWFrZUN1YmUoZS5jb2xvciwgZS5uYW1lKVxuICAgICAgICAgICAgcGxheWVyc1tlXSA9IGN1YmVcbiAgICAgICAgfSlcblxuXG5cbiAgICAgICAgc29ja2V0Lm9uKCdOZXdQbGF5ZXInLCAoaWQsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5ldyBQTHllciBcIiArIGlkKVxuICAgICAgICAgICAgbGV0IGN1YmUgPSBNYWtlQ3ViZShkYXRhLmNvbG9yLCBkYXRhLm5hbWUpXG4gICAgICAgICAgICBhZGR0b0dhbWVGZWVkKGRhdGE/Lm5hbWUsIFwiSm9pbmVkIHRoZSBnYW1lIVwiKVxuXG4gICAgICAgICAgICBwbGF5ZXJzW2lkXSA9IGN1YmVcbiAgICAgICAgfSlcblxuICAgICAgICBzb2NrZXQub24oJ0xvc3RQTGF5ZXInLCAoaWQsIGhvdywgZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJsb3N0IFBMeWVyIFwiICsgaWQpXG4gICAgICAgICAgICBsZXQgY3ViZSA9IHBsYXllcnNbaWRdXG4gICAgICAgICAgICBTY2VuZVRvR2V0LnJlbW92ZShjdWJlKVxuICAgICAgICAgICAgZGVsZXRlIHBsYXllcnNbaWRdXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICAgICAgYWRkdG9HYW1lRmVlZChkYXRhPy5uYW1lLCBob3cgPT09IHRydWUgPyBcIldhcyByZW1vdmVkIGZyb20gdGhlIGdhbWUgZm9yIGJlaW5nIGluYWN0aXZlXCIgOiBcIkxlZnQgdGhlIGdhbWUhXCIpXG4gICAgICAgIH0pXG5cbiAgICAgICAgTGlzdGVuVG9FdmVudCgnUGxheWVyTG9jYXRpb25VcGRhdGUnLCAoaWQsIHBvcywgcm90LCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBsZXQgY3ViZSA9IHBsYXllcnNbaWRdXG4gICAgICAgICAgICBpZiAoY3ViZSkge1xuICAgICAgICAgICAgICAgIGN1YmUucm90YXRpb24uc2V0KHJvdC5feCwgcm90Ll95LCByb3QuX3opXG4gICAgICAgICAgICAgICAgY3ViZS5wb3NpdGlvbi5zZXQocG9zLngsIHBvcy55LCBwb3MueilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjdWJlID0gTWFrZUN1YmUoZGF0YT8uY29sb3IsIGRhdGE/Lm5hbWUpXG5cbiAgICAgICAgICAgICAgICBwbGF5ZXJzW2lkXSA9IGN1YmVcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pXG4gICAgICAgIHNvY2tldC5vbihcIk5ld0NoYXRcIiwgKGRhdGEsIHRleHQpID0+IHtcbiAgICAgICAgICAgIGFkZHRvR2FtZUZlZWQoZGF0YS5uYW1lLCB0ZXh0KVxuICAgICAgICB9KVxuICAgICAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuZW1pdCgnTG9jYXRpb25VcGRhdGUnLCBDYW1lcmEucG9zaXRpb24sIENhbWVyYS5yb3RhdGlvbilcbiAgICAgICAgfSwgMTApXG5cblxuICAgIFxuXG5cbiAgICAgICAgdmFyIGFuaW1hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdGF0cy5iZWdpbigpXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSlcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCBtb3ZpbmcgcGFydHNcbiAgICAgICAgICAgIFVwZGF0ZVJlbmRlckN5Y2xlKEN1cnJlbnRTY2VuZSlcblxuICAgICAgICAgICAgUmVuZGVycy5yZW5kZXIoU2NlbmVUb0dldCwgQ2FtZXJhKTtcbiAgICAgICAgICAgIHN0YXRzLmVuZCgpXG4gICAgICAgIH07XG5cbiAgICAgICAgYW5pbWF0ZSgpO1xuICAgIH0sIFtjaGlsZCwgY2xpZW50c10pXG5cbiAgICBsZXQgc2VuZENoYXQgPSAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgc29ja2V0LmVtaXQoXCJzZW5kQ2hhdFwiLCBjaGlsZDIudmFsdWUpXG4gICAgICAgIGNoaWxkMi52YWx1ZSA9IFwiXCJcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8bWFpbiA+XG4gICAgICAgICAgICA8aDEgc3R5bGU9e3sgcG9zaXRpb246IFwiZml4ZWRcIiwgbWFyZ2luVG9wOiBcIjQwcHhcIiwgY29sb3I6IFwid2hpdGVcIiB9fT57cGVyc29uRGF0YSA9PT0gdW5kZWZpbmVkID8gXCJMT0FESU5HLi4uXCIgOiBwZXJzb25EYXRhLm5hbWV9PC9oMT5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6IFwiMTAwdndcIiwgaGVpZ2h0OiBcIjEwMHZoXCIsIHBvc2l0aW9uOiBcImZpeGVkXCIsIG1hcmdpblRvcDogXCI4MHB4XCIgfX0+XG4gICAgICAgICAgICAgICAgPENyZWF0ZVVJIC8+XG4gICAgICAgICAgICAgICAgPGZvcm0gb25TdWJtaXQ9e3NlbmRDaGF0fT5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHJlZj17cmVmID0+IChzZXRDaGlsZDIocmVmKSl9PjwvaW5wdXQ+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiU3VibWl0XCI+PC9pbnB1dD5cbiAgICAgICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgICAgICAge1suLi5nYW1lRXZlbnREYXRhXS5tYXAoKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8aDQgc3R5bGU9e3sgY29sb3I6IFwid2hpdGVcIiB9fT57ZS5uYW1lfSAtIHtlLmV2ZW50fTwvaDQ+XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9KX1cblxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7IHJlY2lldmVkU2VlZCA9PT0gdW5kZWZpbmVkID8/IDxoMT5MT0FESU5HIFNFRUQhPC9oMT59XG4gICAgICAgICAgICA8ZGl2IHJlZj17cmVmID0+IChzZXRDaGlsZChyZWYpKX0+PC9kaXY+XG4gICAgICAgIDwvbWFpbj5cbiAgICApXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/test.js\n");

/***/ }),

/***/ "@hapi/hoek/lib/applyToDefaults":
/*!*************************************************!*\
  !*** external "@hapi/hoek/lib/applyToDefaults" ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@hapi/hoek/lib/applyToDefaults\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAaGFwaS9ob2VrL2xpYi9hcHBseVRvRGVmYXVsdHNcIj82ZjRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IkBoYXBpL2hvZWsvbGliL2FwcGx5VG9EZWZhdWx0cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBoYXBpL2hvZWsvbGliL2FwcGx5VG9EZWZhdWx0c1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@hapi/hoek/lib/applyToDefaults\n");

/***/ }),

/***/ "@hapi/hoek/lib/assert":
/*!****************************************!*\
  !*** external "@hapi/hoek/lib/assert" ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@hapi/hoek/lib/assert\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAaGFwaS9ob2VrL2xpYi9hc3NlcnRcIj8xYjU1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IkBoYXBpL2hvZWsvbGliL2Fzc2VydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBoYXBpL2hvZWsvbGliL2Fzc2VydFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@hapi/hoek/lib/assert\n");

/***/ }),

/***/ "@hapi/hoek/lib/clone":
/*!***************************************!*\
  !*** external "@hapi/hoek/lib/clone" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@hapi/hoek/lib/clone\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAaGFwaS9ob2VrL2xpYi9jbG9uZVwiPzQwODkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiQGhhcGkvaG9lay9saWIvY2xvbmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAaGFwaS9ob2VrL2xpYi9jbG9uZVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@hapi/hoek/lib/clone\n");

/***/ }),

/***/ "@hapi/hoek/lib/deepEqual":
/*!*******************************************!*\
  !*** external "@hapi/hoek/lib/deepEqual" ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@hapi/hoek/lib/deepEqual\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAaGFwaS9ob2VrL2xpYi9kZWVwRXF1YWxcIj82OTI5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IkBoYXBpL2hvZWsvbGliL2RlZXBFcXVhbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBoYXBpL2hvZWsvbGliL2RlZXBFcXVhbFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@hapi/hoek/lib/deepEqual\n");

/***/ }),

/***/ "@hapi/hoek/lib/error":
/*!***************************************!*\
  !*** external "@hapi/hoek/lib/error" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@hapi/hoek/lib/error\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAaGFwaS9ob2VrL2xpYi9lcnJvclwiPzk1YjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiQGhhcGkvaG9lay9saWIvZXJyb3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAaGFwaS9ob2VrL2xpYi9lcnJvclwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@hapi/hoek/lib/error\n");

/***/ }),

/***/ "@hapi/hoek/lib/escapeHtml":
/*!********************************************!*\
  !*** external "@hapi/hoek/lib/escapeHtml" ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@hapi/hoek/lib/escapeHtml\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAaGFwaS9ob2VrL2xpYi9lc2NhcGVIdG1sXCI/YjM3OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJAaGFwaS9ob2VrL2xpYi9lc2NhcGVIdG1sLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGhhcGkvaG9lay9saWIvZXNjYXBlSHRtbFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@hapi/hoek/lib/escapeHtml\n");

/***/ }),

/***/ "@hapi/hoek/lib/escapeRegex":
/*!*********************************************!*\
  !*** external "@hapi/hoek/lib/escapeRegex" ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@hapi/hoek/lib/escapeRegex\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAaGFwaS9ob2VrL2xpYi9lc2NhcGVSZWdleFwiPzZkYWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiQGhhcGkvaG9lay9saWIvZXNjYXBlUmVnZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAaGFwaS9ob2VrL2xpYi9lc2NhcGVSZWdleFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@hapi/hoek/lib/escapeRegex\n");

/***/ }),

/***/ "@hapi/hoek/lib/ignore":
/*!****************************************!*\
  !*** external "@hapi/hoek/lib/ignore" ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@hapi/hoek/lib/ignore\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAaGFwaS9ob2VrL2xpYi9pZ25vcmVcIj8zMzExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IkBoYXBpL2hvZWsvbGliL2lnbm9yZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBoYXBpL2hvZWsvbGliL2lnbm9yZVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@hapi/hoek/lib/ignore\n");

/***/ }),

/***/ "@hapi/hoek/lib/merge":
/*!***************************************!*\
  !*** external "@hapi/hoek/lib/merge" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@hapi/hoek/lib/merge\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAaGFwaS9ob2VrL2xpYi9tZXJnZVwiPzlmYTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiQGhhcGkvaG9lay9saWIvbWVyZ2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAaGFwaS9ob2VrL2xpYi9tZXJnZVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@hapi/hoek/lib/merge\n");

/***/ }),

/***/ "@hapi/hoek/lib/reach":
/*!***************************************!*\
  !*** external "@hapi/hoek/lib/reach" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@hapi/hoek/lib/reach\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAaGFwaS9ob2VrL2xpYi9yZWFjaFwiPzAwZjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiQGhhcGkvaG9lay9saWIvcmVhY2guanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAaGFwaS9ob2VrL2xpYi9yZWFjaFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@hapi/hoek/lib/reach\n");

/***/ }),

/***/ "@hapi/topo":
/*!*****************************!*\
  !*** external "@hapi/topo" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@hapi/topo\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAaGFwaS90b3BvXCI/MzFmMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJAaGFwaS90b3BvLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGhhcGkvdG9wb1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@hapi/topo\n");

/***/ }),

/***/ "@sideway/address/lib/domain":
/*!**********************************************!*\
  !*** external "@sideway/address/lib/domain" ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@sideway/address/lib/domain\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAc2lkZXdheS9hZGRyZXNzL2xpYi9kb21haW5cIj8xMDczIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IkBzaWRld2F5L2FkZHJlc3MvbGliL2RvbWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBzaWRld2F5L2FkZHJlc3MvbGliL2RvbWFpblwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@sideway/address/lib/domain\n");

/***/ }),

/***/ "@sideway/address/lib/email":
/*!*********************************************!*\
  !*** external "@sideway/address/lib/email" ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@sideway/address/lib/email\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAc2lkZXdheS9hZGRyZXNzL2xpYi9lbWFpbFwiPzY0NDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiQHNpZGV3YXkvYWRkcmVzcy9saWIvZW1haWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAc2lkZXdheS9hZGRyZXNzL2xpYi9lbWFpbFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@sideway/address/lib/email\n");

/***/ }),

/***/ "@sideway/address/lib/ip":
/*!******************************************!*\
  !*** external "@sideway/address/lib/ip" ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@sideway/address/lib/ip\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAc2lkZXdheS9hZGRyZXNzL2xpYi9pcFwiPzE4ZjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiQHNpZGV3YXkvYWRkcmVzcy9saWIvaXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAc2lkZXdheS9hZGRyZXNzL2xpYi9pcFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@sideway/address/lib/ip\n");

/***/ }),

/***/ "@sideway/address/lib/tlds":
/*!********************************************!*\
  !*** external "@sideway/address/lib/tlds" ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@sideway/address/lib/tlds\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAc2lkZXdheS9hZGRyZXNzL2xpYi90bGRzXCI/NzAxNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJAc2lkZXdheS9hZGRyZXNzL2xpYi90bGRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQHNpZGV3YXkvYWRkcmVzcy9saWIvdGxkc1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@sideway/address/lib/tlds\n");

/***/ }),

/***/ "@sideway/address/lib/uri":
/*!*******************************************!*\
  !*** external "@sideway/address/lib/uri" ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@sideway/address/lib/uri\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAc2lkZXdheS9hZGRyZXNzL2xpYi91cmlcIj84M2I4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IkBzaWRld2F5L2FkZHJlc3MvbGliL3VyaS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBzaWRld2F5L2FkZHJlc3MvbGliL3VyaVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@sideway/address/lib/uri\n");

/***/ }),

/***/ "@sideway/formula":
/*!***********************************!*\
  !*** external "@sideway/formula" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@sideway/formula\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAc2lkZXdheS9mb3JtdWxhXCI/MDNkOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJAc2lkZXdheS9mb3JtdWxhLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQHNpZGV3YXkvZm9ybXVsYVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@sideway/formula\n");

/***/ }),

/***/ "@sideway/pinpoint":
/*!************************************!*\
  !*** external "@sideway/pinpoint" ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@sideway/pinpoint\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAc2lkZXdheS9waW5wb2ludFwiPzk3MGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiQHNpZGV3YXkvcGlucG9pbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAc2lkZXdheS9waW5wb2ludFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@sideway/pinpoint\n");

/***/ }),

/***/ "camera-controls":
/*!**********************************!*\
  !*** external "camera-controls" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"camera-controls\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjYW1lcmEtY29udHJvbHNcIj9iMWVkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6ImNhbWVyYS1jb250cm9scy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNhbWVyYS1jb250cm9sc1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///camera-controls\n");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdFwiPzU4OGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoicmVhY3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWFjdFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///react\n");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react/jsx-dev-runtime\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdC9qc3gtZGV2LXJ1bnRpbWVcIj9jZDkwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6InJlYWN0L2pzeC1kZXYtcnVudGltZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlYWN0L2pzeC1kZXYtcnVudGltZVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///react/jsx-dev-runtime\n");

/***/ }),

/***/ "simplex-noise":
/*!********************************!*\
  !*** external "simplex-noise" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"simplex-noise\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzaW1wbGV4LW5vaXNlXCI/N2EzYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJzaW1wbGV4LW5vaXNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic2ltcGxleC1ub2lzZVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///simplex-noise\n");

/***/ }),

/***/ "socket.io-client":
/*!***********************************!*\
  !*** external "socket.io-client" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"socket.io-client\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzb2NrZXQuaW8tY2xpZW50XCI/OGJjNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJzb2NrZXQuaW8tY2xpZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic29ja2V0LmlvLWNsaWVudFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///socket.io-client\n");

/***/ }),

/***/ "stats.js":
/*!***************************!*\
  !*** external "stats.js" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"stats.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzdGF0cy5qc1wiP2E2OGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoic3RhdHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdGF0cy5qc1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///stats.js\n");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "three" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"three\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ0aHJlZVwiP2U4YzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoidGhyZWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0aHJlZVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///three\n");

/***/ })

/******/ });